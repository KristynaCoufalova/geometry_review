(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/math.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */ /*global JXG: true, define: true, Float32Array: true */ /*jslint nomen: true, plusplus: true, bitwise: true*/ /**
 * @fileoverview In this file the namespace JXG.Math is defined, which is the base namespace
 * for namespaces like JXG.Math.Numerics, JXG.Math.Plot, JXG.Math.Statistics, JXG.Math.Clip etc.
 */ __turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/jxg.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/utils/type.js [app-client] (ecmascript)");
;
;
var undef, /*
     * Dynamic programming approach for recursive functions.
     * From "Speed up your JavaScript, Part 3" by Nicholas C. Zakas.
     * @see JXG.Math.factorial
     * @see JXG.Math.binomial
     * http://blog.thejit.org/2008/09/05/memoization-in-javascript/
     *
     * This method is hidden, because it is only used in JXG.Math. If someone wants
     * to use it in JSXGraph outside of JXG.Math, it should be moved to jsxgraph.js
     */ memoizer = function(f) {
    var cache, join;
    if (f.memo) {
        return f.memo;
    }
    cache = {};
    join = Array.prototype.join;
    f.memo = function() {
        var key = join.call(arguments);
        // Seems to be a bit faster than "if (a in b)"
        return cache[key] !== undef ? cache[key] : cache[key] = f.apply(this, arguments);
    };
    return f.memo;
};
/**
 * Math namespace. Contains mathematics related methods which are
 * specific to JSXGraph or which extend the JavaScript Math class.
 * @namespace
 */ __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Math = {
    /**
     * eps defines the closeness to zero. If the absolute value of a given number is smaller
     * than eps, it is considered to be equal to zero.
     * @type Number
     */ eps: 0.000001,
    /**
     * Determine the relative difference between two numbers.
     * @param  {Number} a First number
     * @param  {Number} b Second number
     * @returns {Number}  Relative difference between a and b: |a-b| / max(|a|, |b|)
     */ relDif: function(a, b) {
        var c = Math.abs(a), d = Math.abs(b);
        d = Math.max(c, d);
        return d === 0.0 ? 0.0 : Math.abs(a - b) / d;
    },
    /**
     * The JavaScript implementation of the % operator returns the symmetric modulo.
     * mod and "%" are both identical if a >= 0 and m >= 0 but the results differ if a or m < 0.
     * @param {Number} a
     * @param {Number} m
     * @returns {Number} Mathematical modulo <tt>a mod m</tt>
     */ mod: function(a, m) {
        return a - Math.floor(a / m) * m;
    },
    /**
     * Translate <code>x</code> into the interval <code>[a, b)</code> by adding
     * a multiple of <code>b - a</code>.
     * @param {Number} x
     * @param {Number} a
     * @param {Number} b
     */ wrap: function(x, a, b) {
        return a + this.mod(x - a, b - a);
    },
    /**
     * Clamp <code>x</code> within the interval <code>[a, b]</code>. If
     * <code>x</code> is below <code>a</code>, increase it to <code>a</code>. If
     * it's above <code>b</code>, decrease it to <code>b</code>.
     */ clamp: function(x, a, b) {
        return Math.min(Math.max(x, a), b);
    },
    /**
     * A way of clamping a periodic variable. If <code>x</code> is congruent mod
     * <code>period</code> to a point in <code>[a, b]</code>, return that point.
     * Otherwise, wrap it into <code>[mid - period/2, mid + period/2]</code>,
     * where <code>mid</code> is the mean of <code>a</code> and <code>b</code>,
     * and then clamp it to <code>[a, b]</code> from there.
     */ wrapAndClamp: function(x, a, b, period) {
        var mid = 0.5 * (a + b), half_period = 0.5 * period;
        return this.clamp(this.wrap(x, mid - half_period, mid + half_period), a, b);
    },
    /**
     * Initializes a vector of size <tt>n</tt> wih coefficients set to the init value (default 0)
     * @param {Number} n Length of the vector
     * @param {Number} [init=0] Initial value for each coefficient
     * @returns {Array} An array of length <tt>n</tt>
     */ vector: function(n, init) {
        var r, i;
        init = init || 0;
        r = [];
        for(i = 0; i < n; i++){
            r[i] = init;
        }
        return r;
    },
    /**
     * Initializes a matrix as an array of rows with the given value.
     * @param {Number} n Number of rows
     * @param {Number} [m=n] Number of columns
     * @param {Number} [init=0] Initial value for each coefficient
     * @returns {Array} A <tt>n</tt> times <tt>m</tt>-matrix represented by a
     * two-dimensional array. The inner arrays hold the columns, the outer array holds the rows.
     */ matrix: function(n, m, init) {
        var r, i, j;
        init = init || 0;
        m = m || n;
        r = [];
        for(i = 0; i < n; i++){
            r[i] = [];
            for(j = 0; j < m; j++){
                r[i][j] = init;
            }
        }
        return r;
    },
    /**
     * Generates an identity matrix. If n is a number and m is undefined or not a number, a square matrix is generated,
     * if n and m are both numbers, an nxm matrix is generated.
     * @param {Number} n Number of rows
     * @param {Number} [m=n] Number of columns
     * @returns {Array} A square matrix of length <tt>n</tt> with all coefficients equal to 0 except a_(i,i), i out of (1, ..., n), if <tt>m</tt> is undefined or not a number
     * or a <tt>n</tt> times <tt>m</tt>-matrix with a_(i,j) = 0 and a_(i,i) = 1 if m is a number.
     */ identity: function(n, m) {
        var r, i;
        if (m === undef && typeof m !== "number") {
            m = n;
        }
        r = this.matrix(n, m);
        for(i = 0; i < Math.min(n, m); i++){
            r[i][i] = 1;
        }
        return r;
    },
    /**
     * Generates a 4x4 matrix for 3D to 2D projections.
     * @param {Number} l Left
     * @param {Number} r Right
     * @param {Number} t Top
     * @param {Number} b Bottom
     * @param {Number} n Near
     * @param {Number} f Far
     * @returns {Array} 4x4 Matrix
     */ frustum: function(l, r, b, t, n, f) {
        var ret = this.matrix(4, 4);
        ret[0][0] = n * 2 / (r - l);
        ret[0][1] = 0;
        ret[0][2] = (r + l) / (r - l);
        ret[0][3] = 0;
        ret[1][0] = 0;
        ret[1][1] = n * 2 / (t - b);
        ret[1][2] = (t + b) / (t - b);
        ret[1][3] = 0;
        ret[2][0] = 0;
        ret[2][1] = 0;
        ret[2][2] = -(f + n) / (f - n);
        ret[2][3] = -(f * n * 2) / (f - n);
        ret[3][0] = 0;
        ret[3][1] = 0;
        ret[3][2] = -1;
        ret[3][3] = 0;
        return ret;
    },
    /**
     * Generates a 4x4 matrix for 3D to 2D projections.
     * @param {Number} fov Field of view in vertical direction, given in rad.
     * @param {Number} ratio Aspect ratio of the projection plane.
     * @param {Number} n Near
     * @param {Number} f Far
     * @returns {Array} 4x4 Projection Matrix
     */ projection: function(fov, ratio, n, f) {
        var t = n * Math.tan(fov / 2), r = t * ratio;
        return this.frustum(-r, r, -t, t, n, f);
    },
    /**
     * Multiplies a vector vec to a matrix mat: mat * vec. The matrix is interpreted by this function as an array of rows.
     * Please note: This
     * function does not check if the dimensions match.
     * @param {Array} mat Two-dimensional array of numbers. The inner arrays describe the columns, the outer ones the matrix' rows.
     * @param {Array} vec Array of numbers
     * @returns {Array} Array of numbers containing the result
     * @example
     * var A = [[2, 1],
     *          [2, 3]],
     *     b = [4, 5],
     *     c;
     * c = JXG.Math.matVecMult(A, b);
     * // c === [13, 23];
     */ matVecMult: function(mat, vec) {
        var i, k, s, m = mat.length, n = vec.length, res = [];
        if (n === 3) {
            for(i = 0; i < m; i++){
                res[i] = mat[i][0] * vec[0] + mat[i][1] * vec[1] + mat[i][2] * vec[2];
            }
        } else {
            for(i = 0; i < m; i++){
                s = 0;
                for(k = 0; k < n; k++){
                    s += mat[i][k] * vec[k];
                }
                res[i] = s;
            }
        }
        return res;
    },
    /**
     * Multiplies a vector vec to a matrix mat from the left: vec * mat.
     * The matrix is interpreted by this function as an array of rows.
     * Please note: This function does not check if the dimensions match.
     * @param {Array} vec Array of numbers
     * @param {Array} mat Two-dimensional array of numbers. The inner arrays describe the columns,
     *  the outer ones the matrix' rows.
     * @returns {Array} Array of numbers containing the result
     * @example
     * var A = [[2, 1],
     *          [2, 3]],
     *     b = [4, 5],
     *     c;
     * c = JXG.Math.vecMatMult(b, A);
     * // c === [18, 16];
     */ vecMatMult: function(vec, mat) {
        var i, k, s, m = mat.length, n = vec.length, res = [];
        if (n === 3) {
            for(i = 0; i < m; i++){
                res[i] = vec[0] * mat[0][i] + vec[1] * mat[1][i] + vec[2] * mat[2][i];
            }
        } else {
            for(i = 0; i < n; i++){
                s = 0;
                for(k = 0; k < m; k++){
                    s += vec[k] * mat[k][i];
                }
                res[i] = s;
            }
        }
        return res;
    },
    /**
     * Computes the product of the two matrices: mat1 * mat2.
     * Returns a new matrix array.
     *
     * @param {Array} mat1 Two-dimensional array of numbers
     * @param {Array} mat2 Two-dimensional array of numbers
     * @returns {Array} Two-dimensional Array of numbers containing result
     */ matMatMult: function(mat1, mat2) {
        var i, j, s, k, m = mat1.length, n = m > 0 ? mat2[0].length : 0, m2 = mat2.length, res = this.matrix(m, n);
        for(i = 0; i < m; i++){
            for(j = 0; j < n; j++){
                s = 0;
                for(k = 0; k < m2; k++){
                    s += mat1[i][k] * mat2[k][j];
                }
                res[i][j] = s;
            }
        }
        return res;
    },
    /**
     * Multiply a matrix mat by a scalar alpha: mat * scalar
     *
     * @param {Array} mat Two-dimensional array of numbers
     * @param {Number} alpha Scalar
     * @returns {Array} Two-dimensional Array of numbers containing result
     */ matNumberMult: function(mat, alpha) {
        var i, j, m = mat.length, n = m > 0 ? mat[0].length : 0, res = this.matrix(m, n);
        for(i = 0; i < m; i++){
            for(j = 0; j < n; j++){
                res[i][j] = mat[i][j] * alpha;
            }
        }
        return res;
    },
    /**
     * Compute the sum of two matrices: mat1 + mat2.
     * Returns a new matrix object.
     *
     * @param {Array} mat1 Two-dimensional array of numbers
     * @param {Array} mat2 Two-dimensional array of numbers
     * @returns {Array} Two-dimensional Array of numbers containing result
     */ matMatAdd: function(mat1, mat2) {
        var i, j, m = mat1.length, n = m > 0 ? mat1[0].length : 0, res = this.matrix(m, n);
        for(i = 0; i < m; i++){
            for(j = 0; j < n; j++){
                res[i][j] = mat1[i][j] + mat2[i][j];
            }
        }
        return res;
    },
    /**
     * Transposes a matrix given as a two-dimensional array.
     * @param {Array} M The matrix to be transposed
     * @returns {Array} The transpose of M
     */ transpose: function(M) {
        var MT, i, j, m, n;
        // number of rows of M
        m = M.length;
        // number of columns of M
        n = M.length > 0 ? M[0].length : 0;
        MT = this.matrix(n, m);
        for(i = 0; i < n; i++){
            for(j = 0; j < m; j++){
                MT[i][j] = M[j][i];
            }
        }
        return MT;
    },
    /**
     * Compute the inverse of an <i>(n x n)</i>-matrix by Gauss elimination.
     *
     * @param {Array} A matrix
     * @returns {Array} Inverse matrix of A or empty array (i.e. []) in case A is singular.
     */ inverse: function(Ain) {
        var i, j, k, r, s, eps = this.eps * this.eps, ma, swp, n = Ain.length, A = [], p = [], hv = [];
        for(i = 0; i < n; i++){
            A[i] = [];
            for(j = 0; j < n; j++){
                A[i][j] = Ain[i][j];
            }
            p[i] = i;
        }
        for(j = 0; j < n; j++){
            // Pivot search
            ma = Math.abs(A[j][j]);
            r = j;
            for(i = j + 1; i < n; i++){
                if (Math.abs(A[i][j]) > ma) {
                    ma = Math.abs(A[i][j]);
                    r = i;
                }
            }
            // Singular matrix
            if (ma <= eps) {
                __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].warn('JXG.Math.inverse: singular matrix');
                return [];
            }
            // swap rows:
            if (r > j) {
                for(k = 0; k < n; k++){
                    swp = A[j][k];
                    A[j][k] = A[r][k];
                    A[r][k] = swp;
                }
                swp = p[j];
                p[j] = p[r];
                p[r] = swp;
            }
            // transformation:
            s = 1.0 / A[j][j];
            for(i = 0; i < n; i++){
                A[i][j] *= s;
            }
            A[j][j] = s;
            for(k = 0; k < n; k++){
                if (k !== j) {
                    for(i = 0; i < n; i++){
                        if (i !== j) {
                            A[i][k] -= A[i][j] * A[j][k];
                        }
                    }
                    A[j][k] = -s * A[j][k];
                }
            }
        }
        // swap columns:
        for(i = 0; i < n; i++){
            for(k = 0; k < n; k++){
                hv[p[k]] = A[i][k];
            }
            for(k = 0; k < n; k++){
                A[i][k] = hv[k];
            }
        }
        return A;
    },
    /**
     * Trace of a square matrix, given as a two-dimensional array.
     * @param {Array} M Square matrix
     * @returns {Number} The trace of M, NaN if M is not square.
     */ trace: function(M) {
        var i, m, n, t = 0.0;
        // number of rows of M
        m = M.length;
        // number of columns of M
        n = M.length > 0 ? M[0].length : 0;
        if (m !== n) {
            return NaN;
        }
        for(i = 0; i < n; i++){
            t += M[i][i];
        }
        return t;
    },
    /**
     * Inner product of two vectors a and b. n is the length of the vectors.
     * @param {Array} a Vector
     * @param {Array} b Vector
     * @param {Number} [n] Length of the Vectors. If not given the length of the first vector is taken.
     * @returns {Number} The inner product of a and b.
     */ innerProduct: function(a, b, n) {
        var i, s = 0;
        if (n === undef || !__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(n)) {
            n = a.length;
        }
        for(i = 0; i < n; i++){
            s += a[i] * b[i];
        }
        return s;
    },
    /**
     * Calculates the cross product of two vectors both of length three.
     * In case of homogeneous coordinates this is either
     * <ul>
     * <li>the intersection of two lines</li>
     * <li>the line through two points</li>
     * </ul>
     * @param {Array} c1 Homogeneous coordinates of line or point 1
     * @param {Array} c2 Homogeneous coordinates of line or point 2
     * @returns {Array} vector of length 3: homogeneous coordinates of the resulting point / line.
     */ crossProduct: function(c1, c2) {
        return [
            c1[1] * c2[2] - c1[2] * c2[1],
            c1[2] * c2[0] - c1[0] * c2[2],
            c1[0] * c2[1] - c1[1] * c2[0]
        ];
    },
    /**
     * Euclidean norm of a vector.
     *
     * @param {Array} a Array containing a vector.
     * @param {Number} n (Optional) length of the array.
     * @returns {Number} Euclidean norm of the vector.
     */ norm: function(a, n) {
        var i, sum = 0.0;
        if (n === undef || !__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(n)) {
            n = a.length;
        }
        for(i = 0; i < n; i++){
            sum += a[i] * a[i];
        }
        return Math.sqrt(sum);
    },
    /**
     * Compute a * x + y for a scalar a and vectors x and y.
     *
     * @param {Number} a
     * @param {Array} x
     * @param {Array} y
     * @returns {Array}
     */ axpy: function(a, x, y) {
        var i, le = x.length, p = [];
        for(i = 0; i < le; i++){
            p[i] = a * x[i] + y[i];
        }
        return p;
    },
    /**
     * Compute the factorial of a positive integer. If a non-integer value
     * is given, the fraction will be ignored.
     * @function
     * @param {Number} n
     * @returns {Number} n! = n*(n-1)*...*2*1
     */ factorial: memoizer(function(n) {
        if (n < 0) {
            return NaN;
        }
        n = Math.floor(n);
        if (n === 0 || n === 1) {
            return 1;
        }
        return n * this.factorial(n - 1);
    }),
    /**
     * Computes the binomial coefficient n over k.
     * @function
     * @param {Number} n Fraction will be ignored
     * @param {Number} k Fraction will be ignored
     * @returns {Number} The binomial coefficient n over k
     */ binomial: memoizer(function(n, k) {
        var b, i;
        if (k > n || k < 0) {
            return NaN;
        }
        k = Math.round(k);
        n = Math.round(n);
        if (k === 0 || k === n) {
            return 1;
        }
        b = 1;
        for(i = 0; i < k; i++){
            b *= n - i;
            b /= i + 1;
        }
        return b;
    }),
    /**
     * Calculates the cosine hyperbolicus of x.
     * @function
     * @param {Number} x The number the cosine hyperbolicus will be calculated of.
     * @returns {Number} Cosine hyperbolicus of the given value.
     */ cosh: Math.cosh || function(x) {
        return (Math.exp(x) + Math.exp(-x)) * 0.5;
    },
    /**
     * Sine hyperbolicus of x.
     * @function
     * @param {Number} x The number the sine hyperbolicus will be calculated of.
     * @returns {Number} Sine hyperbolicus of the given value.
     */ sinh: Math.sinh || function(x) {
        return (Math.exp(x) - Math.exp(-x)) * 0.5;
    },
    /**
     * Hyperbolic arc-cosine of a number.
     * @function
     * @param {Number} x
     * @returns {Number}
     */ acosh: Math.acosh || function(x) {
        return Math.log(x + Math.sqrt(x * x - 1));
    },
    /**
     * Hyperbolic arcsine of a number
     * @function
     * @param {Number} x
     * @returns {Number}
     */ asinh: Math.asinh || function(x) {
        if (x === -Infinity) {
            return x;
        }
        return Math.log(x + Math.sqrt(x * x + 1));
    },
    /**
     * Computes the cotangent of x.
     * @function
     * @param {Number} x The number the cotangent will be calculated of.
     * @returns {Number} Cotangent of the given value.
     */ cot: function(x) {
        return 1 / Math.tan(x);
    },
    /**
     * Computes the inverse cotangent of x.
     * @param {Number} x The number the inverse cotangent will be calculated of.
     * @returns {Number} Inverse cotangent of the given value.
     */ acot: function(x) {
        return (x >= 0 ? 0.5 : -0.5) * Math.PI - Math.atan(x);
    },
    /**
     * Compute n-th real root of a real number. n must be strictly positive integer.
     * If n is odd, the real n-th root exists and is negative.
     * For n even, for negative valuees of x NaN is returned
     * @param  {Number} x radicand. Must be non-negative, if n even.
     * @param  {Number} n index of the root. must be strictly positive integer.
     * @returns {Number} returns real root or NaN
     *
     * @example
     * nthroot(16, 4): 2
     * nthroot(-27, 3): -3
     * nthroot(-4, 2): NaN
     */ nthroot: function(x, n) {
        var inv = 1 / n;
        if (n <= 0 || Math.floor(n) !== n) {
            return NaN;
        }
        if (x === 0.0) {
            return 0.0;
        }
        if (x > 0) {
            return Math.exp(inv * Math.log(x));
        }
        // From here on, x is negative
        if (n % 2 === 1) {
            return -Math.exp(inv * Math.log(-x));
        }
        // x negative, even root
        return NaN;
    },
    /**
     * Computes cube root of real number
     * Polyfill for Math.cbrt().
     *
     * @function
     * @param  {Number} x Radicand
     * @returns {Number} Cube root of x.
     */ cbrt: Math.cbrt || function(x) {
        return this.nthroot(x, 3);
    },
    /**
     * Compute base to the power of exponent.
     * @param {Number} base
     * @param {Number} exponent
     * @returns {Number} base to the power of exponent.
     */ pow: function(base, exponent) {
        if (base === 0) {
            if (exponent === 0) {
                return 1;
            }
            return 0;
        }
        // exponent is an integer
        if (Math.floor(exponent) === exponent) {
            return Math.pow(base, exponent);
        }
        // exponent is not an integer
        if (base > 0) {
            return Math.exp(exponent * Math.log(base));
        }
        return NaN;
    },
    /**
     * Compute base to the power of the rational exponent m / n.
     * This function first reduces the fraction m/n and then computes
     * JXG.Math.pow(base, m/n).
     *
     * This function is necessary to have the same results for e.g.
     * (-8)^(1/3) = (-8)^(2/6) = -2
     * @param {Number} base
     * @param {Number} m numerator of exponent
     * @param {Number} n denominator of exponent
     * @returns {Number} base to the power of exponent.
     */ ratpow: function(base, m, n) {
        var g;
        if (m === 0) {
            return 1;
        }
        if (n === 0) {
            return NaN;
        }
        g = this.gcd(m, n);
        return this.nthroot(this.pow(base, m / g), n / g);
    },
    /**
     * Logarithm to base 10.
     * @param {Number} x
     * @returns {Number} log10(x) Logarithm of x to base 10.
     */ log10: function(x) {
        return Math.log(x) / Math.log(10.0);
    },
    /**
     * Logarithm to base 2.
     * @param {Number} x
     * @returns {Number} log2(x) Logarithm of x to base 2.
     */ log2: function(x) {
        return Math.log(x) / Math.log(2.0);
    },
    /**
     * Logarithm to arbitrary base b. If b is not given, natural log is taken, i.e. b = e.
     * @param {Number} x
     * @param {Number} b base
     * @returns {Number} log(x, b) Logarithm of x to base b, that is log(x)/log(b).
     */ log: function(x, b) {
        if (b !== undefined && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(b)) {
            return Math.log(x) / Math.log(b);
        }
        return Math.log(x);
    },
    /**
     * The sign() function returns the sign of a number, indicating whether the number is positive, negative or zero.
     *
     * @function
     * @param  {Number} x A Number
     * @returns {Number}  This function has 5 kinds of return values,
     *    1, -1, 0, -0, NaN, which represent "positive number", "negative number", "positive zero", "negative zero"
     *    and NaN respectively.
     */ sign: Math.sign || function(x) {
        x = +x; // convert to a number
        if (x === 0 || isNaN(x)) {
            return x;
        }
        return x > 0 ? 1 : -1;
    },
    /**
     * A square & multiply algorithm to compute base to the power of exponent.
     * Implementated by Wolfgang Riedl.
     *
     * @param {Number} base
     * @param {Number} exponent
     * @returns {Number} Base to the power of exponent
     */ squampow: function(base, exponent) {
        var result;
        if (Math.floor(exponent) === exponent) {
            // exponent is integer (could be zero)
            result = 1;
            if (exponent < 0) {
                // invert: base
                base = 1.0 / base;
                exponent *= -1;
            }
            while(exponent !== 0){
                if (exponent & 1) {
                    result *= base;
                }
                exponent >>= 1;
                base *= base;
            }
            return result;
        }
        return this.pow(base, exponent);
    },
    /**
     * Greatest common divisor (gcd) of two numbers.
     * See {@link <a href="https://rosettacode.org/wiki/Greatest_common_divisor#JavaScript">rosettacode.org</a>}.
     *
     * @param  {Number} a First number
     * @param  {Number} b Second number
     * @returns {Number}   gcd(a, b) if a and b are numbers, NaN else.
     */ gcd: function(a, b) {
        var tmp, endless = true;
        a = Math.abs(a);
        b = Math.abs(b);
        if (!(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(a) && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(b))) {
            return NaN;
        }
        if (b > a) {
            tmp = a;
            a = b;
            b = tmp;
        }
        while(endless){
            a %= b;
            if (a === 0) {
                return b;
            }
            b %= a;
            if (b === 0) {
                return a;
            }
        }
    },
    /**
     * Least common multiple (lcm) of two numbers.
     *
     * @param  {Number} a First number
     * @param  {Number} b Second number
     * @returns {Number}   lcm(a, b) if a and b are numbers, NaN else.
     */ lcm: function(a, b) {
        var ret;
        if (!(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(a) && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(b))) {
            return NaN;
        }
        ret = a * b;
        if (ret !== 0) {
            return ret / this.gcd(a, b);
        }
        return 0;
    },
    /**
     * Special use of Math.round function to round not only to integers but also to chosen decimal values.
     *
     * @param {Number} value Value to be rounded.
     * @param {Number} step Distance between the values to be rounded to. (default: 1.0)
     * @param {Number} [min] If set, it will be returned the maximum of value and min.
     * @param {Number} [max] If set, it will be returned the minimum of value and max.
     * @returns {Number} Fitted value.
     */ roundToStep: function(value, step, min, max) {
        var n = value, tmp, minOr0;
        // for performance
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(step) && !__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(min) && !__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(max)) {
            return n;
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(max)) {
            n = Math.min(n, max);
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(min)) {
            n = Math.max(n, min);
        }
        minOr0 = min || 0;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(step)) {
            tmp = (n - minOr0) / step;
            if (Number.isInteger(tmp)) {
                return n;
            }
            tmp = Math.round(tmp);
            n = minOr0 + tmp * step;
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(max)) {
            n = Math.min(n, max);
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(min)) {
            n = Math.max(n, min);
        }
        return n;
    },
    /**
     *  Error function, see {@link https://en.wikipedia.org/wiki/Error_function}.
     *
     * @see JXG.Math.ProbFuncs.erf
     * @param  {Number} x
     * @returns {Number}
     */ erf: function(x) {
        return this.ProbFuncs.erf(x);
    },
    /**
     * Complementary error function, i.e. 1 - erf(x).
     *
     * @see JXG.Math.erf
     * @see JXG.Math.ProbFuncs.erfc
     * @param  {Number} x
     * @returns {Number}
     */ erfc: function(x) {
        return this.ProbFuncs.erfc(x);
    },
    /**
     * Inverse of error function
     *
     * @see JXG.Math.erf
     * @see JXG.Math.ProbFuncs.erfi
     * @param  {Number} x
     * @returns {Number}
     */ erfi: function(x) {
        return this.ProbFuncs.erfi(x);
    },
    /**
     * Normal distribution function
     *
     * @see JXG.Math.ProbFuncs.ndtr
     * @param  {Number} x
     * @returns {Number}
     */ ndtr: function(x) {
        return this.ProbFuncs.ndtr(x);
    },
    /**
     * Inverse of normal distribution function
     *
     * @see JXG.Math.ndtr
     * @see JXG.Math.ProbFuncs.ndtri
     * @param  {Number} x
     * @returns {Number}
     */ ndtri: function(x) {
        return this.ProbFuncs.ndtri(x);
    },
    /**
     * Returns sqrt(a * a + b * b) for a variable number of arguments.
     * This is a naive implementation which might be faster than Math.hypot.
     * The latter is numerically more stable.
     *
     * @param {Number} a Variable number of arguments.
     * @returns Number
     */ hypot: function() {
        var i, le, a, sum;
        le = arguments.length;
        for(i = 0, sum = 0.0; i < le; i++){
            a = arguments[i];
            sum += a * a;
        }
        return Math.sqrt(sum);
    },
    /**
     * Heaviside unit step function. Returns 0 for x &lt;, 1 for x &gt; 0, and 0.5 for x == 0.
     *
     * @param {Number} x
     * @returns Number
     */ hstep: function(x) {
        return x > 0.0 ? 1 : x < 0.0 ? 0.0 : 0.5;
    },
    /**
     * Gamma function for real parameters by Lanczos approximation.
     * Implementation straight from {@link https://en.wikipedia.org/wiki/Lanczos_approximation}.
     *
     * @param {Number} z
     * @returns Number
     */ gamma: function(z) {
        var x, y, t, i, le, g = 7, // n = 9,
        p = [
            1.0,
            676.5203681218851,
            -1259.1392167224028,
            771.32342877765313,
            -176.61502916214059,
            12.507343278686905,
            -0.13857109526572012,
            9.9843695780195716e-6,
            1.5056327351493116e-7
        ];
        if (z < 0.5) {
            y = Math.PI / (Math.sin(Math.PI * z) * this.gamma(1 - z)); // Reflection formula
        } else {
            z -= 1;
            x = p[0];
            le = p.length;
            for(i = 1; i < le; i++){
                x += p[i] / (z + i);
            }
            t = z + g + 0.5;
            y = Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
        }
        return y;
    },
    /* ********************  Comparisons and logical operators ************** */ /**
     * Logical test: a < b?
     *
     * @param {Number} a
     * @param {Number} b
     * @returns {Boolean}
     */ lt: function(a, b) {
        return a < b;
    },
    /**
     * Logical test: a <= b?
     *
     * @param {Number} a
     * @param {Number} b
     * @returns {Boolean}
     */ leq: function(a, b) {
        return a <= b;
    },
    /**
     * Logical test: a > b?
     *
     * @param {Number} a
     * @param {Number} b
     * @returns {Boolean}
     */ gt: function(a, b) {
        return a > b;
    },
    /**
     * Logical test: a >= b?
     *
     * @param {Number} a
     * @param {Number} b
     * @returns {Boolean}
     */ geq: function(a, b) {
        return a >= b;
    },
    /**
     * Logical test: a === b?
     *
     * @param {Number} a
     * @param {Number} b
     * @returns {Boolean}
     */ eq: function(a, b) {
        return a === b;
    },
    /**
     * Logical test: a !== b?
     *
     * @param {Number} a
     * @param {Number} b
     * @returns {Boolean}
     */ neq: function(a, b) {
        return a !== b;
    },
    /**
     * Logical operator: a && b?
     *
     * @param {Boolean} a
     * @param {Boolean} b
     * @returns {Boolean}
     */ and: function(a, b) {
        return a && b;
    },
    /**
     * Logical operator: !a?
     *
     * @param {Boolean} a
     * @returns {Boolean}
     */ not: function(a) {
        return !a;
    },
    /**
     * Logical operator: a || b?
     *
     * @param {Boolean} a
     * @param {Boolean} b
     * @returns {Boolean}
     */ or: function(a, b) {
        return a || b;
    },
    /**
     * Logical operator: either a or b?
     *
     * @param {Boolean} a
     * @param {Boolean} b
     * @returns {Boolean}
     */ xor: function(a, b) {
        return (a || b) && !(a && b);
    },
    /**
     *
     * Convert a floating point number to sign + integer + fraction.
     * fraction is given as nominator and denominator.
     * <p>
     * Algorithm: approximate the floating point number
     * by a continued fraction and simultaneously keep track
     * of its convergents.
     * Inspired by {@link https://kevinboone.me/rationalize.html}.
     *
     * @param {Number} x Number which is to be converted
     * @param {Number} [order=0.001] Small number determining the approximation precision.
     * @returns {Array} [sign, leading, nominator, denominator] where sign is 1 or -1.
     * @see JXG.toFraction
     *
     * @example
     * JXG.Math.decToFraction(0.33333333);
     * // Result: [ 1, 0, 1, 3 ]
     *
     * JXG.Math.decToFraction(0);
     * // Result: [ 1, 0, 0, 1 ]
     *
     * JXG.Math.decToFraction(-10.66666666666667);
     * // Result: [-1, 10, 2, 3 ]
    */ decToFraction: function(x, order) {
        var lead, sign, a, n, n1, n2, d, d1, d2, it = 0, maxit = 20;
        order = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].def(order, 0.001);
        // Round the number.
        // Otherwise, 0.999999999 would result in [0, 1, 1].
        x = Math.round(x * 1.e12) * 1.e-12;
        // Negative numbers:
        // The minus sign is handled in sign.
        sign = x < 0 ? -1 : 1;
        x = Math.abs(x);
        // From now on we consider x to be nonnegative.
        lead = Math.floor(x);
        x -= Math.floor(x);
        a = 0.0;
        n2 = 1.0;
        n = n1 = a;
        d2 = 0.0;
        d = d1 = 1.0;
        while(x - Math.floor(x) > order && it < maxit){
            x = 1 / (x - a);
            a = Math.floor(x);
            n = n2 + a * n1;
            d = d2 + a * d1;
            n2 = n1;
            d2 = d1;
            n1 = n;
            d1 = d;
            it++;
        }
        return [
            sign,
            lead,
            n,
            d
        ];
    },
    /* *************************** Normalize *************************** */ /**
     * Normalize the standard form [c, b0, b1, a, k, r, q0, q1].
     * @private
     * @param {Array} stdform The standard form to be normalized.
     * @returns {Array} The normalized standard form.
     */ normalize: function(stdform) {
        var n, signr, a2 = 2 * stdform[3], r = stdform[4] / a2;
        stdform[5] = r;
        stdform[6] = -stdform[1] / a2;
        stdform[7] = -stdform[2] / a2;
        if (!isFinite(r)) {
            n = this.hypot(stdform[1], stdform[2]);
            stdform[0] /= n;
            stdform[1] /= n;
            stdform[2] /= n;
            stdform[3] = 0;
            stdform[4] = 1;
        } else if (Math.abs(r) >= 1) {
            stdform[0] = (stdform[6] * stdform[6] + stdform[7] * stdform[7] - r * r) / (2 * r);
            stdform[1] = -stdform[6] / r;
            stdform[2] = -stdform[7] / r;
            stdform[3] = 1 / (2 * r);
            stdform[4] = 1;
        } else {
            signr = r <= 0 ? -1 : 1;
            stdform[0] = signr * (stdform[6] * stdform[6] + stdform[7] * stdform[7] - r * r) * 0.5;
            stdform[1] = -signr * stdform[6];
            stdform[2] = -signr * stdform[7];
            stdform[3] = signr / 2;
            stdform[4] = signr * r;
        }
        return stdform;
    },
    /**
     * Converts a two-dimensional array to a one-dimensional Float32Array that can be processed by WebGL.
     * @param {Array} m A matrix in a two-dimensional array.
     * @returns {Float32Array} A one-dimensional array containing the matrix in column wise notation. Provides a fall
     * back to the default JavaScript Array if Float32Array is not available.
     */ toGL: function(m) {
        var v, i, j;
        if (typeof Float32Array === "function") {
            v = new Float32Array(16);
        } else {
            v = new Array(16);
        }
        if (m.length !== 4 && m[0].length !== 4) {
            return v;
        }
        for(i = 0; i < 4; i++){
            for(j = 0; j < 4; j++){
                v[i + 4 * j] = m[i][j];
            }
        }
        return v;
    },
    /**
     * Theorem of Vieta: Given a set of simple zeroes x_0, ..., x_n
     * of a polynomial f, compute the coefficients s_k, (k=0,...,n-1)
     * of the polynomial of the form. See {@link https://de.wikipedia.org/wiki/Elementarsymmetrisches_Polynom}.
     * <p>
     *  f(x) = (x-x_0)*...*(x-x_n) =
     *  x^n + sum_{k=1}^{n} (-1)^(k) s_{k-1} x^(n-k)
     * </p>
     * @param {Array} x Simple zeroes of the polynomial.
     * @returns {Array} Coefficients of the polynomial.
     *
     */ Vieta: function(x) {
        var n = x.length, s = [], m, k, y;
        s = x.slice();
        for(m = 1; m < n; ++m){
            y = s[m];
            s[m] *= s[m - 1];
            for(k = m - 1; k >= 1; --k){
                s[k] += s[k - 1] * y;
            }
            s[0] += y;
        }
        return s;
    }
};
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Math;
}),
"[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/probfuncs.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Carsten Miller,
        Andreas Walter,
        Alfred Wassermann

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */ /*global JXG: true, define: true*/ /*jslint nomen: true, plusplus: true*/ /*eslint no-loss-of-precision: off */ __turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/math.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/utils/type.js [app-client] (ecmascript)");
;
;
/**
 * Probability functions, e.g. error function,
 * see: https://en.wikipedia.org/wiki/Error_function
 * Ported from
 * by https://github.com/jeremybarnes/cephes/blob/master/cprob/ndtr.c,
 *
 * Cephes Math Library Release 2.9:  November, 2000
 * Copyright 1984, 1987, 1988, 1992, 2000 by Stephen L. Moshier
 *
 * @name JXG.Math.ProbFuncs
 * @exports Mat.ProbFuncs as JXG.Math.ProbFuncs
 * @namespace
 */ __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ProbFuncs = {
    MAXNUM: 1.701411834604692317316873e38,
    SQRTH: 7.07106781186547524401e-1,
    SQRT2: 1.4142135623730950488,
    MAXLOG: 7.08396418532264106224e2,
    P: [
        2.46196981473530512524e-10,
        5.64189564831068821977e-1,
        7.46321056442269912687,
        4.86371970985681366614e1,
        1.96520832956077098242e2,
        5.26445194995477358631e2,
        9.3452852717195760754e2,
        1.02755188689515710272e3,
        5.57535335369399327526e2
    ],
    Q: [
        1.32281951154744992508e1,
        8.67072140885989742329e1,
        3.54937778887819891062e2,
        9.75708501743205489753e2,
        1.82390916687909736289e3,
        2.24633760818710981792e3,
        1.65666309194161350182e3,
        5.57535340817727675546e2
    ],
    R: [
        5.64189583547755073984e-1,
        1.27536670759978104416,
        5.01905042251180477414,
        6.16021097993053585195,
        7.4097426995044893916,
        2.9788666537210024067
    ],
    S: [
        2.2605286322011727659,
        9.39603524938001434673,
        1.20489539808096656605e1,
        1.70814450747565897222e1,
        9.60896809063285878198,
        3.3690764510008151605
    ],
    T: [
        9.60497373987051638749,
        9.00260197203842689217e1,
        2.23200534594684319226e3,
        7.00332514112805075473e3,
        5.55923013010394962768e4
    ],
    U: [
        3.35617141647503099647e1,
        5.21357949780152679795e2,
        4.59432382970980127987e3,
        2.26290000613890934246e4,
        4.92673942608635921086e4
    ],
    // UTHRESH: 37.519379347,
    M: 128.0,
    MINV: 0.0078125,
    /**
     *
     *	Exponential of squared argument
     *
     * SYNOPSIS:
     *
     * double x, y, expx2();
     * int sign;
     *
     * y = expx2( x, sign );
     *
     *
     *
     * DESCRIPTION:
     *
     * Computes y = exp(x*x) while suppressing error amplification
     * that would ordinarily arise from the inexactness of the
     * exponential argument x*x.
     *
     * If sign < 0, the result is inverted; i.e., y = exp(-x*x) .
     *
     *
     * ACCURACY:
     *
     *                      Relative error:
     * arithmetic    domain     # trials      peak         rms
     *   IEEE      -26.6, 26.6    10^7       3.9e-16     8.9e-17
     *
     * @private
     * @param  {Number} x
     * @param  {Number} sign (int)
     * @returns {Number}
     */ expx2: function(x, sign) {
        // double x;
        // int sign;
        var u, u1, m, f;
        x = Math.abs(x);
        if (sign < 0) {
            x = -x;
        }
        // Represent x as an exact multiple of M plus a residual.
        //    M is a power of 2 chosen so that exp(m * m) does not overflow
        //    or underflow and so that |x - m| is small.
        m = this.MINV * Math.floor(this.M * x + 0.5);
        f = x - m;
        // x^2 = m^2 + 2mf + f^2
        u = m * m;
        u1 = 2 * m * f + f * f;
        if (sign < 0) {
            u = -u;
            u1 = -u1;
        }
        if (u + u1 > this.MAXLOG) {
            return Infinity;
        }
        // u is exact, u1 is small.
        u = Math.exp(u) * Math.exp(u1);
        return u;
    },
    /**
     *
     *	Evaluate polynomial
     *
     * SYNOPSIS:
     *
     * int N;
     * double x, y, coef[N+1], polevl[];
     *
     * y = polevl( x, coef, N );
     *
     * DESCRIPTION:
     *
     * Evaluates polynomial of degree N:
     *
     *                     2          N
     * y  =  C  + C x + C x  +...+ C x
     *        0    1     2          N
     *
     * Coefficients are stored in reverse order:
     *
     * coef[0] = C  , ..., coef[N] = C  .
     *            N                   0
     *
     *  The function p1evl() assumes that coef[N] = 1.0 and is
     * omitted from the array.  Its calling arguments are
     * otherwise the same as polevl().
     *
     *
     * SPEED:
     *
     * In the interest of speed, there are no checks for out
     * of bounds arithmetic.  This routine is used by most of
     * the functions in the library.  Depending on available
     * equipment features, the user may wish to rewrite the
     * program in microcode or assembly language.
     *
     * @private
     * @param  {Number} x
     * @param  {Number} coef
     * @param  {Number} N
     * @returns {Number}
     */ polevl: function(x, coef, N) {
        var ans, i;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(coef.reduce)) {
            return coef.reduce(function(acc, c) {
                return acc * x + c;
            }, 0);
        }
        // Polyfill
        for(i = 0, ans = 0; i <= N; i++){
            ans = ans * x + coef[i];
        }
        return ans;
    },
    /**
     * Evaluate polynomial when coefficient of x is 1.0.
     * Otherwise same as polevl.
     *
     * @private
     * @param  {Number} x
     * @param  {Number} coef
     * @param  {Number} N
     * @returns {Number}
     */ p1evl: function(x, coef, N) {
        var ans, i;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(coef.reduce)) {
            return coef.reduce(function(acc, c) {
                return acc * x + c;
            }, 1);
        }
        // Polyfill
        for(i = 0, ans = 1; i < N; i++){
            ans = ans * x + coef[i];
        }
        return ans;
    },
    /**
     *
     *	Normal distribution function
     *
     * SYNOPSIS:
     *
     * y = ndtr( x );
     *
     * DESCRIPTION:
     *
     * Returns the area under the Gaussian probability density
     * function, integrated from minus infinity to x:
     *
     *                            x
     *                             -
     *                   1        | |          2
     *    ndtr(x)  = ---------    |    exp( - t /2 ) dt
     *               sqrt(2pi)  | |
     *                           -
     *                          -inf.
     *
     *             =  ( 1 + erf(z) ) / 2
     *             =  erfc(z) / 2
     *
     * where z = x/sqrt(2). Computation is via the functions
     * erf and erfc with care to avoid error amplification in computing exp(-x^2).
     *
     *
     * ACCURACY:
     *
     *                      Relative error:
     * arithmetic   domain     # trials      peak         rms
     *    IEEE     -13,0        30000       1.3e-15     2.2e-16
     *
     *
     * ERROR MESSAGES:
     *
     *   message         condition         value returned
     * erfc underflow    x > 37.519379347       0.0
     *
     * @param  {Number} a
     * @returns {Number}
     */ ndtr: function(a) {
        // a: double, return double
        var x, y, z;
        x = a * this.SQRTH;
        z = Math.abs(x);
        if (z < 1.0) {
            y = 0.5 + 0.5 * this.erf(x);
        } else {
            y = 0.5 * this.erfce(z);
            /* Multiply by exp(-x^2 / 2)  */ z = this.expx2(a, -1);
            y = y * Math.sqrt(z);
            if (x > 0) {
                y = 1.0 - y;
            }
        }
        return y;
    },
    /**
     * @private
     * @param  {Number} a
     * @returns {Number}
     */ _underflow: function(a) {
        console.log("erfc", "UNDERFLOW");
        if (a < 0) {
            return 2.0;
        }
        return 0.0;
    },
    /**
     *
     *	Complementary error function
     *
     * SYNOPSIS:
     *
     * double x, y, erfc();
     *
     * y = erfc( x );
     *
     *
     *
     * DESCRIPTION:
     *
     *
     *  1 - erf(x) =
     *
     *                           inf.
     *                             -
     *                  2         | |          2
     *   erfc(x)  =  --------     |    exp( - t  ) dt
     *               sqrt(pi)   | |
     *                           -
     *                            x
     *
     *
     * For small x, erfc(x) = 1 - erf(x); otherwise rational
     * approximations are computed.
     *
     * A special function expx2.c is used to suppress error amplification
     * in computing exp(-x^2).
     *
     *
     * ACCURACY:
     *
     *                      Relative error:
     * arithmetic   domain     # trials      peak         rms
     *    IEEE      0,26.6417   30000       1.3e-15     2.2e-16
     *
     *
     * ERROR MESSAGES:
     *
     *   message         condition              value returned
     * erfc underflow    x > 9.231948545 (DEC)       0.0
     *
     * @param  {Number} a
     * @returns {Number}
     */ erfc: function(a) {
        var p, q, x, y, z;
        if (a < 0.0) {
            x = -a;
        } else {
            x = a;
        }
        if (x < 1.0) {
            return 1.0 - this.erf(a);
        }
        z = -a * a;
        if (z < -this.MAXLOG) {
            return this._underflow(a);
        }
        z = this.expx2(a, -1); // Compute z = exp(z).
        if (x < 8.0) {
            p = this.polevl(x, this.P, 8);
            q = this.p1evl(x, this.Q, 8);
        } else {
            p = this.polevl(x, this.R, 5);
            q = this.p1evl(x, this.S, 6);
        }
        y = z * p / q;
        if (a < 0) {
            y = 2.0 - y;
        }
        if (y === 0.0) {
            return this._underflow(a);
        }
        return y;
    },
    /**
     * Exponentially scaled erfc function
     *   exp(x^2) erfc(x)
     *   valid for x > 1.
     *   Use with ndtr and expx2.
     *
     * @private
     * @param {Number} x
     * @returns {Number}
     */ erfce: function(x) {
        var p, q;
        if (x < 8.0) {
            p = this.polevl(x, this.P, 8);
            q = this.p1evl(x, this.Q, 8);
        } else {
            p = this.polevl(x, this.R, 5);
            q = this.p1evl(x, this.S, 6);
        }
        return p / q;
    },
    /**
     *	Error function
     *
     * SYNOPSIS:
     *
     * double x, y, erf();
     *
     * y = erf( x );
     *
     *
     *
     * DESCRIPTION:
     *
     * The integral is
     *
     *                           x
     *                            -
     *                 2         | |          2
     *   erf(x)  =  --------     |    exp( - t  ) dt.
     *              sqrt(pi)   | |
     *                          -
     *                           0
     *
     * For 0 <= |x| < 1, erf(x) = x * P4(x**2)/Q5(x**2); otherwise
     * erf(x) = 1 - erfc(x).
     *
     *
     * ACCURACY:
     *
     *                      Relative error:
     * arithmetic   domain     # trials      peak         rms
     *    DEC       0,1         14000       4.7e-17     1.5e-17
     *    IEEE      0,1         30000       3.7e-16     1.0e-16
     *
     * @param  {Number} x
     * @returns {Number}
     */ erf: function(x) {
        var y, z;
        if (Math.abs(x) > 1.0) {
            return 1.0 - this.erfc(x);
        }
        z = x * x;
        y = x * this.polevl(z, this.T, 4) / this.p1evl(z, this.U, 5);
        return y;
    },
    s2pi: 2.50662827463100050242,
    // approximation for 0 <= |y - 0.5| <= 3/8 */
    P0: [
        -5.99633501014107895267e1,
        9.80010754185999661536e1,
        -5.66762857469070293439e1,
        1.39312609387279679503e1,
        -1.23916583867381258016
    ],
    Q0: [
        1.95448858338141759834,
        4.67627912898881538453,
        8.63602421390890590575e1,
        -2.25462687854119370527e2,
        2.00260212380060660359e2,
        -8.20372256168333339912e1,
        1.59056225126211695515e1,
        -1.18331621121330003142
    ],
    //  Approximation for interval z = sqrt(-2 log y ) between 2 and 8
    //  i.e., y between exp(-2) = .135 and exp(-32) = 1.27e-14.
    P1: [
        4.05544892305962419923,
        3.15251094599893866154e1,
        5.71628192246421288162e1,
        4.408050738932008347e1,
        1.46849561928858024014e1,
        2.18663306850790267539,
        -1.40256079171354495875e-1,
        -3.50424626827848203418e-2,
        -8.57456785154685413611e-4
    ],
    Q1: [
        1.57799883256466749731e1,
        4.53907635128879210584e1,
        4.1317203825467203044e1,
        1.50425385692907503408e1,
        2.50464946208309415979,
        -1.42182922854787788574e-1,
        -3.80806407691578277194e-2,
        -9.33259480895457427372e-4
    ],
    // Approximation for interval z = sqrt(-2 log y ) between 8 and 64
    // i.e., y between exp(-32) = 1.27e-14 and exp(-2048) = 3.67e-890.
    P2: [
        3.2377489177694603597,
        6.91522889068984211695,
        3.93881025292474443415,
        1.33303460815807542389,
        2.01485389549179081538e-1,
        1.23716634817820021358e-2,
        3.01581553508235416007e-4,
        2.65806974686737550832e-6,
        6.2397453918498329373e-9
    ],
    Q2: [
        6.02427039364742014255,
        3.67983563856160859403,
        1.37702099489081330271,
        2.1623699359449663589e-1,
        1.34204006088543189037e-2,
        3.28014464682127739104e-4,
        2.89247864745380683936e-6,
        6.79019408009981274425e-9
    ],
    /**
     *
     *	Inverse of Normal distribution function
     *
     * SYNOPSIS:
     *
     * double x, y, ndtri();
     *
     * x = ndtri( y );
     *
     * DESCRIPTION:
     *
     * Returns the argument, x, for which the area under the
     * Gaussian probability density function (integrated from
     * minus infinity to x) is equal to y.
     *
     *
     * For small arguments 0 < y < exp(-2), the program computes
     * z = sqrt( -2.0 * log(y) );  then the approximation is
     * x = z - log(z)/z  - (1/z) P(1/z) / Q(1/z).
     * There are two rational functions P/Q, one for 0 < y < exp(-32)
     * and the other for y up to exp(-2).  For larger arguments,
     * w = y - 0.5, and  x/sqrt(2pi) = w + w**3 R(w**2)/S(w**2)).
     *
     *
     * ACCURACY:
     *
     *                      Relative error:
     * arithmetic   domain        # trials      peak         rms
     *    DEC      0.125, 1         5500       9.5e-17     2.1e-17
     *    DEC      6e-39, 0.135     3500       5.7e-17     1.3e-17
     *    IEEE     0.125, 1        20000       7.2e-16     1.3e-16
     *    IEEE     3e-308, 0.135   50000       4.6e-16     9.8e-17
     *
     *
     * ERROR MESSAGES:
     *
     *   message         condition    value returned
     * ndtri domain       x <= 0        -MAXNUM
     * ndtri domain       x >= 1         MAXNUM
     *
     * @param  {Number} y0
     * @returns {Number}
     */ ndtri: function(y0) {
        var x, y, z, y2, x0, x1, code;
        if (y0 <= 0.0) {
            //console.log("ndtri", "DOMAIN ");
            return -Infinity; // -this.MAXNUM;
        }
        if (y0 >= 1.0) {
            // console.log("ndtri", "DOMAIN");
            return Infinity; // this.MAXNUM;
        }
        code = 1;
        y = y0;
        if (y > 1.0 - 0.13533528323661269189) {
            // 0.135... = exp(-2)
            y = 1.0 - y;
            code = 0;
        }
        if (y > 0.13533528323661269189) {
            y = y - 0.5;
            y2 = y * y;
            x = y + y * (y2 * this.polevl(y2, this.P0, 4) / this.p1evl(y2, this.Q0, 8));
            x = x * this.s2pi;
            return x;
        }
        x = Math.sqrt(-2.0 * Math.log(y));
        x0 = x - Math.log(x) / x;
        z = 1.0 / x;
        if (x < 8.0) {
            // y > exp(-32) = 1.2664165549e-14
            x1 = z * this.polevl(z, this.P1, 8) / this.p1evl(z, this.Q1, 8);
        } else {
            x1 = z * this.polevl(z, this.P2, 8) / this.p1evl(z, this.Q2, 8);
        }
        x = x0 - x1;
        if (code !== 0) {
            x = -x;
        }
        return x;
    },
    /**
     * Inverse of error function erf.
     *
     * @param  {Number} x
     * @returns {Number}
     */ erfi: function(x) {
        return this.ndtri((x + 1) * 0.5) * this.SQRTH;
    }
};
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ProbFuncs;
}),
"[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/ia.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Alfred Wassermann

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */ /*global JXG: true, define: true*/ /*jslint nomen: true, plusplus: true*/ __turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/jxg.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/math.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/utils/type.js [app-client] (ecmascript)");
;
;
;
__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Math.DoubleBits = function() {
    var DOUBLE_VIEW = new Float64Array(1), UINT_VIEW = new Uint32Array(DOUBLE_VIEW.buffer), doubleBitsLE, toDoubleLE, lowUintLE, highUintLE, // doubleBits,
    // toDouble,
    // lowUint,
    // highUint,
    // hasTypedArrays = false,
    doubleBitsBE, toDoubleBE, lowUintBE, highUintBE;
    if (Float64Array !== undefined) {
        DOUBLE_VIEW[0] = 1.0;
        // hasTypedArrays = true;
        if (UINT_VIEW[1] === 0x3ff00000) {
            // Use little endian
            doubleBitsLE = function(n) {
                DOUBLE_VIEW[0] = n;
                return [
                    UINT_VIEW[0],
                    UINT_VIEW[1]
                ];
            };
            toDoubleLE = function(lo, hi) {
                UINT_VIEW[0] = lo;
                UINT_VIEW[1] = hi;
                return DOUBLE_VIEW[0];
            };
            lowUintLE = function(n) {
                DOUBLE_VIEW[0] = n;
                return UINT_VIEW[0];
            };
            highUintLE = function(n) {
                DOUBLE_VIEW[0] = n;
                return UINT_VIEW[1];
            };
            this.doubleBits = doubleBitsLE;
            this.pack = toDoubleLE;
            this.lo = lowUintLE;
            this.hi = highUintLE;
        } else if (UINT_VIEW[0] === 0x3ff00000) {
            // Use big endian
            doubleBitsBE = function(n) {
                DOUBLE_VIEW[0] = n;
                return [
                    UINT_VIEW[1],
                    UINT_VIEW[0]
                ];
            };
            toDoubleBE = function(lo, hi) {
                UINT_VIEW[1] = lo;
                UINT_VIEW[0] = hi;
                return DOUBLE_VIEW[0];
            };
            lowUintBE = function(n) {
                DOUBLE_VIEW[0] = n;
                return UINT_VIEW[1];
            };
            highUintBE = function(n) {
                DOUBLE_VIEW[0] = n;
                return UINT_VIEW[0];
            };
            this.doubleBits = doubleBitsBE;
            this.pack = toDoubleBE;
            this.lo = lowUintBE;
            this.hi = highUintBE;
        // } else {
        //     hasTypedArrays = false;
        }
    }
// if (!hasTypedArrays) {
//     var buffer = new Buffer(8)
//     doubleBits = function(n) {
//         buffer.writeDoubleLE(n, 0, true);
//         return [buffer.readUInt32LE(0, true), buffer.readUInt32LE(4, true)];
//     };
//     toDouble = function(lo, hi) {
//         buffer.writeUInt32LE(lo, 0, true);
//         buffer.writeUInt32LE(hi, 4, true);
//         return buffer.readDoubleLE(0, true);
//     };
//     lowUint = function(n) {
//         buffer.writeDoubleLE(n, 0, true);
//         return buffer.readUInt32LE(0, true);
//     };
//     highUint = function(n) {
//         buffer.writeDoubleLE(n, 0, true);
//         return buffer.readUInt32LE(4, true);
//     };
//     this.doubleBits = doubleBits;
//     this.pack = toDouble;
//     this.lo = lowUint;
//     this.hi = highUint;
// }
};
__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].extend(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Math.DoubleBits.prototype, /** @lends JXG.Math.DoubleBits.prototype */ {
    sign: function(n) {
        return this.hi(n) >>> 31;
    },
    exponent: function(n) {
        var b = this.hi(n);
        return (b << 1 >>> 21) - 1023;
    },
    fraction: function(n) {
        var lo = this.lo(n), hi = this.hi(n), b = hi & (1 << 20) - 1;
        if (hi & 0x7ff00000) {
            b += 1 << 20;
        }
        return [
            lo,
            b
        ];
    },
    denormalized: function(n) {
        var hi = this.hi(n);
        return !(hi & 0x7ff00000);
    }
});
var doubleBits = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Math.DoubleBits(), /**
     * Interval for interval arithmetics. Consists of the properties
     * <ul>
     *  <li>lo
     *  <li>hi
     * </ul>
     * @name JXG.Math.Interval
     * @type Object
     */ MatInterval = function(lo, hi) {
    if (lo !== undefined && hi !== undefined) {
        // possible cases:
        // - Interval(1, 2)
        // - Interval(Interval(1, 1), Interval(2, 2))     // singletons are required
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IntervalArithmetic.isInterval(lo)) {
            if (!__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IntervalArithmetic.isSingleton(lo)) {
                throw new TypeError("JXG.Math.IntervalArithmetic: interval `lo` must be a singleton");
            }
            this.lo = lo.lo;
        } else {
            this.lo = lo;
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IntervalArithmetic.isInterval(hi)) {
            if (!__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IntervalArithmetic.isSingleton(hi)) {
                throw new TypeError("JXG.Math.IntervalArithmetic: interval `hi` must be a singleton");
            }
            this.hi = hi.hi;
        } else {
            this.hi = hi;
        }
    } else if (lo !== undefined) {
        // possible cases:
        // - Interval([1, 2])
        // - Interval([Interval(1, 1), Interval(2, 2)])
        if (Array.isArray(lo)) {
            return new MatInterval(lo[0], lo[1]);
        }
        // - Interval(1)
        return new MatInterval(lo, lo);
    } else {
        // This else is necessary even if jslint declares it as redundant
        // possible cases:
        // - Interval()
        this.lo = this.hi = 0;
    }
};
__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].extend(MatInterval.prototype, {
    print: function() {
        console.log("[", this.lo, this.hi, "]");
    },
    set: function(lo, hi) {
        this.lo = lo;
        this.hi = hi;
        return this;
    },
    bounded: function(lo, hi) {
        return this.set(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IntervalArithmetic.prev(lo), __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IntervalArithmetic.next(hi));
    },
    boundedSingleton: function(v) {
        return this.bounded(v, v);
    },
    assign: function(lo, hi) {
        if (typeof lo !== "number" || typeof hi !== "number") {
            throw new TypeError("JXG.Math.Interval#assign: arguments must be numbers");
        }
        if (isNaN(lo) || isNaN(hi) || lo > hi) {
            return this.setEmpty();
        }
        return this.set(lo, hi);
    },
    setEmpty: function() {
        return this.set(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY);
    },
    setWhole: function() {
        return this.set(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);
    },
    open: function(lo, hi) {
        return this.assign(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IntervalArithmetic.next(lo), __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IntervalArithmetic.prev(hi));
    },
    halfOpenLeft: function(lo, hi) {
        return this.assign(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IntervalArithmetic.next(lo), hi);
    },
    halfOpenRight: function(lo, hi) {
        return this.assign(lo, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IntervalArithmetic.prev(hi));
    },
    toArray: function() {
        return [
            this.lo,
            this.hi
        ];
    },
    clone: function() {
        return new MatInterval().set(this.lo, this.hi);
    }
});
/**
 * Object for interval arithmetics.
 * @name JXG.Math.IntervalArithmetic
 * @namespace
 *
 * Interval arithmetic is a technique used to mitigate rounding and measurement errors in mathematical computation
 * by computing function bounds. Instead of representing a value as a single number, interval arithmetic represents each value as a range.
 * <br><br>
 *
 * For example, we wish to calculate the area of a rectangle from direct measurements using a standard meter stick with an uncertainty
 * of 0.0005 m (half the least count measurement of 1 mm). We measure one side nominally as L=1,
 * so 0.9995  L  1.0005, the other nominally as W=2 so the interval is [1.9995, 2.0005].
 *
 * <pre>
 * let L = JXG.Math.IntervalArithmetic.Interval(0.9995, 1.0005)
 * let W = JXG.Math.IntervalArithmetic.Interval(1.9995, 2.0005)
 *
 * let A = JXG.Math.IntervalArithmetic.mul(L, W)
 *
 * console.log('area:', A) // {hi: 2.0015002500000003, lo: 1.99850025}
 * </pre>
 *
 */ __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Math.IntervalArithmetic = {
    Interval: function(lo, hi) {
        return new MatInterval(lo, hi);
    },
    isInterval: function(i) {
        return i !== null && typeof i === "object" && typeof i.lo === "number" && typeof i.hi === "number";
    },
    isSingleton: function(i) {
        return i.lo === i.hi;
    },
    /*
     * Arithmetics
     */ /**
     * Addition
     *
     * @param {JXG.Math.Interval|Number} x
     * @param {JXG.Math.Interval|Number} y
     * @returns JXG.Math.Interval
     */ add: function(x, y) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(x)) {
            x = this.Interval(x);
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(y)) {
            y = this.Interval(y);
        }
        return new MatInterval(this.addLo(x.lo, y.lo), this.addHi(x.hi, y.hi));
    },
    /**
     * Subtraction
     *
     * @param {JXG.Math.Interval|Number} x
     * @param {JXG.Math.Interval|Number} y
     * @returns JXG.Math.Interval
     */ sub: function(x, y) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(x)) {
            x = this.Interval(x);
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(y)) {
            y = this.Interval(y);
        }
        return new MatInterval(this.subLo(x.lo, y.hi), this.subHi(x.hi, y.lo));
    },
    /**
     * Multiplication
     *
     * @param {JXG.Math.Interval|Number} x
     * @param {JXG.Math.Interval|Number} y
     * @returns JXG.Math.Interval
     */ mul: function(x, y) {
        var xl, xh, yl, yh, out;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(x)) {
            x = this.Interval(x);
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(y)) {
            y = this.Interval(y);
        }
        if (this.isEmpty(x) || this.isEmpty(y)) {
            return this.EMPTY.clone();
        }
        xl = x.lo;
        xh = x.hi;
        yl = y.lo;
        yh = y.hi;
        out = new MatInterval();
        if (xl < 0) {
            if (xh > 0) {
                if (yl < 0) {
                    if (yh > 0) {
                        // mixed * mixed
                        out.lo = Math.min(this.mulLo(xl, yh), this.mulLo(xh, yl));
                        out.hi = Math.max(this.mulHi(xl, yl), this.mulHi(xh, yh));
                    } else {
                        // mixed * negative
                        out.lo = this.mulLo(xh, yl);
                        out.hi = this.mulHi(xl, yl);
                    }
                } else {
                    if (yh > 0) {
                        // mixed * positive
                        out.lo = this.mulLo(xl, yh);
                        out.hi = this.mulHi(xh, yh);
                    } else {
                        // mixed * zero
                        out.lo = 0;
                        out.hi = 0;
                    }
                }
            } else {
                if (yl < 0) {
                    if (yh > 0) {
                        // negative * mixed
                        out.lo = this.mulLo(xl, yh);
                        out.hi = this.mulHi(xl, yl);
                    } else {
                        // negative * negative
                        out.lo = this.mulLo(xh, yh);
                        out.hi = this.mulHi(xl, yl);
                    }
                } else {
                    if (yh > 0) {
                        // negative * positive
                        out.lo = this.mulLo(xl, yh);
                        out.hi = this.mulHi(xh, yl);
                    } else {
                        // negative * zero
                        out.lo = 0;
                        out.hi = 0;
                    }
                }
            }
        } else {
            if (xh > 0) {
                if (yl < 0) {
                    if (yh > 0) {
                        // positive * mixed
                        out.lo = this.mulLo(xh, yl);
                        out.hi = this.mulHi(xh, yh);
                    } else {
                        // positive * negative
                        out.lo = this.mulLo(xh, yl);
                        out.hi = this.mulHi(xl, yh);
                    }
                } else {
                    if (yh > 0) {
                        // positive * positive
                        out.lo = this.mulLo(xl, yl);
                        out.hi = this.mulHi(xh, yh);
                    } else {
                        // positive * zero
                        out.lo = 0;
                        out.hi = 0;
                    }
                }
            } else {
                // zero * any other value
                out.lo = 0;
                out.hi = 0;
            }
        }
        return out;
    },
    /**
     * Division
     *
     * @param {JXG.Math.Interval|Number} x
     * @param {JXG.Math.Interval|Number} y
     * @returns JXG.Math.Interval
     */ div: function(x, y) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(x)) {
            x = this.Interval(x);
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(y)) {
            y = this.Interval(y);
        }
        if (this.isEmpty(x) || this.isEmpty(y)) {
            return this.EMPTY.clone();
        }
        if (this.zeroIn(y)) {
            if (y.lo !== 0) {
                if (y.hi !== 0) {
                    return this.divZero(x);
                }
                return this.divNegative(x, y.lo);
            }
            if (y.hi !== 0) {
                return this.divPositive(x, y.hi);
            }
            return this.EMPTY.clone();
        }
        return this.divNonZero(x, y);
    },
    /**
     * Return +x (i.e. identity)
     *
     * @param {JXG.Math.Interval} x
     * @returns JXG.Math.Interval
     */ positive: function(x) {
        return new MatInterval(x.lo, x.hi);
    },
    /**
     * Return -x
     *
     * @param {JXG.Math.Interval} x
     * @returns JXG.Math.Interval
     */ negative: function(x) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(x)) {
            return new MatInterval(-x);
        }
        return new MatInterval(-x.hi, -x.lo);
    },
    /*
     * Utils
     */ /**
     * Test if interval is empty set.
     * @param {JXG.Math.Interval} i
     * @returns Boolean
     */ isEmpty: function(i) {
        return i.lo > i.hi;
    },
    /**
     * Test if interval is (-Infinity, Infinity).
     * @param {JXG.Math.Interval} i
     * @returns Boolean
     */ isWhole: function(i) {
        return i.lo === -Infinity && i.hi === Infinity;
    },
    /**
     * Test if interval contains 0.
     * @param {JXG.Math.Interval} i
     * @returns Boolean
     */ zeroIn: function(i) {
        return this.hasValue(i, 0);
    },
    /**
     * Test if interval contains a specific value.
     * @param {JXG.Math.Interval} i
     * @param {Number} value
     * @returns Boolean
     */ hasValue: function(i, value) {
        if (this.isEmpty(i)) {
            return false;
        }
        return i.lo <= value && value <= i.hi;
    },
    /**
     * Test if interval x contains interval y.
     * @param {JXG.Math.Interval} x
     * @param {JXG.Math.Interval} y
     * @returns Boolean
     */ hasInterval: function(x, y) {
        if (this.isEmpty(x)) {
            return true;
        }
        return !this.isEmpty(y) && y.lo <= x.lo && x.hi <= y.hi;
    },
    /**
     * Test if intervals x and y have non-zero intersection.
     * @param {JXG.Math.Interval} x
     * @param {JXG.Math.Interval} y
     * @returns Boolean
     */ intervalsOverlap: function(x, y) {
        if (this.isEmpty(x) || this.isEmpty(y)) {
            return false;
        }
        return x.lo <= y.lo && y.lo <= x.hi || y.lo <= x.lo && x.lo <= y.hi;
    },
    /*
     * Division
     */ /**
     * @private
     * @param {JXG.Math.Interval} x
     * @param {JXG.Math.Interval} y
     * @returns JXG.Math.Interval
     */ divNonZero: function(x, y) {
        var xl = x.lo, xh = x.hi, yl = y.lo, yh = y.hi, out = new MatInterval();
        if (xh < 0) {
            if (yh < 0) {
                out.lo = this.divLo(xh, yl);
                out.hi = this.divHi(xl, yh);
            } else {
                out.lo = this.divLo(xl, yl);
                out.hi = this.divHi(xh, yh);
            }
        } else if (xl < 0) {
            if (yh < 0) {
                out.lo = this.divLo(xh, yh);
                out.hi = this.divHi(xl, yh);
            } else {
                out.lo = this.divLo(xl, yl);
                out.hi = this.divHi(xh, yl);
            }
        } else {
            if (yh < 0) {
                out.lo = this.divLo(xh, yh);
                out.hi = this.divHi(xl, yl);
            } else {
                out.lo = this.divLo(xl, yh);
                out.hi = this.divHi(xh, yl);
            }
        }
        return out;
    },
    /**
     * @private
     * @param {JXG.Math.Interval} x
     * @param {JXG.Math.Interval} y
     * @returns JXG.Math.Interval
     */ divPositive: function(x, v) {
        if (x.lo === 0 && x.hi === 0) {
            return x;
        }
        if (this.zeroIn(x)) {
            // mixed considering zero in both ends
            return this.WHOLE;
        }
        if (x.hi < 0) {
            // negative / v
            return new MatInterval(Number.NEGATIVE_INFINITY, this.divHi(x.hi, v));
        }
        // positive / v
        return new MatInterval(this.divLo(x.lo, v), Number.POSITIVE_INFINITY);
    },
    /**
     * @private
     * @param {JXG.Math.Interval} x
     * @param {JXG.Math.Interval} y
     * @returns JXG.Math.Interval
     */ divNegative: function(x, v) {
        if (x.lo === 0 && x.hi === 0) {
            return x;
        }
        if (this.zeroIn(x)) {
            // mixed considering zero in both ends
            return this.WHOLE;
        }
        if (x.hi < 0) {
            // negative / v
            return new MatInterval(this.divLo(x.hi, v), Number.POSITIVE_INFINITY);
        }
        // positive / v
        return new MatInterval(Number.NEGATIVE_INFINITY, this.divHi(x.lo, v));
    },
    /**
     * @private
     * @param {JXG.Math.Interval} x
     * @returns JXG.Math.Interval
     */ divZero: function(x) {
        if (x.lo === 0 && x.hi === 0) {
            return x;
        }
        return this.WHOLE;
    },
    /*
     * Algebra
     */ /**
     * x mod y:  x - n * y
     * @param {JXG.Math.Interval|Number} x
     * @param {JXG.Math.Interval|Number} y
     * @returns JXG.Math.Interval
     */ fmod: function(x, y) {
        var yb, n;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(x)) {
            x = this.Interval(x);
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(y)) {
            y = this.Interval(y);
        }
        if (this.isEmpty(x) || this.isEmpty(y)) {
            return this.EMPTY.clone();
        }
        yb = x.lo < 0 ? y.lo : y.hi;
        n = x.lo / yb;
        if (n < 0) {
            n = Math.ceil(n);
        } else {
            n = Math.floor(n);
        }
        // x mod y = x - n * y
        return this.sub(x, this.mul(y, new MatInterval(n)));
    },
    /**
     * 1 / x
     * @param {JXG.Math.Interval|Number} x
     * @returns JXG.Math.Interval
     */ multiplicativeInverse: function(x) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(x)) {
            x = this.Interval(x);
        }
        if (this.isEmpty(x)) {
            return this.EMPTY.clone();
        }
        if (this.zeroIn(x)) {
            if (x.lo !== 0) {
                if (x.hi !== 0) {
                    // [negative, positive]
                    return this.WHOLE;
                }
                // [negative, zero]
                return new MatInterval(Number.NEGATIVE_INFINITY, this.divHi(1, x.lo));
            }
            if (x.hi !== 0) {
                // [zero, positive]
                return new MatInterval(this.divLo(1, x.hi), Number.POSITIVE_INFINITY);
            }
            // [zero, zero]
            return this.EMPTY.clone();
        }
        // [positive, positive]
        return new MatInterval(this.divLo(1, x.hi), this.divHi(1, x.lo));
    },
    /**
     * x<sup>power</sup>
     * @param {JXG.Math.Interval|Number} x
     * @param {JXG.Math.Interval|Number} power
     * @returns JXG.Math.Interval
     */ pow: function(x, power) {
        var yl, yh;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(x)) {
            x = this.Interval(x);
        }
        if (this.isEmpty(x)) {
            return this.EMPTY.clone();
        }
        if (this.isInterval(power)) {
            if (!this.isSingleton(power)) {
                return this.EMPTY.clone();
            }
            power = power.lo;
        }
        if (power === 0) {
            if (x.lo === 0 && x.hi === 0) {
                // 0^0
                return this.EMPTY.clone();
            }
            // x^0
            return this.ONE.clone();
        }
        if (power < 0) {
            // compute [1 / x]^-power if power is negative
            return this.pow(this.multiplicativeInverse(x), -power);
        }
        // power > 0
        if (power % 1 === 0) {
            // isSafeInteger(power) as boolean) {
            // power is integer
            if (x.hi < 0) {
                // [negative, negative]
                // assume that power is even so the operation will yield a positive interval
                // if not then just switch the sign and order of the interval bounds
                yl = this.powLo(-x.hi, power);
                yh = this.powHi(-x.lo, power);
                if ((power & 1) === 1) {
                    // odd power
                    return new MatInterval(-yh, -yl);
                }
                // even power
                return new MatInterval(yl, yh);
            }
            if (x.lo < 0) {
                // [negative, positive]
                if ((power & 1) === 1) {
                    return new MatInterval(-this.powLo(-x.lo, power), this.powHi(x.hi, power));
                }
                // even power means that any negative number will be zero (min value = 0)
                // and the max value will be the max of x.lo^power, x.hi^power
                return new MatInterval(0, this.powHi(Math.max(-x.lo, x.hi), power));
            }
            // [positive, positive]
            return new MatInterval(this.powLo(x.lo, power), this.powHi(x.hi, power));
        }
        console.warn("power is not an integer, you should use nth-root instead, returning an empty interval");
        return this.EMPTY.clone();
    },
    /**
     * sqrt(x)
     * @param {JXG.Math.Interval|Number} x
     * @returns JXG.Math.Interval
     */ sqrt: function(x) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(x)) {
            x = this.Interval(x);
        }
        return this.nthRoot(x, 2);
    },
    /**
     * x<sup>1/n</sup>
     * @param {JXG.Math.Interval|Number} x
     * @param {Number} n
     * @returns JXG.Math.Interval
     */ nthRoot: function(x, n) {
        var power, yl, yh, yp, yn;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(x)) {
            x = this.Interval(x);
        }
        if (this.isEmpty(x) || n < 0) {
            // compute 1 / x^-power if power is negative
            return this.EMPTY.clone();
        }
        // singleton interval check
        if (this.isInterval(n)) {
            if (!this.isSingleton(n)) {
                return this.EMPTY.clone();
            }
            n = n.lo;
        }
        power = 1 / n;
        if (x.hi < 0) {
            // [negative, negative]
            //if ((isSafeInteger(n) as boolean) && (n & 1) === 1) {
            if (n % 1 === 0 && (n & 1) === 1) {
                // when n is odd we can always take the nth root
                yl = this.powHi(-x.lo, power);
                yh = this.powLo(-x.hi, power);
                return new MatInterval(-yl, -yh);
            }
            // n is not odd therefore there's no nth root
            return this.EMPTY.clone();
        }
        if (x.lo < 0) {
            // [negative, positive]
            yp = this.powHi(x.hi, power);
            // if ((isSafeInteger(n) as boolean) && (n & 1) === 1) {
            if (n % 1 === 0 && (n & 1) === 1) {
                // nth root of x.lo is possible (n is odd)
                yn = -this.powHi(-x.lo, power);
                return new MatInterval(yn, yp);
            }
            return new MatInterval(0, yp);
        }
        // [positive, positive]
        return new MatInterval(this.powLo(x.lo, power), this.powHi(x.hi, power));
    },
    /*
     * Misc
     */ /**
     *
     * @param {JXG.Math.Interval|Number} x
     * @returns JXG.Math.Interval
     */ exp: function(x) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(x)) {
            x = this.Interval(x);
        }
        if (this.isEmpty(x)) {
            return this.EMPTY.clone();
        }
        return new MatInterval(this.expLo(x.lo), this.expHi(x.hi));
    },
    /**
     * Natural log
     * @param {JXG.Math.Interval|Number} x
     * @returns JXG.Math.Interval
     */ log: function(x) {
        var l;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(x)) {
            x = this.Interval(x);
        }
        if (this.isEmpty(x)) {
            return this.EMPTY.clone();
        }
        l = x.lo <= 0 ? Number.NEGATIVE_INFINITY : this.logLo(x.lo);
        return new MatInterval(l, this.logHi(x.hi));
    },
    /**
     * Natural log, alias for {@link JXG.Math.IntervalArithmetic#log}.
     * @param {JXG.Math.Interval|Number} x
     * @returns JXG.Math.Interval
     */ ln: function(x) {
        return this.log(x);
    },
    // export const LOG_EXP_10 = this.log(new MatInterval(10, 10))
    // export const LOG_EXP_2 = log(new MatInterval(2, 2))
    /**
     * Logarithm to base 10.
     * @param {JXG.Math.Interval|Number} x
     * @returns JXG.Math.Interval
     */ log10: function(x) {
        if (this.isEmpty(x)) {
            return this.EMPTY.clone();
        }
        return this.div(this.log(x), this.log(new MatInterval(10, 10)));
    },
    /**
     * Logarithm to base 2.
     * @param {JXG.Math.Interval|Number} x
     * @returns JXG.Math.Interval
     */ log2: function(x) {
        if (this.isEmpty(x)) {
            return this.EMPTY.clone();
        }
        return this.div(this.log(x), this.log(new MatInterval(2, 2)));
    },
    /**
     * Hull of intervals x and y
     * @param {JXG.Math.Interval} x
     * @param {JXG.Math.Interval} y
     * @returns JXG.Math.Interval
     */ hull: function(x, y) {
        var badX = this.isEmpty(x), badY = this.isEmpty(y);
        if (badX && badY) {
            return this.EMPTY.clone();
        }
        if (badX) {
            return y.clone();
        }
        if (badY) {
            return x.clone();
        }
        return new MatInterval(Math.min(x.lo, y.lo), Math.max(x.hi, y.hi));
    },
    /**
     * Intersection of intervals x and y
     * @param {JXG.Math.Interval} x
     * @param {JXG.Math.Interval} y
     * @returns JXG.Math.Interval
     */ intersection: function(x, y) {
        var lo, hi;
        if (this.isEmpty(x) || this.isEmpty(y)) {
            return this.EMPTY.clone();
        }
        lo = Math.max(x.lo, y.lo);
        hi = Math.min(x.hi, y.hi);
        if (lo <= hi) {
            return new MatInterval(lo, hi);
        }
        return this.EMPTY.clone();
    },
    /**
     * Union of overlapping intervals x and y
     * @param {JXG.Math.Interval} x
     * @param {JXG.Math.Interval} y
     * @returns JXG.Math.Interval
     */ union: function(x, y) {
        if (!this.intervalsOverlap(x, y)) {
            throw new Error("Interval#unions do not overlap");
        }
        return new MatInterval(Math.min(x.lo, y.lo), Math.max(x.hi, y.hi));
    },
    /**
     * Difference of overlapping intervals x and y
     * @param {JXG.Math.Interval} x
     * @param {JXG.Math.Interval} y
     * @returns JXG.Math.Interval
     */ difference: function(x, y) {
        if (this.isEmpty(x) || this.isWhole(y)) {
            return this.EMPTY.clone();
        }
        if (this.intervalsOverlap(x, y)) {
            if (x.lo < y.lo && y.hi < x.hi) {
                // difference creates multiple subsets
                throw new Error("Interval.difference: difference creates multiple intervals");
            }
            // handle corner cases first
            if (y.lo <= x.lo && y.hi === Infinity || y.hi >= x.hi && y.lo === -Infinity) {
                return this.EMPTY.clone();
            }
            // NOTE: empty interval is handled automatically
            // e.g.
            //
            //    n = difference([0,1], [0,1]) // n = Interval(next(1), 1) = EMPTY
            //    isEmpty(n) === true
            //
            if (y.lo <= x.lo) {
                return new MatInterval().halfOpenLeft(y.hi, x.hi);
            }
            // y.hi >= x.hi
            return new MatInterval().halfOpenRight(x.lo, y.lo);
        }
        return x.clone();
    },
    /**
     * @param {JXG.Math.Interval} x
     * @returns JXG.Math.Interval
     */ width: function(x) {
        if (this.isEmpty(x)) {
            return 0;
        }
        return this.subHi(x.hi, x.lo);
    },
    /**
     * @param {JXG.Math.Interval} x
     * @returns JXG.Math.Interval
     */ abs: function(x) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(x)) {
            x = this.Interval(x);
        }
        if (this.isEmpty(x)) {
            return this.EMPTY.clone();
        }
        if (x.lo >= 0) {
            return x.clone();
        }
        if (x.hi <= 0) {
            return this.negative(x);
        }
        return new MatInterval(0, Math.max(-x.lo, x.hi));
    },
    /**
     * @param {JXG.Math.Interval} x
     * @param {JXG.Math.Interval} y
     * @returns JXG.Math.Interval
     */ max: function(x, y) {
        var badX = this.isEmpty(x), badY = this.isEmpty(y);
        if (badX && badY) {
            return this.EMPTY.clone();
        }
        if (badX) {
            return y.clone();
        }
        if (badY) {
            return x.clone();
        }
        return new MatInterval(Math.max(x.lo, y.lo), Math.max(x.hi, y.hi));
    },
    /**
     * @param {JXG.Math.Interval} x
     * @param {JXG.Math.Interval} y
     * @returns JXG.Math.Interval
     */ min: function(x, y) {
        var badX = this.isEmpty(x), badY = this.isEmpty(y);
        if (badX && badY) {
            return this.EMPTY.clone();
        }
        if (badX) {
            return y.clone();
        }
        if (badY) {
            return x.clone();
        }
        return new MatInterval(Math.min(x.lo, y.lo), Math.min(x.hi, y.hi));
    },
    /*
     * Trigonometric
     */ onlyInfinity: function(x) {
        return !isFinite(x.lo) && x.lo === x.hi;
    },
    _handleNegative: function(interval) {
        var n;
        if (interval.lo < 0) {
            if (interval.lo === -Infinity) {
                interval.lo = 0;
                interval.hi = Infinity;
            } else {
                n = Math.ceil(-interval.lo / this.piTwiceLow);
                interval.lo += this.piTwiceLow * n;
                interval.hi += this.piTwiceLow * n;
            }
        }
        return interval;
    },
    /**
     * @param {JXG.Math.Interval} x
     * @returns JXG.Math.Interval
     */ cos: function(x) {
        var cache, pi2, t, cosv, lo, hi, rlo, rhi;
        if (this.isEmpty(x) || this.onlyInfinity(x)) {
            return this.EMPTY.clone();
        }
        // create a clone of `x` because the clone is going to be modified
        cache = new MatInterval().set(x.lo, x.hi);
        this._handleNegative(cache);
        pi2 = this.PI_TWICE;
        t = this.fmod(cache, pi2);
        if (this.width(t) >= pi2.lo) {
            return new MatInterval(-1, 1);
        }
        // when t.lo > pi it's the same as
        // -cos(t - pi)
        if (t.lo >= this.piHigh) {
            cosv = this.cos(this.sub(t, this.PI));
            return this.negative(cosv);
        }
        lo = t.lo;
        hi = t.hi;
        rlo = this.cosLo(hi);
        rhi = this.cosHi(lo);
        // it's ensured that t.lo < pi and that t.lo >= 0
        if (hi <= this.piLow) {
            // when t.hi < pi
            // [cos(t.lo), cos(t.hi)]
            return new MatInterval(rlo, rhi);
        }
        if (hi <= pi2.lo) {
            // when t.hi < 2pi
            // [-1, max(cos(t.lo), cos(t.hi))]
            return new MatInterval(-1, Math.max(rlo, rhi));
        }
        // t.lo < pi and t.hi > 2pi
        return new MatInterval(-1, 1);
    },
    /**
     * @param {JXG.Math.Interval} x
     * @returns JXG.Math.Interval
     */ sin: function(x) {
        if (this.isEmpty(x) || this.onlyInfinity(x)) {
            return this.EMPTY.clone();
        }
        return this.cos(this.sub(x, this.PI_HALF));
    },
    /**
     * @param {JXG.Math.Interval} x
     * @returns JXG.Math.Interval
     */ tan: function(x) {
        var cache, t, pi;
        if (this.isEmpty(x) || this.onlyInfinity(x)) {
            return this.EMPTY.clone();
        }
        // create a clone of `x` because the clone is going to be modified
        cache = new MatInterval().set(x.lo, x.hi);
        this._handleNegative(cache);
        pi = this.PI;
        t = this.fmod(cache, pi);
        if (t.lo >= this.piHalfLow) {
            t = this.sub(t, pi);
        }
        if (t.lo <= -this.piHalfLow || t.hi >= this.piHalfLow) {
            return this.WHOLE.clone();
        }
        return new MatInterval(this.tanLo(t.lo), this.tanHi(t.hi));
    },
    /**
     * @param {JXG.Math.Interval} x
     * @returns JXG.Math.Interval
     */ asin: function(x) {
        var lo, hi;
        if (this.isEmpty(x) || x.hi < -1 || x.lo > 1) {
            return this.EMPTY.clone();
        }
        lo = x.lo <= -1 ? -this.piHalfHigh : this.asinLo(x.lo);
        hi = x.hi >= 1 ? this.piHalfHigh : this.asinHi(x.hi);
        return new MatInterval(lo, hi);
    },
    /**
     * @param {JXG.Math.Interval} x
     * @returns JXG.Math.Interval
     */ acos: function(x) {
        var lo, hi;
        if (this.isEmpty(x) || x.hi < -1 || x.lo > 1) {
            return this.EMPTY.clone();
        }
        lo = x.hi >= 1 ? 0 : this.acosLo(x.hi);
        hi = x.lo <= -1 ? this.piHigh : this.acosHi(x.lo);
        return new MatInterval(lo, hi);
    },
    /**
     * @param {JXG.Math.Interval} x
     * @returns JXG.Math.Interval
     */ acot: function(x) {
        if (this.isEmpty(x)) {
            return this.EMPTY.clone();
        }
        return new MatInterval(this.acotLo(x.lo), this.acotHi(x.hi));
    },
    /**
     * @param {JXG.Math.Interval} x
     * @returns JXG.Math.Interval
     */ atan: function(x) {
        if (this.isEmpty(x)) {
            return this.EMPTY.clone();
        }
        return new MatInterval(this.atanLo(x.lo), this.atanHi(x.hi));
    },
    /**
     * @param {JXG.Math.Interval} x
     * @returns JXG.Math.Interval
     */ sinh: function(x) {
        if (this.isEmpty(x)) {
            return this.EMPTY.clone();
        }
        return new MatInterval(this.sinhLo(x.lo), this.sinhHi(x.hi));
    },
    /**
     * @param {JXG.Math.Interval} x
     * @returns JXG.Math.Interval
     */ cosh: function(x) {
        if (this.isEmpty(x)) {
            return this.EMPTY.clone();
        }
        if (x.hi < 0) {
            return new MatInterval(this.coshLo(x.hi), this.coshHi(x.lo));
        }
        if (x.lo >= 0) {
            return new MatInterval(this.coshLo(x.lo), this.coshHi(x.hi));
        }
        return new MatInterval(1, this.coshHi(-x.lo > x.hi ? x.lo : x.hi));
    },
    /**
     * @param {JXG.Math.Interval} x
     * @returns JXG.Math.Interval
     */ tanh: function(x) {
        if (this.isEmpty(x)) {
            return this.EMPTY.clone();
        }
        return new MatInterval(this.tanhLo(x.lo), this.tanhHi(x.hi));
    },
    /*
     * Relational
     */ /**
     * @param {JXG.Math.Interval} x
     * @param {JXG.Math.Interval} y
     * @returns Boolean
     */ equal: function(x, y) {
        if (this.isEmpty(x)) {
            return this.isEmpty(y);
        }
        return !this.isEmpty(y) && x.lo === y.lo && x.hi === y.hi;
    },
    // almostEqual: function(x, y): void {
    //     x = Array.isArray(x) ? x : x.toArray();
    //     y = Array.isArray(y) ? y : y.toArray();
    //     assertEps(x[0], y[0])
    //     assertEps(x[1], y[1])
    // },
    /**
     * @param {JXG.Math.Interval} x
     * @param {JXG.Math.Interval} y
     * @returns Boolean
     */ notEqual: function(x, y) {
        if (this.isEmpty(x)) {
            return !this.isEmpty(y);
        }
        return this.isEmpty(y) || x.hi < y.lo || x.lo > y.hi;
    },
    /**
     * @param {JXG.Math.Interval} x
     * @param {JXG.Math.Interval} y
     * @returns Boolean
     */ lt: function(x, y) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(x)) {
            x = this.Interval(x);
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(y)) {
            y = this.Interval(y);
        }
        if (this.isEmpty(x) || this.isEmpty(y)) {
            return false;
        }
        return x.hi < y.lo;
    },
    /**
     * @param {JXG.Math.Interval} x
     * @param {JXG.Math.Interval} y
     * @returns Boolean
     */ gt: function(x, y) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(x)) {
            x = this.Interval(x);
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(y)) {
            y = this.Interval(y);
        }
        if (this.isEmpty(x) || this.isEmpty(y)) {
            return false;
        }
        return x.lo > y.hi;
    },
    /**
     * @param {JXG.Math.Interval} x
     * @param {JXG.Math.Interval} y
     * @returns Boolean
     */ leq: function(x, y) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(x)) {
            x = this.Interval(x);
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(y)) {
            y = this.Interval(y);
        }
        if (this.isEmpty(x) || this.isEmpty(y)) {
            return false;
        }
        return x.hi <= y.lo;
    },
    /**
     * @param {JXG.Math.Interval} x
     * @param {JXG.Math.Interval} y
     * @returns Boolean
     */ geq: function(x, y) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(x)) {
            x = this.Interval(x);
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(y)) {
            y = this.Interval(y);
        }
        if (this.isEmpty(x) || this.isEmpty(y)) {
            return false;
        }
        return x.lo >= y.hi;
    },
    /*
     * Constants
     */ piLow: (3373259426.0 + 273688.0 / (1 << 21)) / (1 << 30),
    piHigh: (3373259426.0 + 273689.0 / (1 << 21)) / (1 << 30),
    piHalfLow: (3373259426.0 + 273688.0 / (1 << 21)) / (1 << 30) * 0.5,
    piHalfHigh: (3373259426.0 + 273689.0 / (1 << 21)) / (1 << 30) * 0.5,
    piTwiceLow: (3373259426.0 + 273688.0 / (1 << 21)) / (1 << 30) * 2,
    piTwiceHigh: (3373259426.0 + 273689.0 / (1 << 21)) / (1 << 30) * 2,
    /*
     * Round
     * Rounding functions for numbers
     */ identity: function(v) {
        return v;
    },
    _prev: function(v) {
        if (v === Infinity) {
            return v;
        }
        return this.nextafter(v, -Infinity);
    },
    _next: function(v) {
        if (v === -Infinity) {
            return v;
        }
        return this.nextafter(v, Infinity);
    },
    prev: function(v) {
        return this._prev(v);
    },
    next: function(v) {
        return this._next(v);
    },
    toInteger: function(x) {
        return x < 0 ? Math.ceil(x) : Math.floor(x);
    },
    addLo: function(x, y) {
        return this.prev(x + y);
    },
    addHi: function(x, y) {
        return this.next(x + y);
    },
    subLo: function(x, y) {
        return this.prev(x - y);
    },
    subHi: function(x, y) {
        return this.next(x - y);
    },
    mulLo: function(x, y) {
        return this.prev(x * y);
    },
    mulHi: function(x, y) {
        return this.next(x * y);
    },
    divLo: function(x, y) {
        return this.prev(x / y);
    },
    divHi: function(x, y) {
        return this.next(x / y);
    },
    intLo: function(x) {
        return this.toInteger(this.prev(x));
    },
    intHi: function(x) {
        return this.toInteger(this.next(x));
    },
    logLo: function(x) {
        return this.prev(Math.log(x));
    },
    logHi: function(x) {
        return this.next(Math.log(x));
    },
    expLo: function(x) {
        return this.prev(Math.exp(x));
    },
    expHi: function(x) {
        return this.next(Math.exp(x));
    },
    sinLo: function(x) {
        return this.prev(Math.sin(x));
    },
    sinHi: function(x) {
        return this.next(Math.sin(x));
    },
    cosLo: function(x) {
        return this.prev(Math.cos(x));
    },
    cosHi: function(x) {
        return this.next(Math.cos(x));
    },
    tanLo: function(x) {
        return this.prev(Math.tan(x));
    },
    tanHi: function(x) {
        return this.next(Math.tan(x));
    },
    asinLo: function(x) {
        return this.prev(Math.asin(x));
    },
    asinHi: function(x) {
        return this.next(Math.asin(x));
    },
    acosLo: function(x) {
        return this.prev(Math.acos(x));
    },
    acosHi: function(x) {
        return this.next(Math.acos(x));
    },
    acotLo: function(x) {
        return this.prev(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].acot(x));
    },
    acotHi: function(x) {
        return this.next(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].acot(x));
    },
    atanLo: function(x) {
        return this.prev(Math.atan(x));
    },
    atanHi: function(x) {
        return this.next(Math.atan(x));
    },
    sinhLo: function(x) {
        return this.prev(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].sinh(x));
    },
    sinhHi: function(x) {
        return this.next(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].sinh(x));
    },
    coshLo: function(x) {
        return this.prev(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cosh(x));
    },
    coshHi: function(x) {
        return this.next(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cosh(x));
    },
    tanhLo: function(x) {
        return this.prev(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].tanh(x));
    },
    tanhHi: function(x) {
        return this.next(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].tanh(x));
    },
    sqrtLo: function(x) {
        return this.prev(Math.sqrt(x));
    },
    sqrtHi: function(x) {
        return this.next(Math.sqrt(x));
    },
    powLo: function(x, power) {
        var y;
        if (power % 1 !== 0) {
            // power has decimals
            return this.prev(Math.pow(x, power));
        }
        y = (power & 1) === 1 ? x : 1;
        power >>= 1;
        while(power > 0){
            x = this.mulLo(x, x);
            if ((power & 1) === 1) {
                y = this.mulLo(x, y);
            }
            power >>= 1;
        }
        return y;
    },
    powHi: function(x, power) {
        var y;
        if (power % 1 !== 0) {
            // power has decimals
            return this.next(Math.pow(x, power));
        }
        y = (power & 1) === 1 ? x : 1;
        power >>= 1;
        while(power > 0){
            x = this.mulHi(x, x);
            if ((power & 1) === 1) {
                y = this.mulHi(x, y);
            }
            power >>= 1;
        }
        return y;
    },
    /**
     * @ignore
     * @private
     */ disable: function() {
        this.next = this.prev = this.identity;
    },
    /**
     * @ignore
     * @private
     */ enable: function() {
        this.prev = function(v) {
            return this._prev(v);
        };
        this.next = function(v) {
            return this._next(v);
        };
    },
    /*
     * nextafter
     */ SMALLEST_DENORM: Math.pow(2, -1074),
    UINT_MAX: -1 >>> 0,
    nextafter: function(x, y) {
        var lo, hi;
        if (isNaN(x) || isNaN(y)) {
            return NaN;
        }
        if (x === y) {
            return x;
        }
        if (x === 0) {
            if (y < 0) {
                return -this.SMALLEST_DENORM;
            }
            return this.SMALLEST_DENORM;
        }
        hi = doubleBits.hi(x);
        lo = doubleBits.lo(x);
        if (y > x === x > 0) {
            if (lo === this.UINT_MAX) {
                hi += 1;
                lo = 0;
            } else {
                lo += 1;
            }
        } else {
            if (lo === 0) {
                lo = this.UINT_MAX;
                hi -= 1;
            } else {
                lo -= 1;
            }
        }
        return doubleBits.pack(lo, hi);
    }
};
__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Math.IntervalArithmetic.PI = new MatInterval(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IntervalArithmetic.piLow, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IntervalArithmetic.piHigh);
__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Math.IntervalArithmetic.PI_HALF = new MatInterval(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IntervalArithmetic.piHalfLow, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IntervalArithmetic.piHalfHigh);
__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Math.IntervalArithmetic.PI_TWICE = new MatInterval(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IntervalArithmetic.piTwiceLow, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IntervalArithmetic.piTwiceHigh);
__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Math.IntervalArithmetic.ZERO = new MatInterval(0);
__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Math.IntervalArithmetic.ONE = new MatInterval(1);
__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Math.IntervalArithmetic.WHOLE = new MatInterval().setWhole();
__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Math.IntervalArithmetic.EMPTY = new MatInterval().setEmpty();
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Math.IntervalArithmetic;
}),
"[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/extrapolate.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Alfred Wassermann

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */ /*global JXG: true, define: true*/ /*jslint nomen: true, plusplus: true*/ __turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/math.js [app-client] (ecmascript)");
;
/**
 * Functions for extrapolation of sequences. Used for finding limits of sequences which is used for curve plotting.
 * @name JXG.Math.Extrapolate
 * @exports Mat.Extrapolate as JXG.Math.Extrapolate
 * @namespace
 */ __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Extrapolate = {
    upper: 15,
    infty: 1e4,
    /**
     * Wynn's epsilon algorithm. Ported from the FORTRAN version in
     * Ernst Joachim Weniger, "Nonlinear sequence transformations for the acceleration of convergence
     * and the summation of divergent series", Computer Physics Reports Vol. 10, 189-371 (1989).
     *
     * @param {Number} s_n next value of sequence, i.e. n-th element of sequence
     * @param {Number} n index of s_n in the sequence
     * @param {Array} e One-dimensional array containing the extrapolation data. Has to be supplied by the calling routine.
     * @returns {Number} New estimate of the limit of the sequence.
     *
     * @memberof JXG.Math.Extrapolate
     */ wynnEps: function(s_n, n, e) {
        var HUGE = 1e20, TINY = 1e-15, f0 = 1, f, j, aux1, aux2, diff, estlim;
        e[n] = s_n;
        if (n === 0) {
            estlim = s_n;
        } else {
            aux2 = 0.0;
            for(j = n; j > 0; j--){
                aux1 = aux2;
                aux2 = e[j - 1];
                diff = e[j] - aux2;
                if (Math.abs(diff) <= TINY) {
                    e[j - 1] = HUGE;
                } else {
                    f = (n - j + 1) % 2 === 1 ? f0 : 1;
                    e[j - 1] = aux1 * f + 1 / diff;
                }
            }
            estlim = e[n % 2];
        }
        return estlim;
    },
    // wynnRho: function(s_n, n, e) {
    //     var HUGE = 1.e+20,
    //         TINY = 1.e-15,
    //         j, f,
    //         aux1, aux2, diff, estlim;
    //     e[n] = s_n;
    //     if (n === 0) {
    //         estlim = s_n;
    //     } else {
    //         aux2 = 0.0;
    //         for (j = n; j >= 1; j--) {
    //             aux1 = aux2;
    //             aux2 = e[j - 1];
    //             diff = e[j] - aux2;
    //             if (Math.abs(diff) <= TINY) {
    //                 e[j - 1] = HUGE;
    //             } else {
    //                 f = ((n - j + 1) % 2 === 1) ? n - j + 1  : 1;
    //                 e[j - 1] = aux1 + f / diff;
    //             }
    //         }
    //         estlim = e[n % 2];
    //     }
    //     return estlim;
    // },
    /**
     * Aitken transformation. Ported from the FORTRAN version in
     * Ernst Joachim Weniger, "Nonlinear sequence transformations for the acceleration of convergence
     * and the summation of divergent series", Computer Physics Reports Vol. 10, 189-371 (1989).
     *
     * @param {Number} s_n next value of sequence, i.e. n-th element of sequence
     * @param {Number} n index of s_n in the sequence
     * @param {Array} a One-dimensional array containing the extrapolation data. Has to be supplied by the calling routine.
     * @returns {Number} New estimate of the limit of the sequence.
     *
     * @memberof JXG.Math.Extrapolate
     */ aitken: function(s_n, n, a) {
        var estlim, HUGE = 1e20, TINY = 1e-15, denom, v, lowmax, j, m;
        a[n] = s_n;
        if (n < 2) {
            estlim = s_n;
        } else {
            lowmax = n / 2;
            for(j = 1; j <= lowmax; j++){
                m = n - 2 * j;
                denom = a[m + 2] - 2 * a[m + 1] + a[m];
                if (Math.abs(denom) < TINY) {
                    a[m] = HUGE;
                } else {
                    v = a[m] - a[m + 1];
                    a[m] -= v * v / denom;
                }
            }
            estlim = a[n % 2];
        }
        return estlim;
    },
    /**
     * Iterated Brezinski transformation. Ported from the FORTRAN version in
     * Ernst Joachim Weniger, "Nonlinear sequence transformations for the acceleration of convergence
     * and the summation of divergent series", Computer Physics Reports Vol. 10, 189-371 (1989).
     *
     * @param {Number} s_n next value of sequence, i.e. n-th element of sequence
     * @param {Number} n index of s_n in the sequence
     * @param {Array} a One-dimensional array containing the extrapolation data. Has to be supplied by the calling routine.
     * @returns {Number} New estimate of the limit of the sequence.
     *
     * @memberof JXG.Math.Extrapolate
     */ brezinski: function(s_n, n, a) {
        var estlim, HUGE = 1e20, TINY = 1e-15, denom, d0, d1, d2, lowmax, j, m;
        a[n] = s_n;
        if (n < 3) {
            estlim = s_n;
        } else {
            lowmax = n / 3;
            m = n;
            for(j = 1; j <= lowmax; j++){
                m -= 3;
                d0 = a[m + 1] - a[m];
                d1 = a[m + 2] - a[m + 1];
                d2 = a[m + 3] - a[m + 2];
                denom = d2 * (d1 - d0) - d0 * (d2 - d1);
                if (Math.abs(denom) < TINY) {
                    a[m] = HUGE;
                } else {
                    a[m] = a[m + 1] - d0 * d1 * (d2 - d1) / denom;
                }
            }
            estlim = a[n % 3];
        }
        return estlim;
    },
    /**
     * Extrapolated iteration to approximate the value f(x_0).
     *
     * @param {Number} x0 Value for which the limit of f is to be determined. f(x0) may or may not exist.
     * @param {Number} h0 Initial (signed) distance from x0.
     * @param {Function} f Function for which the limit at x0 is to be determined
     * @param {String} method String to choose the method. Available values: "wynnEps", "aitken", "brezinski"
     * @param {Number} step_type Approximation method. step_type = 0 uses the sequence x0 + h0/n; step_type = 1 uses the sequence x0 + h0 * 2^(-n)
     *
     * @returns {Array} Array of length 3. Position 0: estimated value for f(x0), position 1: 'finite', 'infinite', or 'NaN'.
     * Position 2: value between 0 and 1 judging the reliability of the result (1: high, 0: not successful).
     *
     * @memberof JXG.Math.Extrapolate
     * @see JXG.Math.Extrapolate.limit
     * @see JXG.Math.Extrapolate.wynnEps
     * @see JXG.Math.Extrapolate.aitken
     * @see JXG.Math.Extrapolate.brezinski
     */ iteration: function(x0, h0, f, method, step_type) {
        var n, v, w, estlim = NaN, diff, r = 0.5, E = [], result = "finite", h = h0;
        step_type = step_type || 0;
        for(n = 1; n <= this.upper; n++){
            h = step_type === 0 ? h0 / (n + 1) : h * r;
            v = f(x0 + h, true);
            w = this[method](v, n - 1, E);
            //console.log(n, x0 + h, v, w);
            if (isNaN(w)) {
                result = "NaN";
                break;
            }
            if (v !== 0 && w / v > this.infty) {
                estlim = w;
                result = "infinite";
                break;
            }
            diff = w - estlim;
            if (Math.abs(diff) < 1e-7) {
                break;
            }
            estlim = w;
        }
        return [
            estlim,
            result,
            1 - (n - 1) / this.upper
        ];
    },
    /**
     * Levin transformation. See Numerical Recipes, ed. 3.
     * Not yet ready for use.
     *
     * @param {Number} s_n next value of sequence, i.e. n-th element of sequence
     * @param {Number} n index of s_n in the sequence
     * @param {Array} numer One-dimensional array containing the extrapolation data for the numerator. Has to be supplied by the calling routine.
     * @param {Array} denom One-dimensional array containing the extrapolation data for the denominator. Has to be supplied by the calling routine.
     *
     * @memberof JXG.Math.Extrapolate
     */ levin: function(s_n, n, omega, beta, numer, denom) {
        var HUGE = 1e20, TINY = 1e-15, j, fact, ratio, term, estlim;
        term = 1.0 / (beta + n);
        numer[n] = s_n / omega;
        denom[n] = 1 / omega;
        if (n > 0) {
            numer[n - 1] = numer[n] - numer[n - 1];
            denom[n - 1] = denom[n] - denom[n - 1];
            if (n > 1) {
                ratio = (beta + n - 1) * term;
                for(j = 2; j <= n; j++){
                    fact = (beta + n - j) * Math.pow(ratio, j - 2) * term;
                    numer[n - j] = numer[n - j + 1] - fact * numer[n - j];
                    denom[n - j] = denom[n - j + 1] - fact * denom[n - j];
                    term *= ratio;
                }
            }
        }
        if (Math.abs(denom[0]) < TINY) {
            estlim = HUGE;
        } else {
            estlim = numer[0] / denom[0];
        }
        return estlim;
    },
    iteration_levin: function(x0, h0, f, step_type) {
        var n, v, w, estlim = NaN, v_prev, delta, diff, omega, beta = 1, r = 0.5, numer = [], denom = [], result = "finite", h = h0, transform = "u";
        step_type = step_type || 0;
        v_prev = f(x0 + h0, true);
        for(n = 1; n <= this.upper; n++){
            h = step_type === 0 ? h0 / (n + 1) : h * r;
            v = f(x0 + h, true);
            delta = v - v_prev;
            if (Math.abs(delta) < 1) {
                transform = "u";
            } else {
                transform = "t";
            }
            if (transform === "u") {
                omega = (beta + n) * delta; // u transformation
            } else {
                omega = delta; // t transformation
            }
            v_prev = v;
            w = this.levin(v, n - 1, omega, beta, numer, denom);
            diff = w - estlim;
            // console.log(n, delta, transform, x0 + h, v, w, diff);
            if (isNaN(w)) {
                result = "NaN";
                break;
            }
            if (v !== 0 && w / v > this.infty) {
                estlim = w;
                result = "infinite";
                break;
            }
            if (Math.abs(diff) < 1e-7) {
                break;
            }
            estlim = w;
        }
        return [
            estlim,
            result,
            1 - (n - 1) / this.upper
        ];
    },
    /**
     *
     * @param {Number} x0 Value for which the limit of f is to be determined. f(x0) may or may not exist.
     * @param {Number} h0 Initial (signed) distance from x0.
     * @param {Function} f Function for which the limit at x0 is to be determined
     *
     * @returns {Array} Array of length 3. Position 0: estimated value for f(x0), position 1: 'finite', 'infinite', or 'NaN'.
     * Position 2: value between 0 and 1 judging the reliability of the result (1: high, 0: not successful).
     * In case that the extrapolation fails, position 1 and 2 contain 'direct' and 0.
     *
     * @example
     * var f1 = (x) => Math.log(x),
     *     f2 = (x) => Math.tan(x - Math.PI * 0.5),
     *     f3 = (x) => 4 / x;
     *
     * var x0 = 0.0000001;
     * var h = 0.1;
     * for (let f of [f1, f2, f3]) {
     *     console.log("x0=", x0, f.toString());
     *     console.log(JXG.Math.Extrapolate.limit(x0, h, f));
     *  }
     *
     * </pre><div id="JXG5e8c6a7e-eeae-43fb-a669-26b5c9e40cab" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG5e8c6a7e-eeae-43fb-a669-26b5c9e40cab',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     var f1 = (x) => Math.log(x),
     *         f2 = (x) => Math.tan(x - Math.PI * 0.5),
     *         f3 = (x) => 4 / x;
     *
     *     var x0 = 0.0000001;
     *     var h = 0.1;
     *     for (let f of [f1, f2, f3]) {
     *         console.log("x0=", x0, f.toString());
     *         console.log(JXG.Math.Extrapolate.limit(x0, h, f));
     *      }
     *
     *     })();
     *
     * </script><pre>
     *
     *
     * @see JXG.Math.Extrapolate.iteration
     * @memberof JXG.Math.Extrapolate
     */ limit: function(x0, h0, f) {
        return this.iteration_levin(x0, h0, f, 0);
    //return this.iteration(x0, h0, f, 'wynnEps', 1);
    // var algs = ['wynnEps', 'levin'], //, 'wynnEps', 'levin', 'aitken', 'brezinski'],
    //     le = algs.length,
    //     i, t, res;
    // for (i = 0; i < le; i++) {
    //     for (t = 0; t < 1; t++) {
    //         if (algs[i] === 'levin') {
    //             res = this.iteration_levin(x0, h0, f, t);
    //         } else {
    //             res = this.iteration(x0, h0, f, algs[i], t);
    //         }
    //         if (res[2] > 0.6) {
    //             return res;
    //         }
    //         console.log(algs[i], t, res)
    //     }
    // }
    // return [f(x0 + Math.sign(h0) * Math.sqrt(Mat.eps)), 'direct', 0];
    }
};
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Extrapolate;
}),
"[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/statistics.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */ /*global JXG: true, define: true*/ /*jslint nomen: true, plusplus: true*/ __turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/jxg.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/math.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/utils/type.js [app-client] (ecmascript)");
;
;
;
/**
 * Functions for mathematical statistics. Most functions are like in the statistics package R.
 * @name JXG.Math.Statistics
 * @exports Mat.Statistics as JXG.Math.Statistics
 * @namespace
 */ __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Statistics = {
    /**
     * Sums up all elements of the given array.
     * @param {Array} arr An array of numbers.
     * @returns {Number}
     * @memberof JXG.Math.Statistics
     */ sum: function(arr) {
        var i, len = arr.length, res = 0;
        for(i = 0; i < len; i++){
            res += arr[i];
        }
        return res;
    },
    /**
     * Multiplies all elements of the given array.
     * @param {Array} arr An array of numbers.
     * @returns {Number}
     * @memberof JXG.Math.Statistics
     */ prod: function(arr) {
        var i, len = arr.length, res = 1;
        for(i = 0; i < len; i++){
            res *= arr[i];
        }
        return res;
    },
    /**
     * Determines the mean value of the values given in an array.
     * @param {Array} arr
     * @returns {Number}
     * @memberof JXG.Math.Statistics
     */ mean: function(arr) {
        if (arr.length > 0) {
            return this.sum(arr) / arr.length;
        }
        return 0.0;
    },
    /**
     * The median of a finite set of values is the value that divides the set
     * into two equal sized subsets.
     * @param {Array} arr The set of values.
     * @returns {Number}
     * @memberof JXG.Math.Statistics
     */ median: function(arr) {
        var tmp, len;
        if (arr.length > 0) {
            if (ArrayBuffer.isView(arr)) {
                tmp = new Float64Array(arr);
                tmp.sort();
            } else {
                tmp = arr.slice(0);
                tmp.sort(function(a, b) {
                    return a - b;
                });
            }
            len = tmp.length;
            if (len & 1) {
                // odd
                return tmp[parseInt(len * 0.5, 10)];
            }
            return (tmp[len * 0.5 - 1] + tmp[len * 0.5]) * 0.5;
        }
        return 0.0;
    },
    /**
     * The P-th percentile ( <i>0 < P  100</i> ) of a list of <i>N</i> ordered values (sorted from least to greatest)
     * is the smallest value in the list such that no more than <i>P</i> percent of the data is strictly less
     * than the value and at least <i>P</i> percent of the data is less than or equal to that value.
     * See <a href="https://en.wikipedia.org/wiki/Percentile">https://en.wikipedia.org/wiki/Percentile</a>.
     *
     * Here, the <i>linear interpolation between closest ranks</i> method is used.
     * @param {Array} arr The set of values, need not be ordered.
     * @param {Number|Array} percentile One or several percentiles
     * @returns {Number|Array} Depending if a number or an array is the input for percentile, a number or an array containing the percentiles
     * is returned.
     */ percentile: function(arr, percentile) {
        var tmp, len, i, p, res = [], per;
        if (arr.length > 0) {
            if (ArrayBuffer.isView(arr)) {
                tmp = new Float64Array(arr);
                tmp.sort();
            } else {
                tmp = arr.slice(0);
                tmp.sort(function(a, b) {
                    return a - b;
                });
            }
            len = tmp.length;
            if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(percentile)) {
                p = percentile;
            } else {
                p = [
                    percentile
                ];
            }
            for(i = 0; i < p.length; i++){
                per = len * p[i] * 0.01;
                if (parseInt(per, 10) === per) {
                    res.push((tmp[per - 1] + tmp[per]) * 0.5);
                } else {
                    res.push(tmp[parseInt(per, 10)]);
                }
            }
            if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(percentile)) {
                return res;
            } else {
                return res[0];
            }
        }
        return 0.0;
    },
    /**
     * Bias-corrected sample variance. A variance is a measure of how far a
     * set of numbers are spread out from each other.
     * @param {Array} arr
     * @returns {Number}
     * @memberof JXG.Math.Statistics
     */ variance: function(arr) {
        var m, res, i, len = arr.length;
        if (len > 1) {
            m = this.mean(arr);
            res = 0;
            for(i = 0; i < len; i++){
                res += (arr[i] - m) * (arr[i] - m);
            }
            return res / (arr.length - 1);
        }
        return 0.0;
    },
    /**
     * Determines the <strong>s</strong>tandard <strong>d</strong>eviation which shows how much
     * variation there is from the average value of a set of numbers.
     * @param {Array} arr
     * @returns {Number}
     * @memberof JXG.Math.Statistics
     */ sd: function(arr) {
        return Math.sqrt(this.variance(arr));
    },
    /**
     * Weighted mean value is basically the same as {@link JXG.Math.Statistics.mean} but here the values
     * are weighted, i.e. multiplied with another value called <em>weight</em>. The weight values are given
     * as a second array with the same length as the value array..
     * @throws {Error} If the dimensions of the arrays don't match.
     * @param {Array} arr Set of alues.
     * @param {Array} w Weight values.
     * @returns {Number}
     * @memberof JXG.Math.Statistics
     */ weightedMean: function(arr, w) {
        if (arr.length !== w.length) {
            throw new Error("JSXGraph error (Math.Statistics.weightedMean): Array dimension mismatch.");
        }
        if (arr.length > 0) {
            return this.mean(this.multiply(arr, w));
        }
        return 0.0;
    },
    /**
     * Extracts the maximum value from the array.
     * @param {Array} arr
     * @returns {Number} The highest number from the array. It returns <tt>NaN</tt> if not every element could be
     * interpreted as a number and <tt>-Infinity</tt> if an empty array is given or no element could be interpreted
     * as a number.
     * @memberof JXG.Math.Statistics
     */ max: function(arr) {
        return Math.max.apply(this, arr);
    },
    /**
     * Extracts the minimum value from the array.
     * @param {Array} arr
     * @returns {Number} The lowest number from the array. It returns <tt>NaN</tt> if not every element could be
     * interpreted as a number and <tt>Infinity</tt> if an empty array is given or no element could be interpreted
     * as a number.
     * @memberof JXG.Math.Statistics
     */ min: function(arr) {
        return Math.min.apply(this, arr);
    },
    /**
     * Determines the lowest and the highest value from the given array.
     * @param {Array} arr
     * @returns {Array} The minimum value as the first and the maximum value as the second value.
     * @memberof JXG.Math.Statistics
     */ range: function(arr) {
        return [
            this.min(arr),
            this.max(arr)
        ];
    },
    /**
     * Determines the absolute value of every given value.
     * @param {Array|Number} arr
     * @returns {Array|Number}
     * @memberof JXG.Math.Statistics
     */ abs: function(arr) {
        var i, len, res;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(arr)) {
            if (arr.map) {
                res = arr.map(Math.abs);
            } else {
                len = arr.length;
                res = [];
                for(i = 0; i < len; i++){
                    res[i] = Math.abs(arr[i]);
                }
            }
        } else if (ArrayBuffer.isView(arr)) {
            res = arr.map(Math.abs);
        } else {
            res = Math.abs(arr);
        }
        return res;
    },
    /**
     * Adds up two (sequences of) values. If one value is an array and the other one is a number the number
     * is added to every element of the array. If two arrays are given and the lengths don't match the shortest
     * length is taken.
     * @param {Array|Number} arr1
     * @param {Array|Number} arr2
     * @returns {Array|Number}
     * @memberof JXG.Math.Statistics
     */ add: function(arr1, arr2) {
        var i, len, res = [];
        arr1 = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evalSlider(arr1);
        arr2 = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evalSlider(arr2);
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(arr1) && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(arr2)) {
            len = arr1.length;
            for(i = 0; i < len; i++){
                res[i] = arr1[i] + arr2;
            }
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(arr1) && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(arr2)) {
            len = arr2.length;
            for(i = 0; i < len; i++){
                res[i] = arr1 + arr2[i];
            }
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(arr1) && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(arr2)) {
            len = Math.min(arr1.length, arr2.length);
            for(i = 0; i < len; i++){
                res[i] = arr1[i] + arr2[i];
            }
        } else {
            res = arr1 + arr2;
        }
        return res;
    },
    /**
     * Divides two (sequences of) values. If two arrays are given and the lengths don't match the shortest length
     * is taken.
     * @param {Array|Number} arr1 Dividend
     * @param {Array|Number} arr2 Divisor
     * @returns {Array|Number}
     * @memberof JXG.Math.Statistics
     */ div: function(arr1, arr2) {
        var i, len, res = [];
        arr1 = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evalSlider(arr1);
        arr2 = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evalSlider(arr2);
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(arr1) && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(arr2)) {
            len = arr1.length;
            for(i = 0; i < len; i++){
                res[i] = arr1[i] / arr2;
            }
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(arr1) && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(arr2)) {
            len = arr2.length;
            for(i = 0; i < len; i++){
                res[i] = arr1 / arr2[i];
            }
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(arr1) && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(arr2)) {
            len = Math.min(arr1.length, arr2.length);
            for(i = 0; i < len; i++){
                res[i] = arr1[i] / arr2[i];
            }
        } else {
            res = arr1 / arr2;
        }
        return res;
    },
    /**
     * @function
     * @deprecated Use {@link JXG.Math.Statistics.div} instead.
     * @memberof JXG.Math.Statistics
     */ divide: function() {
        __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].deprecated("Statistics.divide()", "Statistics.div()");
        __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Statistics.div.apply(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Statistics, arguments);
    },
    /**
     * Divides two (sequences of) values and returns the remainder. If two arrays are given and the lengths don't
     * match the shortest length is taken.
     * @param {Array|Number} arr1 Dividend
     * @param {Array|Number} arr2 Divisor
     * @param {Boolean} [math=false] Mathematical mod or symmetric mod? Default is symmetric, the JavaScript <tt>%</tt> operator.
     * @returns {Array|Number}
     * @memberof JXG.Math.Statistics
     */ mod: function(arr1, arr2, math) {
        var i, len, res = [], mod = function(a, m) {
            return a % m;
        };
        math = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].def(math, false);
        if (math) {
            mod = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].mod;
        }
        arr1 = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evalSlider(arr1);
        arr2 = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evalSlider(arr2);
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(arr1) && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(arr2)) {
            len = arr1.length;
            for(i = 0; i < len; i++){
                res[i] = mod(arr1[i], arr2);
            }
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(arr1) && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(arr2)) {
            len = arr2.length;
            for(i = 0; i < len; i++){
                res[i] = mod(arr1, arr2[i]);
            }
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(arr1) && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(arr2)) {
            len = Math.min(arr1.length, arr2.length);
            for(i = 0; i < len; i++){
                res[i] = mod(arr1[i], arr2[i]);
            }
        } else {
            res = mod(arr1, arr2);
        }
        return res;
    },
    /**
     * Multiplies two (sequences of) values. If one value is an array and the other one is a number the number
     * is multiplied to every element of the array. If two arrays are given and the lengths don't match the shortest
     * length is taken.
     * @param {Array|Number} arr1
     * @param {Array|Number} arr2
     * @returns {Array|Number}
     * @memberof JXG.Math.Statistics
     */ multiply: function(arr1, arr2) {
        var i, len, res = [];
        arr1 = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evalSlider(arr1);
        arr2 = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evalSlider(arr2);
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(arr1) && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(arr2)) {
            len = arr1.length;
            for(i = 0; i < len; i++){
                res[i] = arr1[i] * arr2;
            }
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(arr1) && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(arr2)) {
            len = arr2.length;
            for(i = 0; i < len; i++){
                res[i] = arr1 * arr2[i];
            }
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(arr1) && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(arr2)) {
            len = Math.min(arr1.length, arr2.length);
            for(i = 0; i < len; i++){
                res[i] = arr1[i] * arr2[i];
            }
        } else {
            res = arr1 * arr2;
        }
        return res;
    },
    /**
     * Subtracts two (sequences of) values. If two arrays are given and the lengths don't match the shortest
     * length is taken.
     * @param {Array|Number} arr1 Minuend
     * @param {Array|Number} arr2 Subtrahend
     * @returns {Array|Number}
     * @memberof JXG.Math.Statistics
     */ subtract: function(arr1, arr2) {
        var i, len, res = [];
        arr1 = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evalSlider(arr1);
        arr2 = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evalSlider(arr2);
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(arr1) && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(arr2)) {
            len = arr1.length;
            for(i = 0; i < len; i++){
                res[i] = arr1[i] - arr2;
            }
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(arr1) && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(arr2)) {
            len = arr2.length;
            for(i = 0; i < len; i++){
                res[i] = arr1 - arr2[i];
            }
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(arr1) && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(arr2)) {
            len = Math.min(arr1.length, arr2.length);
            for(i = 0; i < len; i++){
                res[i] = arr1[i] - arr2[i];
            }
        } else {
            res = arr1 - arr2;
        }
        return res;
    },
    /**
     * The Theil-Sen estimator can be used to determine a more robust linear regression of a set of sample
     * points than least squares regression in {@link JXG.Math.Numerics.regressionPolynomial}.
     *
     * If the function should be applied to an array a of points, a the coords array can be generated with
     * JavaScript array.map:
     *
     * <pre>
     * JXG.Math.Statistics.TheilSenRegression(a.map(el => el.coords));
     * </pre>
     *
     * @param {Array} coords Array of {@link JXG.Coords}.
     * @returns {Array} A stdform array of the regression line.
     * @memberof JXG.Math.Statistics
     *
     * @example
     * var board = JXG.JSXGraph.initBoard('jxgbox', { boundingbox: [-6,6,6,-6], axis : true });
     * var a=[];
     * a[0]=board.create('point', [0,0]);
     * a[1]=board.create('point', [3,0]);
     * a[2]=board.create('point', [0,3]);
     *
     * board.create('line', [
     *     () => JXG.Math.Statistics.TheilSenRegression(a.map(el => el.coords))
     *   ],
     *   {strokeWidth:1, strokeColor:'black'});
     *
     * </pre><div id="JXG0a28be85-91c5-44d3-aae6-114e81217cf0" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG0a28be85-91c5-44d3-aae6-114e81217cf0',
     *             {boundingbox: [-6,6,6,-6], axis: true, showcopyright: false, shownavigation: false});
     *     var a=[];
     *     a[0]=board.create('point', [0,0]);
     *     a[1]=board.create('point', [3,0]);
     *     a[2]=board.create('point', [0,3]);
     *
     *     board.create('line', [
     *         () => JXG.Math.Statistics.TheilSenRegression(a.map(el => el.coords))
     *       ],
     *       {strokeWidth:1, strokeColor:'black'});
     *
     *     })();
     *
     * </script><pre>
     *
     */ TheilSenRegression: function(coords) {
        var i, j, slopes = [], tmpslopes = [], yintercepts = [];
        for(i = 0; i < coords.length; i++){
            tmpslopes.length = 0;
            for(j = 0; j < coords.length; j++){
                if (Math.abs(coords[j].usrCoords[1] - coords[i].usrCoords[1]) > __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
                    tmpslopes[j] = (coords[j].usrCoords[2] - coords[i].usrCoords[2]) / (coords[j].usrCoords[1] - coords[i].usrCoords[1]);
                }
            }
            slopes[i] = this.median(tmpslopes);
            yintercepts.push(coords[i].usrCoords[2] - slopes[i] * coords[i].usrCoords[1]);
        }
        return [
            this.median(yintercepts),
            this.median(slopes),
            -1
        ];
    },
    /**
     * Generate values of a standard normal random variable with the Marsaglia polar method, see
     * <a href="https://en.wikipedia.org/wiki/Marsaglia_polar_method">https://en.wikipedia.org/wiki/Marsaglia_polar_method</a>.
     * See also D. E. Knuth, The art of computer programming, vol 2, p. 117.
     *
     * @param {Number} mean mean value of the normal distribution
     * @param {Number} stdDev standard deviation of the normal distribution
     * @returns {Number} value of a standard normal random variable
     * @memberof JXG.Math.Statistics
     */ generateGaussian: function(mean, stdDev) {
        var u, v, s;
        if (this.hasSpare) {
            this.hasSpare = false;
            return this.spare * stdDev + mean;
        }
        do {
            u = Math.random() * 2 - 1;
            v = Math.random() * 2 - 1;
            s = u * u + v * v;
        }while (s >= 1 || s === 0)
        s = Math.sqrt(-2.0 * Math.log(s) / s);
        this.spare = v * s;
        this.hasSpare = true;
        return mean + stdDev * u * s;
    },
    /**
     * Generate value of a standard normal random variable with given mean and standard deviation.
     * Alias for {@link JXG.Math.Statistics#generateGaussian}
     *
     * @param {Number} mean
     * @param {Number} stdDev
     * @returns Number
     * @memberof JXG.Math.Statistics
     * @see JXG.Math.Statistics.generateGaussian
     * @example
     *  let board = JXG.JSXGraph.initBoard('JXGbox',
     *       { boundingbox: [-5, 1.5, 5, -.03], axis: true});
     *
     *   let runs = [
     *       [0, 0.2, 'blue'],
     *       [0, 1.0, 'red'],
     *       [0, 5.0, 'orange'],
     *       [-2,0.5, 'green'],
     *   ]
     *
     *   let labelY = 1.2
     *   runs.forEach((run,i) => {
     *       board.create('segment',[[1.0,labelY-(i/20)],[2.0,labelY-(i/20)]],{strokeColor:run[2]})
     *       board.create('text',[2.5,labelY-(i/20),`&mu;=${run[0]}, &#963;<sup>2</sup>=${run[1]}`])
     *
     *       let x = Array(50000).fill(0).map(() => JXG.Math.Statistics.randomNormal(run[0],Math.sqrt(run[1])))  // sqrt so Std Dev, not Variance
     *       let res = JXG.Math.Statistics.histogram(x, { bins: 40, density: true, cumulative: false, range: false });
     *       board.create('curve', [res[1], res[0]], { strokeColor: run[2], strokeWidth:2});
     *   })
     *
     * </pre><div id="JXGda56df4d-a5a5-4c87-9ffc-9bbc1b512302-4" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     * {
     *  let board = JXG.JSXGraph.initBoard('JXGda56df4d-a5a5-4c87-9ffc-9bbc1b512302-4',
     *       { boundingbox: [-5, 1.5, 5, -.03], axis: true});
     *
     *   let runs = [
     *       [0, 0.2, 'blue'],
     *       [0, 1.0, 'red'],
     *       [0, 5.0, 'orange'],
     *       [-2,0.5, 'green'],
     *   ]
     *
     *   let labelY = 1.2
     *   runs.forEach((run,i) => {
     *       board.create('segment',[[1.0,labelY-(i/20)],[2.0,labelY-(i/20)]],{strokeColor:run[2]})
     *       board.create('text',[2.5,labelY-(i/20),`&mu;=${run[0]}, &#963;<sup>2</sup>=${run[1]}`])
     *
     *       let x = Array(50000).fill(0).map(() => JXG.Math.Statistics.randomNormal(run[0],Math.sqrt(run[1])))  // sqrt so Std Dev, not Variance
     *       let res = JXG.Math.Statistics.histogram(x, { bins: 40, density: true, cumulative: false, range: false });
     *       board.create('curve', [res[1], res[0]], { strokeColor: run[2], strokeWidth:2});
     *   })
     * }
     * </script><pre>

     */ randomNormal: function(mean, stdDev) {
        return this.generateGaussian(mean, stdDev);
    },
    /**
     * Generate value of a uniform distributed random variable in the interval [a, b].
     * @param {Number} a
     * @param {Number} b
     * @returns Number
     * @memberof JXG.Math.Statistics
     */ randomUniform: function(a, b) {
        return Math.random() * (b - a) + a;
    },
    /**
     * Generate value of a random variable with exponential distribution, i.e.
     * <i>f(x; lambda) = lambda * e^(-lambda x)</i> if <i>x >= 0</i> and <i>f(x; lambda) = 0</i> if <i>x < 0</i>.
     * See <a href="https://en.wikipedia.org/wiki/Exponential_distribution">https://en.wikipedia.org/wiki/Exponential_distribution</a>.
     * Algorithm: D.E. Knuth, TAOCP 2, p. 128.
     *
     * @param {Number} lambda <i>&gt; 0</i>
     * @returns Number
     * @memberof JXG.Math.Statistics
     * @example
     *  let board = JXG.JSXGraph.initBoard('JXGbox',
     *       { boundingbox: [-.5, 1.5, 5, -.1], axis: true});
     *
     *   let runs = [
     *       [0.5, 'red'],
     *       [1.0, 'green'],
     *       [1.5, 'blue'],
     *   ]
     *
     *   let labelY = 1
     *   runs.forEach((run,i) => {
     *       board.create('segment',[[1.8,labelY-(i/20)],[2.3,labelY-(i/20)]],{strokeColor:run[1]})
     *       board.create('text',[2.5,labelY-(i/20),`&lambda;=${run[0]}`])
     *
     *       let x = Array(50000).fill(0).map(() => JXG.Math.Statistics.randomExponential(run[0]))
     *       let res = JXG.Math.Statistics.histogram(x, { bins: 40, density: true, cumulative: false, range: false });
     *       board.create('curve', [res[1], res[0]], { strokeColor: run[1], strokeWidth:2});
     *   })
     *
     * </pre><div id="JXGda56df4d-a5a5-4c87-9ffc-9bbc1b512302-5" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     * {
     *  let board = JXG.JSXGraph.initBoard('JXGda56df4d-a5a5-4c87-9ffc-9bbc1b512302-5',
     *       { boundingbox: [-.5, 1.5, 5, -.1], axis: true});
     *
     *   let runs = [
     *       [0.5, 'red'],
     *       [1.0, 'green'],
     *       [1.5, 'blue'],
     *   ]
     *
     *   let labelY = 1
     *   runs.forEach((run,i) => {
     *       board.create('segment',[[1.8,labelY-(i/20)],[2.3,labelY-(i/20)]],{strokeColor:run[1]})
     *       board.create('text',[2.5,labelY-(i/20),`&lambda;=${run[0]}`])
     *
     *       let x = Array(50000).fill(0).map(() => JXG.Math.Statistics.randomExponential(run[0]))
     *       let res = JXG.Math.Statistics.histogram(x, { bins: 40, density: true, cumulative: false, range: false });
     *       board.create('curve', [res[1], res[0]], { strokeColor: run[1], strokeWidth:2});
     *   })
     * }
     * </script><pre>

    */ randomExponential: function(lbda) {
        var u;
        // Knuth, TAOCP 2, p 128
        // See https://en.wikipedia.org/wiki/Exponential_distribution
        if (lbda <= 0) {
            return NaN;
        }
        do {
            u = Math.random();
        }while (u === 0)
        return -Math.log(u) / lbda;
    },
    /**
     * Generate value of a random variable with gamma distribution of order alpha.
     * See <a href="https://en.wikipedia.org/wiki/Gamma_distribution">https://en.wikipedia.org/wiki/Gamma_distribution</a>.
     * Algorithm: D.E. Knuth, TAOCP 2, p. 129.

     * @param {Number} a shape, <i> &gt; 0</i>
     * @param {Number} [b=1] scale, <i> &gt; 0</i>
     * @param {Number} [t=0] threshold
     * @returns Number
     * @memberof JXG.Math.Statistics
     * @example
     *  let board = JXG.JSXGraph.initBoard('jxgbox',
     *       { boundingbox: [-1.7, .5, 20, -.03], axis: true});
     *
     *   let runs = [
     *       [0.5, 1.0, 'brown'],
     *       [1.0, 2.0, 'red'],
     *       [2.0, 2.0, 'orange'],
     *       [3.0, 2.0, 'yellow'],
     *       [5.0, 1.0, 'green'],
     *       [9.0, 0.5, 'black'],
     *       [7.5, 1.0, 'purple'],
     *   ]
     *
     *   let labelY = .4
     *   runs.forEach((run,i) => {
     *       board.create('segment',[[7,labelY-(i/50)],[9,labelY-(i/50)]],{strokeColor:run[2]})
     *       board.create('text',[10,labelY-(i/50),`k=${run[0]}, &theta;=${run[1]}`])
     *
     *       // density
     *       let x = Array(50000).fill(0).map(() => JXG.Math.Statistics.randomGamma(run[0],run[1]))
     *       let res = JXG.Math.Statistics.histogram(x, { bins: 50, density: true, cumulative: false, range: [0, 20] });
     *       board.create('curve', [res[1], res[0]], { strokeColor: run[2]});
     *
     *   })
     *
     *
     * </pre>
     * <div id="JXGda56df4d-a5a5-4c87-9ffc-9bbc1b512302-6" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     * {
     *  let board = JXG.JSXGraph.initBoard('JXGda56df4d-a5a5-4c87-9ffc-9bbc1b512302-6',
     *       { boundingbox: [-1.7, .5, 20, -.03], axis: true});
     *
     *   let runs = [
     *       [0.5, 1.0, 'brown'],
     *       [1.0, 2.0, 'red'],
     *       [2.0, 2.0, 'orange'],
     *       [3.0, 2.0, 'yellow'],
     *       [5.0, 1.0, 'green'],
     *       [9.0, 0.5, 'black'],
     *       [7.5, 1.0, 'purple'],
     *   ]
     *
     *   let labelY = .4
     *   runs.forEach((run,i) => {
     *       board.create('segment',[[7,labelY-(i/50)],[9,labelY-(i/50)]],{strokeColor:run[2]})
     *       board.create('text',[10,labelY-(i/50),`k=${run[0]}, &theta;=${run[1]}`])
     *
     *       let x = Array(50000).fill(0).map(() => JXG.Math.Statistics.randomGamma(run[0],run[1]))
     *       let res = JXG.Math.Statistics.histogram(x, { bins: 50, density: true, cumulative: false, range: [0, 20] });
     *       board.create('curve', [res[1], res[0]], { strokeColor: run[2]});
     *   })
     * }
     * </script><pre>
     *
     */ randomGamma: function(a, b, t) {
        var u, v, x, y, p, q;
        if (a <= 0) {
            return NaN;
        }
        b = b || 1;
        t = t || 0;
        if (a === 1) {
            return b * this.randomExponential(1) + t;
        }
        if (a < 1) {
            // Method by Ahrens
            // Knuth, TAOCP 2, Ex. 16, p 551
            p = Math.E / (a + Math.E);
            do {
                u = Math.random();
                do {
                    v = Math.random();
                }while (v === 0)
                if (u < p) {
                    x = Math.pow(v, 1 / a);
                    q = Math.exp(-x);
                } else {
                    x = 1 - Math.log(v);
                    q = Math.pow(x, a - 1);
                }
                u = Math.random();
            }while (u >= q)
            return b * x + t;
        }
        // a > 1
        // Knuth, TAOCP 2, p 129
        do {
            y = Math.tan(Math.PI * Math.random());
            x = Math.sqrt(2 * a - 1) * y + a - 1;
            if (x > 0) {
                v = Math.random();
            } else {
                continue;
            }
        }while (x <= 0.0 || v > (1 + y * y) * Math.exp((a - 1) * Math.log(x / (a - 1)) - Math.sqrt(2 * a - 1) * y))
        return b * x + t;
    },
    /**
     * Generate value of a random variable with beta distribution with shape parameters alpha and beta.
     * See <a href="https://en.wikipedia.org/wiki/Beta_distribution">https://en.wikipedia.org/wiki/Beta_distribution</a>.
     *
     * @param {Number} alpha <i>&gt; 0</i>
     * @param {Number} beta <i>&gt; 0</i>
     * @returns Number
     * @memberof JXG.Math.Statistics
     */ randomBeta: function(a, b) {
        // Knuth, TAOCP 2, p 129
        var x1, x2, x;
        if (a <= 0 || b <= 0) {
            return NaN;
        }
        x1 = this.randomGamma(a);
        x2 = this.randomGamma(b);
        x = x1 / (x1 + x2);
        return x;
    },
    /**
     * Generate value of a random variable with chi-square distribution with k degrees of freedom.
     * See <a href="https://en.wikipedia.org/wiki/Chi-squared_distribution">https://en.wikipedia.org/wiki/Chi-squared_distribution</a>.
     *
     * @param {Number} k <i>&gt; 0</i>
     * @returns Number
     * @memberof JXG.Math.Statistics
     */ randomChisquare: function(nu) {
        // Knuth, TAOCP 2, p 130
        if (nu <= 0) {
            return NaN;
        }
        return 2 * this.randomGamma(nu * 0.5);
    },
    /**
     * Generate value of a random variable with F-distribution with d<sub>1</sub> and d<sub>2</sub> degrees of freedom.
     * See <a href="https://en.wikipedia.org/wiki/F-distribution">https://en.wikipedia.org/wiki/F-distribution</a>.
     * @param {Number} d1 <i>&gt; 0</i>
     * @param {Number} d2 <i>&gt; 0</i>
     * @returns Number
     * @memberof JXG.Math.Statistics
     */ randomF: function(nu1, nu2) {
        // Knuth, TAOCP 2, p 130
        var y1, y2;
        if (nu1 <= 0 || nu2 <= 0) {
            return NaN;
        }
        y1 = this.randomChisquare(nu1);
        y2 = this.randomChisquare(nu2);
        return y1 * nu2 / (y2 * nu1);
    },
    /**
     * Generate value of a random variable with Students-t-distribution with &nu; degrees of freedom.
     * See <a href="https://en.wikipedia.org/wiki/Student%27s_t-distribution">https://en.wikipedia.org/wiki/Student%27s_t-distribution</a>.
     * @param {Number} nu <i>&gt; 0</i>
     * @returns Number
     * @memberof JXG.Math.Statistics
     */ randomT: function(nu) {
        // Knuth, TAOCP 2, p 130
        var y1, y2;
        if (nu <= 0) {
            return NaN;
        }
        y1 = this.randomNormal(0, 1);
        y2 = this.randomChisquare(nu);
        return y1 / Math.sqrt(y2 / nu);
    },
    /**
     * Generate values for a random variable in binomial distribution with parameters <i>n</i> and <i>p</i>.
     * See <a href="https://en.wikipedia.org/wiki/Binomial_distribution">https://en.wikipedia.org/wiki/Binomial_distribution</a>.
     * It uses algorithm BG from <a href="https://dl.acm.org/doi/pdf/10.1145/42372.42381">https://dl.acm.org/doi/pdf/10.1145/42372.42381</a>.
     *
     * @param {Number} n Number of trials (n >= 0)
     * @param {Number} p Probability (0 <= p <= 1)
     * @returns Number Integer value of a random variable in binomial distribution
     * @memberof JXG.Math.Statistics
     *
     * @example
     * let board = JXG.JSXGraph.initBoard('jxgbox',
     *     { boundingbox: [-1.7, .5, 30, -.03], axis: true });
     *
     * let runs = [
     *     [0.5, 20, 'blue'],
     *     [0.7, 20, 'green'],
     *     [0.5, 40, 'red'],
     * ];
     *
     * let labelY = .4;
     * runs.forEach((run, i) => {
     *     board.create('segment', [[7, labelY - (i / 50)], [9, labelY - (i / 50)]], { strokeColor: run[2] });
     *     board.create('text', [10, labelY - (i / 50), `p=${run[0]}, n=${run[1]}`]);
     *
     *     let x = Array(50000).fill(0).map(() => JXG.Math.Statistics.randomBinomial(run[1], run[0]));
     *     let res = JXG.Math.Statistics.histogram(x, {
     *         bins: 40,
     *         density: true,
     *         cumulative: false,
     *         range: [0, 40]
     *     });
     *     board.create('curve', [res[1], res[0]], { strokeColor: run[2] });
     * });
     *
     *
     * </pre><div id="JXGda56df4d-a5a5-4c87-9ffc-9bbc1b512302-3" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     * {
     *  let board = JXG.JSXGraph.initBoard('JXGda56df4d-a5a5-4c87-9ffc-9bbc1b512302-3',
     *       { boundingbox: [-1.7, .5, 30, -.03], axis: true});
     *
     *   let runs = [
     *       [0.5, 20, 'blue'],
     *       [0.7, 20, 'green'],
     *       [0.5, 40, 'red'],
     *   ]
     *
     *   let labelY = .4
     *   runs.forEach((run,i) => {
     *       board.create('segment',[[7,labelY-(i/50)],[9,labelY-(i/50)]],{strokeColor:run[2]})
     *       board.create('text',[10,labelY-(i/50),`p=${run[0]}, n=${run[1]}`])
     *
     *       let x = Array(50000).fill(0).map(() => JXG.Math.Statistics.randomBinomial(run[1],run[0]))
     *       let res = JXG.Math.Statistics.histogram(x, { bins: 40, density: true, cumulative: false, range: [0, 40] });
     *       board.create('curve', [res[1], res[0]], { strokeColor: run[2]});
     *   })
     * }
     * </script><pre>
     *
     */ randomBinomial: function(n, p) {
        var x, y, c, a, b, N1;
        if (p < 0 || p > 1 || n < 0) {
            return NaN;
        }
        // Edge cases
        if (p === 0) {
            return 0;
        }
        if (p === 1) {
            return n;
        }
        // Now, we can assume 0 < p < 1.
        // Fast path for common cases
        if (n === 0) {
            return 0;
        }
        if (n === 1) {
            return Math.random() < p ? 1 : 0;
        }
        // Exploit symmetry
        if (p > 0.5) {
            return n - this.randomBinomial(n, 1 - p);
        }
        // General case: n > 1, p <= 0.5
        if (n < 100) {
            // n small:
            // Algorithm BG (Devroye) from:
            // https://dl.acm.org/doi/pdf/10.1145/42372.42381
            // Time O(np) so suitable for np small only.
            x = -1;
            y = 0;
            c = Math.log(1 - p);
            if (c === 0) {
                return 0;
            }
            do {
                x += 1;
                y += Math.floor(Math.log(Math.random()) / c) + 1;
            }while (y < n)
        } else {
            // n large:
            // Knuth, TAOCP 2, p 131
            a = 1 + Math.floor(n * 0.5);
            b = n - a + 1;
            x = this.randomBeta(a, b);
            if (x >= p) {
                N1 = this.randomBinomial(a - 1, p / x);
                x = N1;
            } else {
                N1 = this.randomBinomial(b - 1, (p - x) / (1 - x));
                x = a + N1;
            }
        }
        return x;
    },
    /**
     * Generate values for a random variable in geometric distribution with probability <i>p</i>.
     * See <a href="https://en.wikipedia.org/wiki/Geometric_distribution">https://en.wikipedia.org/wiki/Geometric_distribution</a>.
     *
     * @param {Number} p (0 <= p <= 1)
     * @returns Number
     * @memberof JXG.Math.Statistics
     */ randomGeometric: function(p) {
        var u;
        if (p < 0 || p > 1) {
            return NaN;
        }
        // Knuth, TAOCP 2, p 131
        u = Math.random();
        return Math.ceil(Math.log(u) / Math.log(1 - p));
    },
    /**
     * Generate values for a random variable in Poisson distribution with mean <i>mu</i>.
     * See <a href="https://en.wikipedia.org/wiki/Poisson_distribution">https://en.wikipedia.org/wiki/Poisson_distribution</a>.
     *
     * @param {Number} mu (0 < mu)
     * @returns Number
     * @memberof JXG.Math.Statistics
     */ randomPoisson: function(mu) {
        var e = Math.exp(-mu), N, m = 0, u = 1, x, alpha = 7 / 8;
        if (mu <= 0) {
            return NaN;
        }
        // Knuth, TAOCP 2, p 132
        if (mu < 10) {
            do {
                u *= Math.random();
                m += 1;
            }while (u > e)
            N = m - 1;
        } else {
            m = Math.floor(alpha * mu);
            x = this.randomGamma(m);
            if (x < mu) {
                N = m + this.randomPoisson(mu - x);
            } else {
                N = this.randomBinomial(m - 1, mu / x);
            }
        }
        return N;
    },
    /**
     * Generate values for a random variable in Pareto distribution with
     * shape <i>gamma</i> and scale <i>k</i>.
     * See <a href="https://en.wikipedia.org/wiki/Pareto_distribution">https://en.wikipedia.org/wiki/Pareto_distribution</a>.
     * Method: use inverse transformation sampling.
     *
     * @param {Number} gamma shape (0 < gamma)
     * @param {Number} k scale (0 < k < x)
     * @returns Number
     * @memberof JXG.Math.Statistics
     */ randomPareto: function(gamma, k) {
        var u = Math.random();
        if (gamma <= 0 || k <= 0) {
            return NaN;
        }
        return k * Math.pow(1 - u, -1 / gamma);
    },
    /**
     * Generate values for a random variable in hypergeometric distribution.
     * Samples are drawn from a hypergeometric distribution with specified parameters, <i>good</i> (ways to make a good selection),
     * <i>bad</i> (ways to make a bad selection), and <i>samples</i> (number of items sampled, which is less than or equal to <i>good + bad</i>).
     * <p>
     * Naive implementation with runtime <i>O(samples)</i>.
     *
     * @param {Number} good ways to make a good selection
     * @param {Number} bad ways to make a bad selection
     * @param {Number} samples number of items sampled
     * @returns
     * @memberof JXG.Math.Statistics
     */ randomHypergeometric: function(good, bad, k) {
        var i, u, x = 0, // kk,
        // n = good + bad,
        d1 = good + bad - k, d2 = Math.min(good, bad), y = d2;
        if (good < 1 || bad < 1 || k > good + bad) {
            return NaN;
        }
        // Naive method
        // kk = Math.min(k, n - k);
        // for (i = 0; i < k; i ++) {
        //     u = Math.random();
        //     if (n * u <= good) {
        //         x += 1;
        //         if (x === good) {
        //             return x;
        //         }
        //         good -= 1;
        //     }
        //     n -= 1;
        // }
        // return x;
        // Implementation from
        // Monte Carlo by George S. Fishman
        // https://link.springer.com/book/10.1007/978-1-4757-2553-7
        // page 218
        //
        i = k;
        while(y * i > 0){
            u = Math.random();
            y -= Math.floor(u + y / (d1 + i));
            i -= 1;
        }
        x = d2 - y;
        if (good <= bad) {
            return x;
        } else {
            return k - x;
        }
    },
    /**
     * Compute the histogram of a dataset.
     * Optional parameters can be supplied through a JavaScript object
     * with the following default values:
     * <pre>
     * {
     *   bins: 10,          // Number of bins
     *   range: false,      // false or array. The lower and upper range of the bins.
     *                      // If not provided, range is simply [min(x), max(x)].
     *                      // Values outside the range are ignored.
     *   density: false,    // If true, normalize the counts by dividing by sum(counts)
     *   cumulative: false
     * }
     * </pre>
     * The function returns an array containing two arrays. The first array is of length bins+1
     * containing the start values of the bins. The last entry contains the end values of the last bin.
     * <p>
     * The second array contains the counts of each bin.
     * @param {Array} x
     * @param {Object} opt Optional parameters
     * @returns Array [bin, counts] Array bins contains start values of bins, array counts contains
     * the number of entries of x which are contained in each bin.
     * @memberof JXG.Math.Statistics
     *
     * @example
     *  let board = JXG.JSXGraph.initBoard('jxgbox',
     *       { boundingbox: [-1.7, .5, 20, -.03], axis: true});
     *  let board2 = JXG.JSXGraph.initBoard('jxgbox2',
     *       { boundingbox: [-1.6, 1.1, 20, -.06], axis: true});
     *
     *   let runs = [
     *       [0.5, 1.0, 'brown'],
     *       [1.0, 2.0, 'red'],
     *       [2.0, 2.0, 'orange'],
     *       [3.0, 2.0, 'yellow'],
     *       [5.0, 1.0, 'green'],
     *       [9.0, 0.5, 'black'],
     *       [7.5, 1.0, 'purple'],
     *   ]
     *
     *   let labelY = .4
     *   runs.forEach((run,i) => {
     *       board.create('segment',[[7,labelY-(i/50)],[9,labelY-(i/50)]],{strokeColor:run[2]})
     *       board.create('text',[10,labelY-(i/50),`k=${run[0]}, &theta;=${run[1]}`])
     *
     *       // density
     *       let x = Array(50000).fill(0).map(() => JXG.Math.Statistics.randomGamma(run[0],run[1]))
     *       let res = JXG.Math.Statistics.histogram(x, { bins: 50, density: true, cumulative: false, range: [0, 20] });
     *       board.create('curve', [res[1], res[0]], { strokeColor: run[2], strokeWidth:2});
     *
     *       // cumulative density
     *       res = JXG.Math.Statistics.histogram(x, { bins: 50, density: true, cumulative: true, range: [0, 20] });
     *       res[0].unshift(0)  // add zero to front so cumulative starts at zero
     *       res[1].unshift(0)
     *       board2.create('curve', [res[1], res[0]], { strokeColor: run[2], strokeWidth:2 });
     *   })
     *
     *
     * </pre><div id="JXGda56df4d-a5a5-4c87-9ffc-9bbc1b512302" class="jxgbox" style="width: 300px; height: 300px; float:left;"></div>
     * <div style='float:left;'>&nbsp;&nbsp;</div>
     * <div id="JXGda56df4d-a5a5-4c87-9ffc-9bbc1b512302-2" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     * {
     *  let board = JXG.JSXGraph.initBoard('JXGda56df4d-a5a5-4c87-9ffc-9bbc1b512302',
     *       { boundingbox: [-1.7, .5, 20, -.03], axis: true});
     *  let board2 = JXG.JSXGraph.initBoard('JXGda56df4d-a5a5-4c87-9ffc-9bbc1b512302-2',
     *       { boundingbox: [-1.6, 1.1, 20, -.06], axis: true});
     *
     *   let runs = [
     *       [0.5, 1.0, 'brown'],
     *       [1.0, 2.0, 'red'],
     *       [2.0, 2.0, 'orange'],
     *       [3.0, 2.0, 'yellow'],
     *       [5.0, 1.0, 'green'],
     *       [9.0, 0.5, 'black'],
     *       [7.5, 1.0, 'purple'],
     *   ]
     *
     *   let labelY = .4
     *   runs.forEach((run,i) => {
     *       board.create('segment',[[7,labelY-(i/50)],[9,labelY-(i/50)]],{strokeColor:run[2]})
     *       board.create('text',[10,labelY-(i/50),`k=${run[0]}, &theta;=${run[1]}`])
     *
     *       let x = Array(50000).fill(0).map(() => JXG.Math.Statistics.randomGamma(run[0],run[1]))
     *       let res = JXG.Math.Statistics.histogram(x, { bins: 50, density: true, cumulative: false, range: [0, 20] });
     *       board.create('curve', [res[1], res[0]], { strokeColor: run[2], strokeWidth:2});
     *
     *       // cumulative density
     *       res = JXG.Math.Statistics.histogram(x, { bins: 50, density: true, cumulative: true, range: [0, 20] });
     *       res[0].unshift(0)  // add zero to front so cumulative starts at zero
     *       res[1].unshift(0)
     *       board2.create('curve', [res[1], res[0]], { strokeColor: run[2], strokeWidth:2 });
     *   })
     * }
     * </script><pre>
     *
     */ histogram: function(x, opt) {
        var i, le, k, mi, ma, num_bins, delta, range, s, counts = [], bins = [], no_bin = 0; // Count of long tail elements not in histogram range
        // Evaluate number of bins
        num_bins = opt.bins || 10;
        // Evaluate range
        range = opt.range || false;
        if (range === false) {
            mi = Math.min.apply(null, x);
            ma = Math.max.apply(null, x);
        } else {
            mi = range[0];
            ma = range[1];
        }
        // Set uniform delta
        if (num_bins > 0) {
            delta = (ma - mi) / (num_bins - 1);
        } else {
            delta = 0;
        }
        // Set the bins and init the counts array
        for(i = 0; i < num_bins; i++){
            counts.push(0);
            bins.push(mi + i * delta);
        }
        // bins.push(ma);
        // Determine the counts
        le = x.length;
        for(i = 0; i < le; i++){
            k = Math.floor((x[i] - mi) / delta);
            if (k >= 0 && k < num_bins) {
                counts[k] += 1;
            } else {
                no_bin += 1;
            }
        }
        // Normalize if density===true
        if (opt.density) {
            s = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Math.Statistics.sum(counts) + no_bin; // Normalize including long tail
            for(i = 0; i < num_bins; i++){
                counts[i] /= s * delta;
            // counts[i] /= s;
            }
        }
        // Cumulative counts
        if (opt.cumulative) {
            if (opt.density) {
                for(i = 0; i < num_bins; i++){
                    counts[i] *= delta; // Normalize
                }
            }
            for(i = 1; i < num_bins; i++){
                counts[i] += counts[i - 1];
            }
        }
        return [
            counts,
            bins
        ];
    }
};
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Statistics;
}),
"[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/numerics.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */ /*global JXG: true, define: true*/ /*jslint nomen: true, plusplus: true*/ /*eslint no-loss-of-precision: off */ /**
 * @fileoverview In this file the namespace Math.Numerics is defined, which holds numerical
 * algorithms for solving linear equations etc.
 */ __turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/jxg.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/utils/type.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$env$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/utils/env.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/math.js [app-client] (ecmascript)");
;
;
;
;
// Predefined butcher tableaus for the common Runge-Kutta method (fourth order), Heun method (second order), and Euler method (first order).
var predefinedButcher = {
    rk4: {
        s: 4,
        A: [
            [
                0,
                0,
                0,
                0
            ],
            [
                0.5,
                0,
                0,
                0
            ],
            [
                0,
                0.5,
                0,
                0
            ],
            [
                0,
                0,
                1,
                0
            ]
        ],
        b: [
            1.0 / 6.0,
            1.0 / 3.0,
            1.0 / 3.0,
            1.0 / 6.0
        ],
        c: [
            0,
            0.5,
            0.5,
            1
        ]
    },
    heun: {
        s: 2,
        A: [
            [
                0,
                0
            ],
            [
                1,
                0
            ]
        ],
        b: [
            0.5,
            0.5
        ],
        c: [
            0,
            1
        ]
    },
    euler: {
        s: 1,
        A: [
            [
                0
            ]
        ],
        b: [
            1
        ],
        c: [
            0
        ]
    }
};
/**
 * The JXG.Math.Numerics namespace holds numerical algorithms, constants, and variables.
 * @name JXG.Math.Numerics
 * @exports Mat.Numerics as JXG.Math.Numerics
 * @namespace
 */ __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Numerics = {
    //JXG.extend(Mat.Numerics, /** @lends JXG.Math.Numerics */ {
    /**
     * Solves a system of linear equations given by A and b using the Gauss-Jordan-elimination.
     * The algorithm runs in-place. I.e. the entries of A and b are changed.
     * @param {Array} A Square matrix represented by an array of rows, containing the coefficients of the lineare equation system.
     * @param {Array} b A vector containing the linear equation system's right hand side.
     * @throws {Error} If a non-square-matrix is given or if b has not the right length or A's rank is not full.
     * @returns {Array} A vector that solves the linear equation system.
     * @memberof JXG.Math.Numerics
     */ Gauss: function(A, b) {
        var i, j, k, // copy the matrix to prevent changes in the original
        Acopy, // solution vector, to prevent changing b
        x, eps = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps, // number of columns of A
        n = A.length > 0 ? A[0].length : 0;
        if (n !== b.length || n !== A.length) {
            throw new Error("JXG.Math.Numerics.Gauss: Dimensions don't match. A must be a square matrix and b must be of the same length as A.");
        }
        // initialize solution vector
        Acopy = [];
        x = b.slice(0, n);
        for(i = 0; i < n; i++){
            Acopy[i] = A[i].slice(0, n);
        }
        // Gauss-Jordan-elimination
        for(j = 0; j < n; j++){
            for(i = n - 1; i > j; i--){
                // Is the element which is to eliminate greater than zero?
                if (Math.abs(Acopy[i][j]) > eps) {
                    // Equals pivot element zero?
                    if (Math.abs(Acopy[j][j]) < eps) {
                        // At least numerically, so we have to exchange the rows
                        __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].swap(Acopy, i, j);
                        __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].swap(x, i, j);
                    } else {
                        // Saves the L matrix of the LR-decomposition. unnecessary.
                        Acopy[i][j] /= Acopy[j][j];
                        // Transform right-hand-side b
                        x[i] -= Acopy[i][j] * x[j];
                        // subtract the multiple of A[i][j] / A[j][j] of the j-th row from the i-th.
                        for(k = j + 1; k < n; k++){
                            Acopy[i][k] -= Acopy[i][j] * Acopy[j][k];
                        }
                    }
                }
            }
            // The absolute values of all coefficients below the j-th row in the j-th column are smaller than JXG.Math.eps.
            if (Math.abs(Acopy[j][j]) < eps) {
                throw new Error("JXG.Math.Numerics.Gauss(): The given matrix seems to be singular.");
            }
        }
        this.backwardSolve(Acopy, x, true);
        return x;
    },
    /**
     * Solves a system of linear equations given by the right triangular matrix R and vector b.
     * @param {Array} R Right triangular matrix represented by an array of rows. All entries a_(i,j) with i &lt; j are ignored.
     * @param {Array} b Right hand side of the linear equation system.
     * @param {Boolean} [canModify=false] If true, the right hand side vector is allowed to be changed by this method.
     * @returns {Array} An array representing a vector that solves the system of linear equations.
     * @memberof JXG.Math.Numerics
     */ backwardSolve: function(R, b, canModify) {
        var x, m, n, i, j;
        if (canModify) {
            x = b;
        } else {
            x = b.slice(0, b.length);
        }
        // m: number of rows of R
        // n: number of columns of R
        m = R.length;
        n = R.length > 0 ? R[0].length : 0;
        for(i = m - 1; i >= 0; i--){
            for(j = n - 1; j > i; j--){
                x[i] -= R[i][j] * x[j];
            }
            x[i] /= R[i][i];
        }
        return x;
    },
    /**
     *  Gauss-Bareiss algorithm to compute the
     *  determinant of matrix without fractions.
     *  See Henri Cohen, "A Course in Computational
     *  Algebraic Number Theory (Graduate texts
     *  in mathematics; 138)", Springer-Verlag,
     *  ISBN 3-540-55640-0 / 0-387-55640-0
     *  Third, Corrected Printing 1996
     *  "Algorithm 2.2.6", pg. 52-53
     *
     * @param {Array} mat Matrix
     * @returns Number
     * @private
     * @memberof JXG.Math.Numerics
     */ gaussBareiss: function(mat) {
        var k, c, s, i, j, p, n, M, t, eps = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps;
        n = mat.length;
        if (n <= 0) {
            return 0;
        }
        if (mat[0].length < n) {
            n = mat[0].length;
        }
        // Copy the input matrix to M
        M = [];
        for(i = 0; i < n; i++){
            M[i] = mat[i].slice(0, n);
        }
        c = 1;
        s = 1;
        for(k = 0; k < n - 1; k++){
            p = M[k][k];
            // Pivot step
            if (Math.abs(p) < eps) {
                for(i = k + 1; i < n; i++){
                    if (Math.abs(M[i][k]) >= eps) {
                        break;
                    }
                }
                // No nonzero entry found in column k -> det(M) = 0
                if (i === n) {
                    return 0.0;
                }
                // swap row i and k partially
                for(j = k; j < n; j++){
                    t = M[i][j];
                    M[i][j] = M[k][j];
                    M[k][j] = t;
                }
                s = -s;
                p = M[k][k];
            }
            // Main step
            for(i = k + 1; i < n; i++){
                for(j = k + 1; j < n; j++){
                    t = p * M[i][j] - M[i][k] * M[k][j];
                    M[i][j] = t / c;
                }
            }
            c = p;
        }
        return s * M[n - 1][n - 1];
    },
    /**
     * Computes the determinant of a square nxn matrix with the
     * Gauss-Bareiss algorithm.
     * @param {Array} mat Matrix.
     * @returns {Number} The determinant pf the matrix mat.
     *                   The empty matrix returns 0.
     * @memberof JXG.Math.Numerics
     */ det: function(mat) {
        var n = mat.length;
        if (n === 2 && mat[0].length === 2) {
            return mat[0][0] * mat[1][1] - mat[1][0] * mat[0][1];
        }
        return this.gaussBareiss(mat);
    },
    /**
     * Compute the Eigenvalues and Eigenvectors of a symmetric 3x3 matrix with the Jacobi method
     * Adaption of a FORTRAN program by Ed Wilson, Dec. 25, 1990
     * @param {Array} Ain A symmetric 3x3 matrix.
     * @returns {Array} [A,V] the matrices A and V. The diagonal of A contains the Eigenvalues, V contains the Eigenvectors.
     * @memberof JXG.Math.Numerics
     */ Jacobi: function(Ain) {
        var i, j, k, aa, si, co, tt, ssum, amax, eps = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps * __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps, sum = 0.0, n = Ain.length, V = [
            [
                0,
                0,
                0
            ],
            [
                0,
                0,
                0
            ],
            [
                0,
                0,
                0
            ]
        ], A = [
            [
                0,
                0,
                0
            ],
            [
                0,
                0,
                0
            ],
            [
                0,
                0,
                0
            ]
        ], nloops = 0;
        // Initialization. Set initial Eigenvectors.
        for(i = 0; i < n; i++){
            for(j = 0; j < n; j++){
                V[i][j] = 0.0;
                A[i][j] = Ain[i][j];
                sum += Math.abs(A[i][j]);
            }
            V[i][i] = 1.0;
        }
        // Trivial problems
        if (n === 1) {
            return [
                A,
                V
            ];
        }
        if (sum <= 0.0) {
            return [
                A,
                V
            ];
        }
        sum /= n * n;
        // Reduce matrix to diagonal
        do {
            ssum = 0.0;
            amax = 0.0;
            for(j = 1; j < n; j++){
                for(i = 0; i < j; i++){
                    // Check if A[i][j] is to be reduced
                    aa = Math.abs(A[i][j]);
                    if (aa > amax) {
                        amax = aa;
                    }
                    ssum += aa;
                    if (aa >= eps) {
                        // calculate rotation angle
                        aa = Math.atan2(2.0 * A[i][j], A[i][i] - A[j][j]) * 0.5;
                        si = Math.sin(aa);
                        co = Math.cos(aa);
                        // Modify 'i' and 'j' columns
                        for(k = 0; k < n; k++){
                            tt = A[k][i];
                            A[k][i] = co * tt + si * A[k][j];
                            A[k][j] = -si * tt + co * A[k][j];
                            tt = V[k][i];
                            V[k][i] = co * tt + si * V[k][j];
                            V[k][j] = -si * tt + co * V[k][j];
                        }
                        // Modify diagonal terms
                        A[i][i] = co * A[i][i] + si * A[j][i];
                        A[j][j] = -si * A[i][j] + co * A[j][j];
                        A[i][j] = 0.0;
                        // Make 'A' matrix symmetrical
                        for(k = 0; k < n; k++){
                            A[i][k] = A[k][i];
                            A[j][k] = A[k][j];
                        }
                    // A[i][j] made zero by rotation
                    }
                }
            }
            nloops += 1;
        }while (Math.abs(ssum) / sum > eps && nloops < 2000)
        return [
            A,
            V
        ];
    },
    /**
     * Calculates the integral of function f over interval using Newton-Cotes-algorithm.
     * @param {Array} interval The integration interval, e.g. [0, 3].
     * @param {function} f A function which takes one argument of type number and returns a number.
     * @param {Object} [config] The algorithm setup. Accepted properties are number_of_nodes of type number and integration_type
     * with value being either 'trapez', 'simpson', or 'milne'.
     * @param {Number} [config.number_of_nodes=28]
     * @param {String} [config.integration_type='milne'] Possible values are 'milne', 'simpson', 'trapez'
     * @returns {Number} Integral value of f over interval
     * @throws {Error} If config.number_of_nodes doesn't match config.integration_type an exception is thrown. If you want to use
     * simpson rule respectively milne rule config.number_of_nodes must be dividable by 2 respectively 4.
     * @example
     * function f(x) {
     *   return x*x;
     * }
     *
     * // calculates integral of <tt>f</tt> from 0 to 2.
     * var area1 = JXG.Math.Numerics.NewtonCotes([0, 2], f);
     *
     * // the same with an anonymous function
     * var area2 = JXG.Math.Numerics.NewtonCotes([0, 2], function (x) { return x*x; });
     *
     * // use trapez rule with 16 nodes
     * var area3 = JXG.Math.Numerics.NewtonCotes([0, 2], f,
     *                                   {number_of_nodes: 16, integration_type: 'trapez'});
     * @memberof JXG.Math.Numerics
     */ NewtonCotes: function(interval, f, config) {
        var evaluation_point, i, number_of_intervals, integral_value = 0.0, number_of_nodes = config && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(config.number_of_nodes) ? config.number_of_nodes : 28, available_types = {
            trapez: true,
            simpson: true,
            milne: true
        }, integration_type = config && config.integration_type && available_types.hasOwnProperty(config.integration_type) && available_types[config.integration_type] ? config.integration_type : "milne", step_size = (interval[1] - interval[0]) / number_of_nodes;
        switch(integration_type){
            case "trapez":
                integral_value = (f(interval[0]) + f(interval[1])) * 0.5;
                evaluation_point = interval[0];
                for(i = 0; i < number_of_nodes - 1; i++){
                    evaluation_point += step_size;
                    integral_value += f(evaluation_point);
                }
                integral_value *= step_size;
                break;
            case "simpson":
                if (number_of_nodes % 2 > 0) {
                    throw new Error("JSXGraph:  INT_SIMPSON requires config.number_of_nodes dividable by 2.");
                }
                number_of_intervals = number_of_nodes / 2.0;
                integral_value = f(interval[0]) + f(interval[1]);
                evaluation_point = interval[0];
                for(i = 0; i < number_of_intervals - 1; i++){
                    evaluation_point += 2.0 * step_size;
                    integral_value += 2.0 * f(evaluation_point);
                }
                evaluation_point = interval[0] - step_size;
                for(i = 0; i < number_of_intervals; i++){
                    evaluation_point += 2.0 * step_size;
                    integral_value += 4.0 * f(evaluation_point);
                }
                integral_value *= step_size / 3.0;
                break;
            default:
                if (number_of_nodes % 4 > 0) {
                    throw new Error("JSXGraph: Error in INT_MILNE: config.number_of_nodes must be a multiple of 4");
                }
                number_of_intervals = number_of_nodes * 0.25;
                integral_value = 7.0 * (f(interval[0]) + f(interval[1]));
                evaluation_point = interval[0];
                for(i = 0; i < number_of_intervals - 1; i++){
                    evaluation_point += 4.0 * step_size;
                    integral_value += 14.0 * f(evaluation_point);
                }
                evaluation_point = interval[0] - 3.0 * step_size;
                for(i = 0; i < number_of_intervals; i++){
                    evaluation_point += 4.0 * step_size;
                    integral_value += 32.0 * (f(evaluation_point) + f(evaluation_point + 2 * step_size));
                }
                evaluation_point = interval[0] - 2.0 * step_size;
                for(i = 0; i < number_of_intervals; i++){
                    evaluation_point += 4.0 * step_size;
                    integral_value += 12.0 * f(evaluation_point);
                }
                integral_value *= 2.0 * step_size / 45.0;
        }
        return integral_value;
    },
    /**
     * Calculates the integral of function f over interval using Romberg iteration.
     * @param {Array} interval The integration interval, e.g. [0, 3].
     * @param {function} f A function which takes one argument of type number and returns a number.
     * @param {Object} [config] The algorithm setup. Accepted properties are max_iterations of type number and precision eps.
     * @param {Number} [config.max_iterations=20]
     * @param {Number} [config.eps=0.0000001]
     * @returns {Number} Integral value of f over interval
     * @example
     * function f(x) {
     *   return x*x;
     * }
     *
     * // calculates integral of <tt>f</tt> from 0 to 2.
     * var area1 = JXG.Math.Numerics.Romberg([0, 2], f);
     *
     * // the same with an anonymous function
     * var area2 = JXG.Math.Numerics.Romberg([0, 2], function (x) { return x*x; });
     *
     * // use trapez rule with maximum of 16 iterations or stop if the precision 0.0001 has been reached.
     * var area3 = JXG.Math.Numerics.Romberg([0, 2], f,
     *                                   {max_iterations: 16, eps: 0.0001});
     * @memberof JXG.Math.Numerics
     */ Romberg: function(interval, f, config) {
        var a, b, h, s, n, k, i, q, p = [], integral = 0.0, last = Infinity, m = config && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(config.max_iterations) ? config.max_iterations : 20, eps = config && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(config.eps) ? config.eps : config.eps || 0.0000001;
        a = interval[0];
        b = interval[1];
        h = b - a;
        n = 1;
        p[0] = 0.5 * h * (f(a) + f(b));
        for(k = 0; k < m; ++k){
            s = 0;
            h *= 0.5;
            n *= 2;
            q = 1;
            for(i = 1; i < n; i += 2){
                s += f(a + i * h);
            }
            p[k + 1] = 0.5 * p[k] + s * h;
            integral = p[k + 1];
            for(i = k - 1; i >= 0; --i){
                q *= 4;
                p[i] = p[i + 1] + (p[i + 1] - p[i]) / (q - 1.0);
                integral = p[i];
            }
            if (Math.abs(integral - last) < eps * Math.abs(integral)) {
                break;
            }
            last = integral;
        }
        return integral;
    },
    /**
     * Calculates the integral of function f over interval using Gauss-Legendre quadrature.
     * @param {Array} interval The integration interval, e.g. [0, 3].
     * @param {function} f A function which takes one argument of type number and returns a number.
     * @param {Object} [config] The algorithm setup. Accepted property is the order n of type number. n is allowed to take
     * values between 2 and 18, default value is 12.
     * @param {Number} [config.n=16]
     * @returns {Number} Integral value of f over interval
     * @example
     * function f(x) {
     *   return x*x;
     * }
     *
     * // calculates integral of <tt>f</tt> from 0 to 2.
     * var area1 = JXG.Math.Numerics.GaussLegendre([0, 2], f);
     *
     * // the same with an anonymous function
     * var area2 = JXG.Math.Numerics.GaussLegendre([0, 2], function (x) { return x*x; });
     *
     * // use 16 point Gauss-Legendre rule.
     * var area3 = JXG.Math.Numerics.GaussLegendre([0, 2], f,
     *                                   {n: 16});
     * @memberof JXG.Math.Numerics
     */ GaussLegendre: function(interval, f, config) {
        var a, b, i, m, xp, xm, result = 0.0, table_xi = [], table_w = [], xi, w, n = config && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(config.n) ? config.n : 12;
        if (n > 18) {
            n = 18;
        }
        /* n = 2 */ table_xi[2] = [
            0.5773502691896257645091488
        ];
        table_w[2] = [
            1.0
        ];
        /* n = 4 */ table_xi[4] = [
            0.3399810435848562648026658,
            0.8611363115940525752239465
        ];
        table_w[4] = [
            0.6521451548625461426269361,
            0.3478548451374538573730639
        ];
        /* n = 6 */ table_xi[6] = [
            0.2386191860831969086305017,
            0.6612093864662645136613996,
            0.9324695142031520278123016
        ];
        table_w[6] = [
            0.4679139345726910473898703,
            0.3607615730481386075698335,
            0.1713244923791703450402961
        ];
        /* n = 8 */ table_xi[8] = [
            0.1834346424956498049394761,
            0.525532409916328985817739,
            0.7966664774136267395915539,
            0.9602898564975362316835609
        ];
        table_w[8] = [
            0.3626837833783619829651504,
            0.3137066458778872873379622,
            0.222381034453374470544356,
            0.1012285362903762591525314
        ];
        /* n = 10 */ table_xi[10] = [
            0.148874338981631210884826,
            0.4333953941292471907992659,
            0.6794095682990244062343274,
            0.8650633666889845107320967,
            0.973906528517171720077964
        ];
        table_w[10] = [
            0.295524224714752870173893,
            0.2692667193099963550912269,
            0.2190863625159820439955349,
            0.1494513491505805931457763,
            0.0666713443086881375935688
        ];
        /* n = 12 */ table_xi[12] = [
            0.1252334085114689154724414,
            0.3678314989981801937526915,
            0.5873179542866174472967024,
            0.7699026741943046870368938,
            0.9041172563704748566784659,
            0.9815606342467192506905491
        ];
        table_w[12] = [
            0.2491470458134027850005624,
            0.2334925365383548087608499,
            0.2031674267230659217490645,
            0.1600783285433462263346525,
            0.1069393259953184309602547,
            0.047175336386511827194616
        ];
        /* n = 14 */ table_xi[14] = [
            0.1080549487073436620662447,
            0.3191123689278897604356718,
            0.5152486363581540919652907,
            0.6872929048116854701480198,
            0.8272013150697649931897947,
            0.9284348836635735173363911,
            0.9862838086968123388415973
        ];
        table_w[14] = [
            0.2152638534631577901958764,
            0.2051984637212956039659241,
            0.1855383974779378137417166,
            0.1572031671581935345696019,
            0.1215185706879031846894148,
            0.0801580871597602098056333,
            0.0351194603317518630318329
        ];
        /* n = 16 */ table_xi[16] = [
            0.0950125098376374401853193,
            0.2816035507792589132304605,
            0.4580167776572273863424194,
            0.6178762444026437484466718,
            0.7554044083550030338951012,
            0.8656312023878317438804679,
            0.9445750230732325760779884,
            0.9894009349916499325961542
        ];
        table_w[16] = [
            0.1894506104550684962853967,
            0.1826034150449235888667637,
            0.1691565193950025381893121,
            0.1495959888165767320815017,
            0.1246289712555338720524763,
            0.0951585116824927848099251,
            0.0622535239386478928628438,
            0.0271524594117540948517806
        ];
        /* n = 18 */ table_xi[18] = [
            0.0847750130417353012422619,
            0.2518862256915055095889729,
            0.4117511614628426460359318,
            0.5597708310739475346078715,
            0.6916870430603532078748911,
            0.8037049589725231156824175,
            0.8926024664975557392060606,
            0.9558239495713977551811959,
            0.991565168420930946730016
        ];
        table_w[18] = [
            0.1691423829631435918406565,
            0.1642764837458327229860538,
            0.154684675126265244925418,
            0.1406429146706506512047313,
            0.1225552067114784601845191,
            0.100942044106287165562814,
            0.0764257302548890565291297,
            0.0497145488949697964533349,
            0.0216160135264833103133427
        ];
        /* n = 3 */ table_xi[3] = [
            0.0,
            0.7745966692414833770358531
        ];
        table_w[3] = [
            0.8888888888888888888888889,
            0.5555555555555555555555556
        ];
        /* n = 5 */ table_xi[5] = [
            0.0,
            0.5384693101056830910363144,
            0.9061798459386639927976269
        ];
        table_w[5] = [
            0.5688888888888888888888889,
            0.4786286704993664680412915,
            0.236926885056189087514264
        ];
        /* n = 7 */ table_xi[7] = [
            0.0,
            0.4058451513773971669066064,
            0.7415311855993944398638648,
            0.9491079123427585245261897
        ];
        table_w[7] = [
            0.417959183673469387755102,
            0.3818300505051189449503698,
            0.2797053914892766679014678,
            0.1294849661688696932706114
        ];
        /* n = 9 */ table_xi[9] = [
            0.0,
            0.324253423403808929038538,
            0.613371432700590397308702,
            0.8360311073266357942994298,
            0.9681602395076260898355762
        ];
        table_w[9] = [
            0.3302393550012597631645251,
            0.3123470770400028400686304,
            0.2606106964029354623187429,
            0.180648160694857404058472,
            0.0812743883615744119718922
        ];
        /* n = 11 */ table_xi[11] = [
            0.0,
            0.269543155952344972331532,
            0.5190961292068118159257257,
            0.7301520055740493240934163,
            0.8870625997680952990751578,
            0.978228658146056992803938
        ];
        table_w[11] = [
            0.2729250867779006307144835,
            0.2628045445102466621806889,
            0.2331937645919904799185237,
            0.1862902109277342514260976,
            0.1255803694649046246346943,
            0.0556685671161736664827537
        ];
        /* n = 13 */ table_xi[13] = [
            0.0,
            0.2304583159551347940655281,
            0.4484927510364468528779129,
            0.6423493394403402206439846,
            0.8015780907333099127942065,
            0.9175983992229779652065478,
            0.9841830547185881494728294
        ];
        table_w[13] = [
            0.2325515532308739101945895,
            0.2262831802628972384120902,
            0.2078160475368885023125232,
            0.1781459807619457382800467,
            0.1388735102197872384636018,
            0.0921214998377284479144218,
            0.0404840047653158795200216
        ];
        /* n = 15 */ table_xi[15] = [
            0.0,
            0.2011940939974345223006283,
            0.3941513470775633698972074,
            0.5709721726085388475372267,
            0.7244177313601700474161861,
            0.8482065834104272162006483,
            0.9372733924007059043077589,
            0.9879925180204854284895657
        ];
        table_w[15] = [
            0.2025782419255612728806202,
            0.1984314853271115764561183,
            0.1861610000155622110268006,
            0.1662692058169939335532009,
            0.1395706779261543144478048,
            0.1071592204671719350118695,
            0.0703660474881081247092674,
            0.0307532419961172683546284
        ];
        /* n = 17 */ table_xi[17] = [
            0.0,
            0.1784841814958478558506775,
            0.3512317634538763152971855,
            0.5126905370864769678862466,
            0.6576711592166907658503022,
            0.7815140038968014069252301,
            0.8802391537269859021229557,
            0.950675521768767761222717,
            0.990575475314417335675434
        ];
        table_w[17] = [
            0.1794464703562065254582656,
            0.176562705366992646325271,
            0.1680041021564500445099707,
            0.1540457610768102880814316,
            0.13513636846852547328632,
            0.1118838471934039710947884,
            0.0850361483171791808835354,
            0.0554595293739872011294402,
            0.02414830286854793196011
        ];
        a = interval[0];
        b = interval[1];
        //m = Math.ceil(n * 0.5);
        m = n + 1 >> 1;
        xi = table_xi[n];
        w = table_w[n];
        xm = 0.5 * (b - a);
        xp = 0.5 * (b + a);
        if (n & 1 === 1) {
            // n odd
            result = w[0] * f(xp);
            for(i = 1; i < m; ++i){
                result += w[i] * (f(xp + xm * xi[i]) + f(xp - xm * xi[i]));
            }
        } else {
            // n even
            result = 0.0;
            for(i = 0; i < m; ++i){
                result += w[i] * (f(xp + xm * xi[i]) + f(xp - xm * xi[i]));
            }
        }
        return xm * result;
    },
    /**
     * Scale error in Gauss Kronrod quadrature.
     * Internal method used in {@link JXG.Math.Numerics._gaussKronrod}.
     * @private
     */ _rescale_error: function(err, result_abs, result_asc) {
        var scale, min_err, DBL_MIN = 2.2250738585072014e-308, DBL_EPS = 2.2204460492503131e-16;
        err = Math.abs(err);
        if (result_asc !== 0 && err !== 0) {
            scale = Math.pow(200 * err / result_asc, 1.5);
            if (scale < 1.0) {
                err = result_asc * scale;
            } else {
                err = result_asc;
            }
        }
        if (result_abs > DBL_MIN / (50 * DBL_EPS)) {
            min_err = 50 * DBL_EPS * result_abs;
            if (min_err > err) {
                err = min_err;
            }
        }
        return err;
    },
    /**
     * Generic Gauss-Kronrod quadrature algorithm.
     * Internal method used in {@link JXG.Math.Numerics.GaussKronrod15},
     * {@link JXG.Math.Numerics.GaussKronrod21},
     * {@link JXG.Math.Numerics.GaussKronrod31}.
     * Taken from QUADPACK.
     *
     * @param {Array} interval The integration interval, e.g. [0, 3].
     * @param {function} f A function which takes one argument of type number and returns a number.
     * @param {Number} n order of approximation. Actually, n is the length of the array xgk. For example, for the 15-point Kronrod rule, n is equal to 8.
     * @param {Array} xgk Kronrod quadrature abscissae
     * @param {Array} wg Weights of the Gauss rule
     * @param {Array} wgk Weights of the Kronrod rule
     * @param {Object} resultObj Object returning resultObj.abserr, resultObj.resabs, resultObj.resasc.
     * See the library QUADPACK for an explanation.
     *
     * @returns {Number} Integral value of f over interval
     *
     * @private
     */ _gaussKronrod: function(interval, f, n, xgk, wg, wgk, resultObj) {
        var a = interval[0], b = interval[1], up, result, center = 0.5 * (a + b), half_length = 0.5 * (b - a), abs_half_length = Math.abs(half_length), f_center = f(center), result_gauss = 0.0, result_kronrod = f_center * wgk[n - 1], result_abs = Math.abs(result_kronrod), result_asc = 0.0, mean = 0.0, err = 0.0, j, jtw, jtwm1, abscissa, fval1, fval2, fsum, fv1 = [], fv2 = [];
        if (n % 2 === 0) {
            result_gauss = f_center * wg[n / 2 - 1];
        }
        up = Math.floor((n - 1) / 2);
        for(j = 0; j < up; j++){
            jtw = j * 2 + 1; // in original fortran j=1,2,3 jtw=2,4,6
            abscissa = half_length * xgk[jtw];
            fval1 = f(center - abscissa);
            fval2 = f(center + abscissa);
            fsum = fval1 + fval2;
            fv1[jtw] = fval1;
            fv2[jtw] = fval2;
            result_gauss += wg[j] * fsum;
            result_kronrod += wgk[jtw] * fsum;
            result_abs += wgk[jtw] * (Math.abs(fval1) + Math.abs(fval2));
        }
        up = Math.floor(n / 2);
        for(j = 0; j < up; j++){
            jtwm1 = j * 2;
            abscissa = half_length * xgk[jtwm1];
            fval1 = f(center - abscissa);
            fval2 = f(center + abscissa);
            fv1[jtwm1] = fval1;
            fv2[jtwm1] = fval2;
            result_kronrod += wgk[jtwm1] * (fval1 + fval2);
            result_abs += wgk[jtwm1] * (Math.abs(fval1) + Math.abs(fval2));
        }
        mean = result_kronrod * 0.5;
        result_asc = wgk[n - 1] * Math.abs(f_center - mean);
        for(j = 0; j < n - 1; j++){
            result_asc += wgk[j] * (Math.abs(fv1[j] - mean) + Math.abs(fv2[j] - mean));
        }
        // scale by the width of the integration region
        err = (result_kronrod - result_gauss) * half_length;
        result_kronrod *= half_length;
        result_abs *= abs_half_length;
        result_asc *= abs_half_length;
        result = result_kronrod;
        resultObj.abserr = this._rescale_error(err, result_abs, result_asc);
        resultObj.resabs = result_abs;
        resultObj.resasc = result_asc;
        return result;
    },
    /**
     * 15-point Gauss-Kronrod quadrature algorithm, see the library QUADPACK
     * @param {Array} interval The integration interval, e.g. [0, 3].
     * @param {function} f A function which takes one argument of type number and returns a number.
     * @param {Object} resultObj Object returning resultObj.abserr, resultObj.resabs, resultObj.resasc. See the library
     *  QUADPACK for an explanation.
     *
     * @returns {Number} Integral value of f over interval
     *
     * @memberof JXG.Math.Numerics
     */ GaussKronrod15: function(interval, f, resultObj) {
        /* Gauss quadrature weights and kronrod quadrature abscissae and
                weights as evaluated with 80 decimal digit arithmetic by
                L. W. Fullerton, Bell Labs, Nov. 1981. */ var xgk = /* abscissae of the 15-point kronrod rule */ [
            0.991455371120812639206854697526329,
            0.949107912342758524526189684047851,
            0.864864423359769072789712788640926,
            0.741531185599394439863864773280788,
            0.58608723546769113029414483825873,
            0.405845151377397166906606412076961,
            0.207784955007898467600689403773245,
            0.0
        ], /* xgk[1], xgk[3], ... abscissae of the 7-point gauss rule.
                xgk[0], xgk[2], ... abscissae to optimally extend the 7-point gauss rule */ wg = /* weights of the 7-point gauss rule */ [
            0.129484966168869693270611432679082,
            0.27970539148927666790146777142378,
            0.381830050505118944950369775488975,
            0.417959183673469387755102040816327
        ], wgk = /* weights of the 15-point kronrod rule */ [
            0.02293532201052922496373200805897,
            0.063092092629978553290700663189204,
            0.104790010322250183839876322541518,
            0.140653259715525918745189590510238,
            0.16900472663926790282658342659855,
            0.190350578064785409913256402421014,
            0.204432940075298892414161999234649,
            0.209482141084727828012999174891714
        ];
        return this._gaussKronrod(interval, f, 8, xgk, wg, wgk, resultObj);
    },
    /**
     * 21 point Gauss-Kronrod quadrature algorithm, see the library QUADPACK
     * @param {Array} interval The integration interval, e.g. [0, 3].
     * @param {function} f A function which takes one argument of type number and returns a number.
     * @param {Object} resultObj Object returning resultObj.abserr, resultObj.resabs, resultObj.resasc. See the library
     *  QUADPACK for an explanation.
     *
     * @returns {Number} Integral value of f over interval
     *
     * @memberof JXG.Math.Numerics
     */ GaussKronrod21: function(interval, f, resultObj) {
        /* Gauss quadrature weights and kronrod quadrature abscissae and
                weights as evaluated with 80 decimal digit arithmetic by
                L. W. Fullerton, Bell Labs, Nov. 1981. */ var xgk = /* abscissae of the 21-point kronrod rule */ [
            0.995657163025808080735527280689003,
            0.973906528517171720077964012084452,
            0.930157491355708226001207180059508,
            0.865063366688984510732096688423493,
            0.780817726586416897063717578345042,
            0.679409568299024406234327365114874,
            0.562757134668604683339000099272694,
            0.433395394129247190799265943165784,
            0.294392862701460198131126603103866,
            0.14887433898163121088482600112972,
            0.0
        ], /* xgk[1], xgk[3], ... abscissae of the 10-point gauss rule.
                xgk[0], xgk[2], ... abscissae to optimally extend the 10-point gauss rule */ wg = /* weights of the 10-point gauss rule */ [
            0.066671344308688137593568809893332,
            0.149451349150580593145776339657697,
            0.219086362515982043995534934228163,
            0.269266719309996355091226921569469,
            0.295524224714752870173892994651338
        ], wgk = /* weights of the 21-point kronrod rule */ [
            0.011694638867371874278064396062192,
            0.03255816230796472747881897245939,
            0.05475589657435199603138130024458,
            0.07503967481091995276704314091619,
            0.093125454583697605535065465083366,
            0.109387158802297641899210590325805,
            0.123491976262065851077958109831074,
            0.134709217311473325928054001771707,
            0.142775938577060080797094273138717,
            0.147739104901338491374841515972068,
            0.149445554002916905664936468389821
        ];
        return this._gaussKronrod(interval, f, 11, xgk, wg, wgk, resultObj);
    },
    /**
     * 31 point Gauss-Kronrod quadrature algorithm, see the library QUADPACK
     * @param {Array} interval The integration interval, e.g. [0, 3].
     * @param {function} f A function which takes one argument of type number and returns a number.
     * @param {Object} resultObj Object returning resultObj.abserr, resultObj.resabs, resultObj.resasc. See the library
     *  QUADPACK for an explanation.
     *
     * @returns {Number} Integral value of f over interval
     *
     * @memberof JXG.Math.Numerics
     */ GaussKronrod31: function(interval, f, resultObj) {
        /* Gauss quadrature weights and kronrod quadrature abscissae and
                weights as evaluated with 80 decimal digit arithmetic by
                L. W. Fullerton, Bell Labs, Nov. 1981. */ var xgk = /* abscissae of the 21-point kronrod rule */ [
            0.998002298693397060285172840152271,
            0.987992518020485428489565718586613,
            0.967739075679139134257347978784337,
            0.937273392400705904307758947710209,
            0.897264532344081900882509656454496,
            0.848206583410427216200648320774217,
            0.790418501442465932967649294817947,
            0.724417731360170047416186054613938,
            0.650996741297416970533735895313275,
            0.570972172608538847537226737253911,
            0.485081863640239680693655740232351,
            0.394151347077563369897207370981045,
            0.299180007153168812166780024266389,
            0.201194093997434522300628303394596,
            0.101142066918717499027074231447392,
            0.0
        ], /* xgk[1], xgk[3], ... abscissae of the 10-point gauss rule.
                xgk[0], xgk[2], ... abscissae to optimally extend the 10-point gauss rule */ wg = /* weights of the 10-point gauss rule */ [
            0.030753241996117268354628393577204,
            0.070366047488108124709267416450667,
            0.107159220467171935011869546685869,
            0.139570677926154314447804794511028,
            0.166269205816993933553200860481209,
            0.186161000015562211026800561866423,
            0.198431485327111576456118326443839,
            0.202578241925561272880620199967519
        ], wgk = /* weights of the 21-point kronrod rule */ [
            0.005377479872923348987792051430128,
            0.015007947329316122538374763075807,
            0.025460847326715320186874001019653,
            0.03534636079137584622203794847836,
            0.04458975132476487660822729937328,
            0.05348152469092808726534314723943,
            0.062009567800670640285139230960803,
            0.069854121318728258709520077099147,
            0.076849680757720378894432777482659,
            0.083080502823133021038289247286104,
            0.088564443056211770647275443693774,
            0.093126598170825321225486872747346,
            0.096642726983623678505179907627589,
            0.099173598721791959332393173484603,
            0.10076984552387559504494666261757,
            0.101330007014791549017374792767493
        ];
        return this._gaussKronrod(interval, f, 16, xgk, wg, wgk, resultObj);
    },
    /**
     * Generate workspace object for {@link JXG.Math.Numerics.Qag}.
     * @param {Array} interval The integration interval, e.g. [0, 3].
     * @param {Number} n Max. limit
     * @returns {Object} Workspace object
     *
     * @private
     * @memberof JXG.Math.Numerics
     */ _workspace: function(interval, n) {
        return {
            limit: n,
            size: 0,
            nrmax: 0,
            i: 0,
            alist: [
                interval[0]
            ],
            blist: [
                interval[1]
            ],
            rlist: [
                0.0
            ],
            elist: [
                0.0
            ],
            order: [
                0
            ],
            level: [
                0
            ],
            qpsrt: function() {
                var last = this.size - 1, limit = this.limit, errmax, errmin, i, k, top, i_nrmax = this.nrmax, i_maxerr = this.order[i_nrmax];
                /* Check whether the list contains more than two error estimates */ if (last < 2) {
                    this.order[0] = 0;
                    this.order[1] = 1;
                    this.i = i_maxerr;
                    return;
                }
                errmax = this.elist[i_maxerr];
                /* This part of the routine is only executed if, due to a difficult
                        integrand, subdivision increased the error estimate. In the normal
                        case the insert procedure should start after the nrmax-th largest
                        error estimate. */ while(i_nrmax > 0 && errmax > this.elist[this.order[i_nrmax - 1]]){
                    this.order[i_nrmax] = this.order[i_nrmax - 1];
                    i_nrmax--;
                }
                /* Compute the number of elements in the list to be maintained in
                        descending order. This number depends on the number of
                        subdivisions still allowed. */ if (last < limit / 2 + 2) {
                    top = last;
                } else {
                    top = limit - last + 1;
                }
                /* Insert errmax by traversing the list top-down, starting
                        comparison from the element elist(order(i_nrmax+1)). */ i = i_nrmax + 1;
                /* The order of the tests in the following line is important to
                        prevent a segmentation fault */ while(i < top && errmax < this.elist[this.order[i]]){
                    this.order[i - 1] = this.order[i];
                    i++;
                }
                this.order[i - 1] = i_maxerr;
                /* Insert errmin by traversing the list bottom-up */ errmin = this.elist[last];
                k = top - 1;
                while(k > i - 2 && errmin >= this.elist[this.order[k]]){
                    this.order[k + 1] = this.order[k];
                    k--;
                }
                this.order[k + 1] = last;
                /* Set i_max and e_max */ i_maxerr = this.order[i_nrmax];
                this.i = i_maxerr;
                this.nrmax = i_nrmax;
            },
            set_initial_result: function(result, error) {
                this.size = 1;
                this.rlist[0] = result;
                this.elist[0] = error;
            },
            update: function(a1, b1, area1, error1, a2, b2, area2, error2) {
                var i_max = this.i, i_new = this.size, new_level = this.level[this.i] + 1;
                /* append the newly-created intervals to the list */ if (error2 > error1) {
                    this.alist[i_max] = a2; /* blist[maxerr] is already == b2 */ 
                    this.rlist[i_max] = area2;
                    this.elist[i_max] = error2;
                    this.level[i_max] = new_level;
                    this.alist[i_new] = a1;
                    this.blist[i_new] = b1;
                    this.rlist[i_new] = area1;
                    this.elist[i_new] = error1;
                    this.level[i_new] = new_level;
                } else {
                    this.blist[i_max] = b1; /* alist[maxerr] is already == a1 */ 
                    this.rlist[i_max] = area1;
                    this.elist[i_max] = error1;
                    this.level[i_max] = new_level;
                    this.alist[i_new] = a2;
                    this.blist[i_new] = b2;
                    this.rlist[i_new] = area2;
                    this.elist[i_new] = error2;
                    this.level[i_new] = new_level;
                }
                this.size++;
                if (new_level > this.maximum_level) {
                    this.maximum_level = new_level;
                }
                this.qpsrt();
            },
            retrieve: function() {
                var i = this.i;
                return {
                    a: this.alist[i],
                    b: this.blist[i],
                    r: this.rlist[i],
                    e: this.elist[i]
                };
            },
            sum_results: function() {
                var nn = this.size, k, result_sum = 0.0;
                for(k = 0; k < nn; k++){
                    result_sum += this.rlist[k];
                }
                return result_sum;
            },
            subinterval_too_small: function(a1, a2, b2) {
                var e = 2.2204460492503131e-16, u = 2.2250738585072014e-308, tmp = (1 + 100 * e) * (Math.abs(a2) + 1000 * u);
                return Math.abs(a1) <= tmp && Math.abs(b2) <= tmp;
            }
        };
    },
    /**
     * Quadrature algorithm qag from QUADPACK.
     * Internal method used in {@link JXG.Math.Numerics.GaussKronrod15},
     * {@link JXG.Math.Numerics.GaussKronrod21},
     * {@link JXG.Math.Numerics.GaussKronrod31}.
     *
     * @param {Array} interval The integration interval, e.g. [0, 3].
     * @param {function} f A function which takes one argument of type number and returns a number.
     * @param {Object} [config] The algorithm setup. Accepted propert are max. recursion limit of type number,
     * and epsrel and epsabs, the relative and absolute required precision of type number. Further,
     * q the internal quadrature sub-algorithm of type function.
     * @param {Number} [config.limit=15]
     * @param {Number} [config.epsrel=0.0000001]
     * @param {Number} [config.epsabs=0.0000001]
     * @param {Number} [config.q=JXG.Math.Numerics.GaussKronrod15]
     * @returns {Number} Integral value of f over interval
     *
     * @example
     * function f(x) {
     *   return x*x;
     * }
     *
     * // calculates integral of <tt>f</tt> from 0 to 2.
     * var area1 = JXG.Math.Numerics.Qag([0, 2], f);
     *
     * // the same with an anonymous function
     * var area2 = JXG.Math.Numerics.Qag([0, 2], function (x) { return x*x; });
     *
     * // use JXG.Math.Numerics.GaussKronrod31 rule as sub-algorithm.
     * var area3 = JXG.Math.Numerics.Quag([0, 2], f,
     *                                   {q: JXG.Math.Numerics.GaussKronrod31});
     * @memberof JXG.Math.Numerics
     */ Qag: function(interval, f, config) {
        var DBL_EPS = 2.2204460492503131e-16, ws = this._workspace(interval, 1000), limit = config && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(config.limit) ? config.limit : 15, epsrel = config && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(config.epsrel) ? config.epsrel : 0.0000001, epsabs = config && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(config.epsabs) ? config.epsabs : 0.0000001, q = config && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isFunction(config.q) ? config.q : this.GaussKronrod15, resultObj = {}, area, errsum, result0, abserr0, resabs0, resasc0, result, tolerance, iteration = 0, roundoff_type1 = 0, roundoff_type2 = 0, error_type = 0, round_off, a1, b1, a2, b2, a_i, b_i, r_i, e_i, area1 = 0, area2 = 0, area12 = 0, error1 = 0, error2 = 0, error12 = 0, resasc1, resasc2, // resabs1, resabs2,
        wsObj, delta;
        if (limit > ws.limit) {
            __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].warn("iteration limit exceeds available workspace");
        }
        if (epsabs <= 0 && (epsrel < 50 * __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps || epsrel < 0.5e-28)) {
            __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].warn("tolerance cannot be acheived with given epsabs and epsrel");
        }
        result0 = q.apply(this, [
            interval,
            f,
            resultObj
        ]);
        abserr0 = resultObj.abserr;
        resabs0 = resultObj.resabs;
        resasc0 = resultObj.resasc;
        ws.set_initial_result(result0, abserr0);
        tolerance = Math.max(epsabs, epsrel * Math.abs(result0));
        round_off = 50 * DBL_EPS * resabs0;
        if (abserr0 <= round_off && abserr0 > tolerance) {
            result = result0;
            // abserr = abserr0;
            __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].warn("cannot reach tolerance because of roundoff error on first attempt");
            return -Infinity;
        }
        if (abserr0 <= tolerance && abserr0 !== resasc0 || abserr0 === 0.0) {
            result = result0;
            // abserr = abserr0;
            return result;
        }
        if (limit === 1) {
            result = result0;
            // abserr = abserr0;
            __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].warn("a maximum of one iteration was insufficient");
            return -Infinity;
        }
        area = result0;
        errsum = abserr0;
        iteration = 1;
        do {
            area1 = 0;
            area2 = 0;
            area12 = 0;
            error1 = 0;
            error2 = 0;
            error12 = 0;
            /* Bisect the subinterval with the largest error estimate */ wsObj = ws.retrieve();
            a_i = wsObj.a;
            b_i = wsObj.b;
            r_i = wsObj.r;
            e_i = wsObj.e;
            a1 = a_i;
            b1 = 0.5 * (a_i + b_i);
            a2 = b1;
            b2 = b_i;
            area1 = q.apply(this, [
                [
                    a1,
                    b1
                ],
                f,
                resultObj
            ]);
            error1 = resultObj.abserr;
            // resabs1 = resultObj.resabs;
            resasc1 = resultObj.resasc;
            area2 = q.apply(this, [
                [
                    a2,
                    b2
                ],
                f,
                resultObj
            ]);
            error2 = resultObj.abserr;
            // resabs2 = resultObj.resabs;
            resasc2 = resultObj.resasc;
            area12 = area1 + area2;
            error12 = error1 + error2;
            errsum += error12 - e_i;
            area += area12 - r_i;
            if (resasc1 !== error1 && resasc2 !== error2) {
                delta = r_i - area12;
                if (Math.abs(delta) <= 1.0e-5 * Math.abs(area12) && error12 >= 0.99 * e_i) {
                    roundoff_type1++;
                }
                if (iteration >= 10 && error12 > e_i) {
                    roundoff_type2++;
                }
            }
            tolerance = Math.max(epsabs, epsrel * Math.abs(area));
            if (errsum > tolerance) {
                if (roundoff_type1 >= 6 || roundoff_type2 >= 20) {
                    error_type = 2; /* round off error */ 
                }
                /* set error flag in the case of bad integrand behaviour at
                    a point of the integration range */ if (ws.subinterval_too_small(a1, a2, b2)) {
                    error_type = 3;
                }
            }
            ws.update(a1, b1, area1, error1, a2, b2, area2, error2);
            wsObj = ws.retrieve();
            a_i = wsObj.a_i;
            b_i = wsObj.b_i;
            r_i = wsObj.r_i;
            e_i = wsObj.e_i;
            iteration++;
        }while (iteration < limit && !error_type && errsum > tolerance)
        result = ws.sum_results();
        // abserr = errsum;
        /*
  if (errsum <= tolerance)
    {
      return GSL_SUCCESS;
    }
  else if (error_type == 2)
    {
      GSL_ERROR ("roundoff error prevents tolerance from being achieved",
                 GSL_EROUND);
    }
  else if (error_type == 3)
    {
      GSL_ERROR ("bad integrand behavior found in the integration interval",
                 GSL_ESING);
    }
  else if (iteration == limit)
    {
      GSL_ERROR ("maximum number of subdivisions reached", GSL_EMAXITER);
    }
  else
    {
      GSL_ERROR ("could not integrate function", GSL_EFAILED);
    }
*/ return result;
    },
    /**
     * Integral of function f over interval.
     * @param {Array} interval The integration interval, e.g. [0, 3].
     * @param {function} f A function which takes one argument of type number and returns a number.
     * @returns {Number} The value of the integral of f over interval
     * @see JXG.Math.Numerics.NewtonCotes
     * @see JXG.Math.Numerics.Romberg
     * @see JXG.Math.Numerics.Qag
     * @memberof JXG.Math.Numerics
     */ I: function(interval, f) {
        // return this.NewtonCotes(interval, f, {number_of_nodes: 16, integration_type: 'milne'});
        // return this.Romberg(interval, f, {max_iterations: 20, eps: 0.0000001});
        return this.Qag(interval, f, {
            q: this.GaussKronrod15,
            limit: 15,
            epsrel: 0.0000001,
            epsabs: 0.0000001
        });
    },
    /**
     * Newton's method to find roots of a funtion in one variable.
     * @param {function} f We search for a solution of f(x)=0.
     * @param {Number} x initial guess for the root, i.e. start value.
     * @param {Object} context optional object that is treated as "this" in the function body. This is useful if
     * the function is a method of an object and contains a reference to its parent object via "this".
     * @returns {Number} A root of the function f.
     * @memberof JXG.Math.Numerics
     */ Newton: function(f, x, context) {
        var df, i = 0, h = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps, newf = f.apply(context, [
            x
        ]);
        // nfev = 1;
        // For compatibility
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(x)) {
            x = x[0];
        }
        while(i < 50 && Math.abs(newf) > h){
            df = this.D(f, context)(x);
            // nfev += 2;
            if (Math.abs(df) > h) {
                x -= newf / df;
            } else {
                x += Math.random() * 0.2 - 1.0;
            }
            newf = f.apply(context, [
                x
            ]);
            // nfev += 1;
            i += 1;
        }
        return x;
    },
    /**
     * Abstract method to find roots of univariate functions, which - for the time being -
     * is an alias for {@link JXG.Math.Numerics.chandrupatla}.
     * @param {function} f We search for a solution of f(x)=0.
     * @param {Number|Array} x initial guess for the root, i.e. starting value, or start interval enclosing the root.
     * If x is an interval [a,b], it is required that f(a)f(b) <= 0, otherwise the minimum of f in [a, b] will be returned.
     * If x is a number, the algorithms tries to enclose the root by an interval [a, b] containing x and the root and
     * f(a)f(b) <= 0. If this fails, the algorithm falls back to Newton's method.
     *
     * @param {Object} context optional object that is treated as "this" in the function body. This is useful if
     * the function is a method of an object and contains a reference to its parent object via "this".
     * @returns {Number} A root of the function f.
     *
     * @see JXG.Math.Numerics.chandrupatla
     * @see JXG.Math.Numerics.fzero
     * @see JXG.Math.Numerics.polzeros
     * @see JXG.Math.Numerics.Newton
     * @memberof JXG.Math.Numerics
     */ root: function(f, x, context) {
        //return this.fzero(f, x, context);
        return this.chandrupatla(f, x, context);
    },
    /**
     * Compute an intersection of the curves c1 and c2
     * with a generalized Newton method.
     * We want to find values t1, t2 such that
     * c1(t1) = c2(t2), i.e.
     * <br>
     * (c1_x(t1)-c2_x(t2),c1_y(t1)-c2_y(t2)) = (0,0).
     * <p>
     * We set
     * (e,f) := (c1_x(t1)-c2_x(t2),c1_y(t1)-c2_y(t2))
     * <p>
     * The Jacobian J is defined by
     * <pre>
     * J = (a, b)
     *     (c, d)
     * </pre>
     * where
     * <ul>
     * <li> a = c1_x'(t1)
     * <li> b = -c2_x'(t2)
     * <li> c = c1_y'(t1)
     * <li> d = -c2_y'(t2)
     * </ul>
     * The inverse J^(-1) of J is equal to
     * <pre>
     *  (d, -b)/ (ad-bc)
     *  (-c, a) / (ad-bc)
     * </pre>
     *
     * Then, (t1new, t2new) := (t1,t2) - J^(-1)*(e,f).
     * <p>
     * If the function meetCurveCurve has the properties
     * t1memo and t2memo then these are taken as start values
     * for the Newton algorithm.
     * After stopping of the Newton algorithm the values of t1 and t2 are stored in
     * t1memo and t2memo.
     *
     * @param {JXG.Curve} c1 Curve, Line or Circle
     * @param {JXG.Curve} c2 Curve, Line or Circle
     * @param {Number} t1ini start value for t1
     * @param {Number} t2ini start value for t2
     * @returns {JXG.Coords} intersection point
     * @memberof JXG.Math.Numerics
     */ generalizedNewton: function(c1, c2, t1ini, t2ini) {
        var t1, t2, a, b, c, d, e, f, disc, F, D00, D01, D10, D11, count = 0;
        if (this.generalizedNewton.t1memo) {
            t1 = this.generalizedNewton.t1memo;
            t2 = this.generalizedNewton.t2memo;
        } else {
            t1 = t1ini;
            t2 = t2ini;
        }
        e = c1.X(t1) - c2.X(t2);
        f = c1.Y(t1) - c2.Y(t2);
        F = e * e + f * f;
        D00 = this.D(c1.X, c1);
        D01 = this.D(c2.X, c2);
        D10 = this.D(c1.Y, c1);
        D11 = this.D(c2.Y, c2);
        while(F > __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps && count < 10){
            a = D00(t1);
            b = -D01(t2);
            c = D10(t1);
            d = -D11(t2);
            disc = a * d - b * c;
            t1 -= (d * e - b * f) / disc;
            t2 -= (a * f - c * e) / disc;
            e = c1.X(t1) - c2.X(t2);
            f = c1.Y(t1) - c2.Y(t2);
            F = e * e + f * f;
            count += 1;
        }
        this.generalizedNewton.t1memo = t1;
        this.generalizedNewton.t2memo = t2;
        if (Math.abs(t1) < Math.abs(t2)) {
            return [
                c1.X(t1),
                c1.Y(t1)
            ];
        }
        return [
            c2.X(t2),
            c2.Y(t2)
        ];
    },
    /**
     * Returns the Lagrange polynomials for curves with equidistant nodes, see
     * Jean-Paul Berrut, Lloyd N. Trefethen: Barycentric Lagrange Interpolation,
     * SIAM Review, Vol 46, No 3, (2004) 501-517.
     * The graph of the parametric curve [x(t),y(t)] runs through the given points.
     * @param {Array} p Array of JXG.Points
     * @returns {Array} An array consisting of two functions x(t), y(t) which define a parametric curve
     * f(t) = (x(t), y(t)), a number x1 (which equals 0) and a function x2 defining the curve's domain.
     * That means the curve is defined between x1 and x2(). x2 returns the (length of array p minus one).
     * @memberof JXG.Math.Numerics
     *
     * @example
     * var p = [];
     *
     * p[0] = board.create('point', [0, -2], {size:2, name: 'C(a)'});
     * p[1] = board.create('point', [-1.5, 5], {size:2, name: ''});
     * p[2] = board.create('point', [1, 4], {size:2, name: ''});
     * p[3] = board.create('point', [3, 3], {size:2, name: 'C(b)'});
     *
     * // Curve
     * var fg = JXG.Math.Numerics.Neville(p);
     * var graph = board.create('curve', fg, {strokeWidth:3, strokeOpacity:0.5});
     *
     * </pre><div id="JXG88a8b3a8-6561-44f5-a678-76bca13fd484" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG88a8b3a8-6561-44f5-a678-76bca13fd484',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     var p = [];
     *
     *     p[0] = board.create('point', [0, -2], {size:2, name: 'C(a)'});
     *     p[1] = board.create('point', [-1.5, 5], {size:2, name: ''});
     *     p[2] = board.create('point', [1, 4], {size:2, name: ''});
     *     p[3] = board.create('point', [3, 3], {size:2, name: 'C(b)'});
     *
     *     // Curve
     *     var fg = JXG.Math.Numerics.Neville(p);
     *     var graph = board.create('curve', fg, {strokeWidth:3, strokeOpacity:0.5});
     *
     *     })();
     *
     * </script><pre>
     *
     */ Neville: function(p) {
        var w = [], /** @ignore */ makeFct = function(fun) {
            return function(t, suspendedUpdate) {
                var i, d, s, bin = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].binomial, len = p.length, len1 = len - 1, num = 0.0, denom = 0.0;
                if (!suspendedUpdate) {
                    s = 1;
                    for(i = 0; i < len; i++){
                        w[i] = bin(len1, i) * s;
                        s *= -1;
                    }
                }
                d = t;
                for(i = 0; i < len; i++){
                    if (d === 0) {
                        return p[i][fun]();
                    }
                    s = w[i] / d;
                    d -= 1;
                    num += p[i][fun]() * s;
                    denom += s;
                }
                return num / denom;
            };
        }, xfct = makeFct("X"), yfct = makeFct("Y");
        return [
            xfct,
            yfct,
            0,
            function() {
                return p.length - 1;
            }
        ];
    },
    /**
     * Calculates second derivatives at the given knots.
     * @param {Array} x x values of knots
     * @param {Array} y y values of knots
     * @returns {Array} Second derivatives of the interpolated function at the knots.
     * @see JXG.Math.Numerics.splineEval
     * @memberof JXG.Math.Numerics
     */ splineDef: function(x, y) {
        var pair, i, l, n = Math.min(x.length, y.length), diag = [], z = [], data = [], dx = [], delta = [], F = [];
        if (n === 2) {
            return [
                0,
                0
            ];
        }
        for(i = 0; i < n; i++){
            pair = {
                X: x[i],
                Y: y[i]
            };
            data.push(pair);
        }
        data.sort(function(a, b) {
            return a.X - b.X;
        });
        for(i = 0; i < n; i++){
            x[i] = data[i].X;
            y[i] = data[i].Y;
        }
        for(i = 0; i < n - 1; i++){
            dx.push(x[i + 1] - x[i]);
        }
        for(i = 0; i < n - 2; i++){
            delta.push(6 * (y[i + 2] - y[i + 1]) / dx[i + 1] - 6 * (y[i + 1] - y[i]) / dx[i]);
        }
        // ForwardSolve
        diag.push(2 * (dx[0] + dx[1]));
        z.push(delta[0]);
        for(i = 0; i < n - 3; i++){
            l = dx[i + 1] / diag[i];
            diag.push(2 * (dx[i + 1] + dx[i + 2]) - l * dx[i + 1]);
            z.push(delta[i + 1] - l * z[i]);
        }
        // BackwardSolve
        F[n - 3] = z[n - 3] / diag[n - 3];
        for(i = n - 4; i >= 0; i--){
            F[i] = (z[i] - dx[i + 1] * F[i + 1]) / diag[i];
        }
        // Generate f''-Vector
        for(i = n - 3; i >= 0; i--){
            F[i + 1] = F[i];
        }
        // natural cubic spline
        F[0] = 0;
        F[n - 1] = 0;
        return F;
    },
    /**
     * Evaluate points on spline.
     * @param {Number|Array} x0 A single float value or an array of values to evaluate
     * @param {Array} x x values of knots
     * @param {Array} y y values of knots
     * @param {Array} F Second derivatives at knots, calculated by {@link JXG.Math.Numerics.splineDef}
     * @see JXG.Math.Numerics.splineDef
     * @returns {Number|Array} A single value or an array, depending on what is given as x0.
     * @memberof JXG.Math.Numerics
     */ splineEval: function(x0, x, y, F) {
        var i, j, a, b, c, d, x_, n = Math.min(x.length, y.length), l = 1, asArray = false, y0 = [];
        // number of points to be evaluated
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(x0)) {
            l = x0.length;
            asArray = true;
        } else {
            x0 = [
                x0
            ];
        }
        for(i = 0; i < l; i++){
            // is x0 in defining interval?
            if (x0[i] < x[0] || x[i] > x[n - 1]) {
                return NaN;
            }
            // determine part of spline in which x0 lies
            for(j = 1; j < n; j++){
                if (x0[i] <= x[j]) {
                    break;
                }
            }
            j -= 1;
            // we're now in the j-th partial interval, i.e. x[j] < x0[i] <= x[j+1];
            // determine the coefficients of the polynomial in this interval
            a = y[j];
            b = (y[j + 1] - y[j]) / (x[j + 1] - x[j]) - (x[j + 1] - x[j]) / 6 * (F[j + 1] + 2 * F[j]);
            c = F[j] / 2;
            d = (F[j + 1] - F[j]) / (6 * (x[j + 1] - x[j]));
            // evaluate x0[i]
            x_ = x0[i] - x[j];
            //y0.push(a + b*x_ + c*x_*x_ + d*x_*x_*x_);
            y0.push(a + (b + (c + d * x_) * x_) * x_);
        }
        if (asArray) {
            return y0;
        }
        return y0[0];
    },
    /**
     * Generate a string containing the function term of a polynomial.
     * @param {Array} coeffs Coefficients of the polynomial. The position i belongs to x^i.
     * @param {Number} deg Degree of the polynomial
     * @param {String} varname Name of the variable (usually 'x')
     * @param {Number} prec Precision
     * @returns {String} A string containing the function term of the polynomial.
     * @memberof JXG.Math.Numerics
     */ generatePolynomialTerm: function(coeffs, deg, varname, prec) {
        var i, t = [];
        for(i = deg; i >= 0; i--){
            __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].concat(t, [
                "(",
                coeffs[i].toPrecision(prec),
                ")"
            ]);
            if (i > 1) {
                __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].concat(t, [
                    "*",
                    varname,
                    "<sup>",
                    i,
                    "<",
                    "/sup> + "
                ]);
            } else if (i === 1) {
                __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].concat(t, [
                    "*",
                    varname,
                    " + "
                ]);
            }
        }
        return t.join("");
    },
    /**
     * Computes the polynomial through a given set of coordinates in Lagrange form.
     * Returns the Lagrange polynomials, see
     * Jean-Paul Berrut, Lloyd N. Trefethen: Barycentric Lagrange Interpolation,
     * SIAM Review, Vol 46, No 3, (2004) 501-517.
     * <p>
     * It possesses the method getTerm() which returns the string containing the function term of the polynomial and
     * the method getCoefficients() which returns an array containing the coefficients of the polynomial.
     * @param {Array} p Array of JXG.Points
     * @returns {function} A function of one parameter which returns the value of the polynomial, whose graph runs through the given points.
     * @memberof JXG.Math.Numerics
     *
     * @example
     * var p = [];
     * p[0] = board.create('point', [-1,2], {size:4});
     * p[1] = board.create('point', [0,3], {size:4});
     * p[2] = board.create('point', [1,1], {size:4});
     * p[3] = board.create('point', [3,-1], {size:4});
     * var f = JXG.Math.Numerics.lagrangePolynomial(p);
     * var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});
     *
     * </pre><div id="JXGc058aa6b-74d4-41e1-af94-df06169a2d89" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXGc058aa6b-74d4-41e1-af94-df06169a2d89',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     var p = [];
     *     p[0] = board.create('point', [-1,2], {size:4});
     *     p[1] = board.create('point', [0,3], {size:4});
     *     p[2] = board.create('point', [1,1], {size:4});
     *     p[3] = board.create('point', [3,-1], {size:4});
     *     var f = JXG.Math.Numerics.lagrangePolynomial(p);
     *     var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});
     *
     *     })();
     *
     * </script><pre>
     *
     * @example
     * var points = [];
     * points[0] = board.create('point', [-1,2], {size:4});
     * points[1] = board.create('point', [0, 0], {size:4});
     * points[2] = board.create('point', [2, 1], {size:4});
     *
     * var f = JXG.Math.Numerics.lagrangePolynomial(points);
     * var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});
     * var txt = board.create('text', [-3, -4,  () => f.getTerm(2, 't', ' * ')], {fontSize: 16});
     * var txt2 = board.create('text', [-3, -6,  () => f.getCoefficients()], {fontSize: 12});
     *
     * </pre><div id="JXG73fdaf12-e257-4374-b488-ae063e4eecbb" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG73fdaf12-e257-4374-b488-ae063e4eecbb',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     var points = [];
     *     points[0] = board.create('point', [-1,2], {size:4});
     *     points[1] = board.create('point', [0, 0], {size:4});
     *     points[2] = board.create('point', [2, 1], {size:4});
     *
     *     var f = JXG.Math.Numerics.lagrangePolynomial(points);
     *     var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});
     *     var txt = board.create('text', [-3, -4,  () => f.getTerm(2, 't', ' * ')], {fontSize: 16});
     *     var txt2 = board.create('text', [-3, -6,  () => f.getCoefficients()], {fontSize: 12});
     *
     *     })();
     *
     * </script><pre>
     *
     */ lagrangePolynomial: function(p) {
        var w = [], that = this, /** @ignore */ fct = function(x, suspendedUpdate) {
            var i, k, xi, s, len = p.length, num = 0, denom = 0;
            if (!suspendedUpdate) {
                for(i = 0; i < len; i++){
                    w[i] = 1.0;
                    xi = p[i].X();
                    for(k = 0; k < len; k++){
                        if (k !== i) {
                            w[i] *= xi - p[k].X();
                        }
                    }
                    w[i] = 1 / w[i];
                }
            // M = [];
            // for (k = 0; k < len; k++) {
            //     M.push([1]);
            // }
            }
            for(i = 0; i < len; i++){
                xi = p[i].X();
                if (x === xi) {
                    return p[i].Y();
                }
                s = w[i] / (x - xi);
                denom += s;
                num += s * p[i].Y();
            }
            return num / denom;
        };
        /**
         * Get the term of the Lagrange polynomial as string.
         * Calls {@link JXG.Math.Numerics#lagrangePolynomialTerm}.
         *
         * @name JXG.Math.Numerics.lagrangePolynomial#getTerm
         * @param {Number} digits Number of digits of the coefficients
         * @param {String} param Variable name
         * @param {String} dot Dot symbol
         * @returns {String} containing the term of Lagrange polynomial as string.
         * @see JXG.Math.Numerics.lagrangePolynomialTerm
         * @example
         * var points = [];
         * points[0] = board.create('point', [-1,2], {size:4});
         * points[1] = board.create('point', [0, 0], {size:4});
         * points[2] = board.create('point', [2, 1], {size:4});
         *
         * var f = JXG.Math.Numerics.lagrangePolynomial(points);
         * var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});
         * var txt = board.create('text', [-3, -4,  () => f.getTerm(2, 't', ' * ')], {fontSize: 16});
         *
         * </pre><div id="JXG73fdaf12-e257-4374-b488-ae063e4eeccf" class="jxgbox" style="width: 300px; height: 300px;"></div>
         * <script type="text/javascript">
         *     (function() {
         *         var board = JXG.JSXGraph.initBoard('JXG73fdaf12-e257-4374-b488-ae063e4eeccf',
         *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
         *     var points = [];
         *     points[0] = board.create('point', [-1,2], {size:4});
         *     points[1] = board.create('point', [0, 0], {size:4});
         *     points[2] = board.create('point', [2, 1], {size:4});
         *
         *     var f = JXG.Math.Numerics.lagrangePolynomial(points);
         *     var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});
         *     var txt = board.create('text', [-3, -4,  () => f.getTerm(2, 't', ' * ')], {fontSize: 16});
         *
         *     })();
         *
         * </script><pre>
         *
         */ fct.getTerm = function(digits, param, dot) {
            return that.lagrangePolynomialTerm(p, digits, param, dot)();
        };
        /**
         * Get the coefficients of the Lagrange polynomial as array. The leading
         * coefficient is at position 0.
         * Calls {@link JXG.Math.Numerics#lagrangePolynomialCoefficients}.
         *
         * @name JXG.Math.Numerics.lagrangePolynomial#getCoefficients
         * @returns {Array} containing the coefficients of the Lagrange polynomial.
         * @see JXG.Math.Numerics.lagrangePolynomial.getTerm
         * @see JXG.Math.Numerics.lagrangePolynomialTerm
         * @see JXG.Math.Numerics.lagrangePolynomialCoefficients
         * @example
         * var points = [];
         * points[0] = board.create('point', [-1,2], {size:4});
         * points[1] = board.create('point', [0, 0], {size:4});
         * points[2] = board.create('point', [2, 1], {size:4});
         *
         * var f = JXG.Math.Numerics.lagrangePolynomial(points);
         * var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});
         * var txt = board.create('text', [1, -4,  () => f.getCoefficients()], {fontSize: 10});
         *
         * </pre><div id="JXG52a883a5-2e0c-4caf-8f84-8650c173c365" class="jxgbox" style="width: 300px; height: 300px;"></div>
         * <script type="text/javascript">
         *     (function() {
         *         var board = JXG.JSXGraph.initBoard('JXG52a883a5-2e0c-4caf-8f84-8650c173c365',
         *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
         *     var points = [];
         *     points[0] = board.create('point', [-1,2], {size:4});
         *     points[1] = board.create('point', [0, 0], {size:4});
         *     points[2] = board.create('point', [2, 1], {size:4});
         *
         *     var f = JXG.Math.Numerics.lagrangePolynomial(points);
         *     var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});
         *     var txt = board.create('text', [1, -4,  () => f.getCoefficients()], {fontSize: 10});
         *
         *     })();
         *
         * </script><pre>
         *
         */ fct.getCoefficients = function() {
            return that.lagrangePolynomialCoefficients(p)();
        };
        return fct;
    },
    /**
     * Determine the Lagrange polynomial through an array of points and
     * return the term of the polynomial as string.
     *
     * @param {Array} points Array of JXG.Points
     * @param {Number} digits Number of decimal digits of the coefficients
     * @param {String} param Name of the parameter. Default: 'x'.
     * @param {String} dot Multiplication symbol. Default: ' * '.
     * @returns {Function} returning the Lagrange polynomial term through
     *    the supplied points as string
     * @memberof JXG.Math.Numerics
     *
     * @example
     * var points = [];
     * points[0] = board.create('point', [-1,2], {size:4});
     * points[1] = board.create('point', [0, 0], {size:4});
     * points[2] = board.create('point', [2, 1], {size:4});
     *
     * var f = JXG.Math.Numerics.lagrangePolynomial(points);
     * var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});
     *
     * var f_txt = JXG.Math.Numerics.lagrangePolynomialTerm(points, 2, 't', ' * ');
     * var txt = board.create('text', [-3, -4, f_txt], {fontSize: 16});
     *
     * </pre><div id="JXGd45e9e96-7526-486d-aa43-e1178d5f2baa" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXGd45e9e96-7526-486d-aa43-e1178d5f2baa',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     var points = [];
     *     points[0] = board.create('point', [-1,2], {size:4});
     *     points[1] = board.create('point', [0, 0], {size:4});
     *     points[2] = board.create('point', [2, 1], {size:4});
     *
     *     var f = JXG.Math.Numerics.lagrangePolynomial(points);
     *     var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});
     *
     *     var f_txt = JXG.Math.Numerics.lagrangePolynomialTerm(points, 2, 't', ' * ');
     *     var txt = board.create('text', [-3, -4, f_txt], {fontSize: 16});
     *
     *     })();
     *
     * </script><pre>
     *
     */ lagrangePolynomialTerm: function(points, digits, param, dot) {
        var that = this;
        return function() {
            var len = points.length, coeffs = [], isLeading = true, n, t, j, c;
            param = param || "x";
            if (dot === undefined) {
                dot = " * ";
            }
            n = len - 1; // (Max) degree of the polynomial
            coeffs = that.lagrangePolynomialCoefficients(points)();
            t = "";
            for(j = 0; j < coeffs.length; j++){
                c = coeffs[j];
                if (Math.abs(c) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
                    continue;
                }
                if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(digits)) {
                    c = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$env$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]._round10(c, -digits);
                }
                if (isLeading) {
                    t += c > 0 ? c : "-" + -c;
                    isLeading = false;
                } else {
                    t += c > 0 ? " + " + c : " - " + -c;
                }
                if (n - j > 1) {
                    t += dot + param + "^" + (n - j);
                } else if (n - j === 1) {
                    t += dot + param;
                }
            }
            return t; // board.jc.manipulate('f = map(x) -> ' + t + ';');
        };
    },
    /**
     * Determine the Lagrange polynomial through an array of points and
     * return the coefficients of the polynomial as array.
     * The leading coefficient is at position 0.
     *
     * @param {Array} points Array of JXG.Points
     * @returns {Function} returning the coefficients of the Lagrange polynomial through
     *    the supplied points.
     * @memberof JXG.Math.Numerics
     *
     * @example
     * var points = [];
     * points[0] = board.create('point', [-1,2], {size:4});
     * points[1] = board.create('point', [0, 0], {size:4});
     * points[2] = board.create('point', [2, 1], {size:4});
     *
     * var f = JXG.Math.Numerics.lagrangePolynomial(points);
     * var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});
     *
     * var f_arr = JXG.Math.Numerics.lagrangePolynomialCoefficients(points);
     * var txt = board.create('text', [1, -4, f_arr], {fontSize: 10});
     *
     * </pre><div id="JXG1778f0d1-a420-473f-99e8-1755ef4be97e" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG1778f0d1-a420-473f-99e8-1755ef4be97e',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     var points = [];
     *     points[0] = board.create('point', [-1,2], {size:4});
     *     points[1] = board.create('point', [0, 0], {size:4});
     *     points[2] = board.create('point', [2, 1], {size:4});
     *
     *     var f = JXG.Math.Numerics.lagrangePolynomial(points);
     *     var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});
     *
     *     var f_arr = JXG.Math.Numerics.lagrangePolynomialCoefficients(points);
     *     var txt = board.create('text', [1, -4, f_arr], {fontSize: 10});
     *
     *     })();
     *
     * </script><pre>
     *
     */ lagrangePolynomialCoefficients: function(points) {
        return function() {
            var len = points.length, zeroes = [], coeffs = [], coeffs_sum = [], i, j, c, p;
            // n = len - 1; // (Max) degree of the polynomial
            for(j = 0; j < len; j++){
                coeffs_sum[j] = 0;
            }
            for(i = 0; i < len; i++){
                c = points[i].Y();
                p = points[i].X();
                zeroes = [];
                for(j = 0; j < len; j++){
                    if (j !== i) {
                        c /= p - points[j].X();
                        zeroes.push(points[j].X());
                    }
                }
                coeffs = [
                    1
                ].concat(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Vieta(zeroes));
                for(j = 0; j < coeffs.length; j++){
                    coeffs_sum[j] += (j % 2 === 1 ? -1 : 1) * coeffs[j] * c;
                }
            }
            return coeffs_sum;
        };
    },
    /**
     * Determine the coefficients of a cardinal spline polynom, See
     * https://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections
     * @param  {Number} x1 point 1
     * @param  {Number} x2 point 2
     * @param  {Number} t1 tangent slope 1
     * @param  {Number} t2 tangent slope 2
     * @return {Array}    coefficents array c for the polynomial t maps to
     * c[0] + c[1]*t + c[2]*t*t + c[3]*t*t*t
     */ _initCubicPoly: function(x1, x2, t1, t2) {
        return [
            x1,
            t1,
            -3 * x1 + 3 * x2 - 2 * t1 - t2,
            2 * x1 - 2 * x2 + t1 + t2
        ];
    },
    /**
     * Computes the cubic cardinal spline curve through a given set of points. The curve
     * is uniformly parametrized.
     * Two artificial control points at the beginning and the end are added.
     *
     * The implementation (especially the centripetal parametrization) is from
     * https://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections .
     * @param {Array} points Array consisting of JXG.Points.
     * @param {Number|Function} tau The tension parameter, either a constant number or a function returning a number. This number is between 0 and 1.
     * tau=1/2 give Catmull-Rom splines.
     * @param {String} type (Optional) parameter which allows to choose between "uniform" (default) and
     * "centripetal" parameterization. Thus the two possible values are "uniform" or "centripetal".
     * @returns {Array} An Array consisting of four components: Two functions each of one parameter t
     * which return the x resp. y coordinates of the Catmull-Rom-spline curve in t, a zero value,
     * and a function simply returning the length of the points array
     * minus three.
     * @memberof JXG.Math.Numerics
     */ CardinalSpline: function(points, tau_param, type) {
        var p, coeffs = [], makeFct, tau, _tau, that = this;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isFunction(tau_param)) {
            _tau = tau_param;
        } else {
            _tau = function() {
                return tau_param;
            };
        }
        if (type === undefined) {
            type = "uniform";
        }
        /** @ignore */ makeFct = function(which) {
            return function(t, suspendedUpdate) {
                var s, c, // control point at the beginning and at the end
                first, last, t1, t2, dt0, dt1, dt2, // dx, dy,
                len;
                if (points.length < 2) {
                    return NaN;
                }
                if (!suspendedUpdate) {
                    tau = _tau();
                    // New point list p: [first, points ..., last]
                    first = {
                        X: function() {
                            return 2 * points[0].X() - points[1].X();
                        },
                        Y: function() {
                            return 2 * points[0].Y() - points[1].Y();
                        },
                        Dist: function(p) {
                            var dx = this.X() - p.X(), dy = this.Y() - p.Y();
                            return __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].hypot(dx, dy);
                        }
                    };
                    last = {
                        X: function() {
                            return 2 * points[points.length - 1].X() - points[points.length - 2].X();
                        },
                        Y: function() {
                            return 2 * points[points.length - 1].Y() - points[points.length - 2].Y();
                        },
                        Dist: function(p) {
                            var dx = this.X() - p.X(), dy = this.Y() - p.Y();
                            return __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].hypot(dx, dy);
                        }
                    };
                    p = [
                        first
                    ].concat(points, [
                        last
                    ]);
                    len = p.length;
                    coeffs[which] = [];
                    for(s = 0; s < len - 3; s++){
                        if (type === "centripetal") {
                            // The order is important, since p[0].coords === undefined
                            dt0 = p[s].Dist(p[s + 1]);
                            dt1 = p[s + 2].Dist(p[s + 1]);
                            dt2 = p[s + 3].Dist(p[s + 2]);
                            dt0 = Math.sqrt(dt0);
                            dt1 = Math.sqrt(dt1);
                            dt2 = Math.sqrt(dt2);
                            if (dt1 < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
                                dt1 = 1.0;
                            }
                            if (dt0 < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
                                dt0 = dt1;
                            }
                            if (dt2 < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
                                dt2 = dt1;
                            }
                            t1 = (p[s + 1][which]() - p[s][which]()) / dt0 - (p[s + 2][which]() - p[s][which]()) / (dt1 + dt0) + (p[s + 2][which]() - p[s + 1][which]()) / dt1;
                            t2 = (p[s + 2][which]() - p[s + 1][which]()) / dt1 - (p[s + 3][which]() - p[s + 1][which]()) / (dt2 + dt1) + (p[s + 3][which]() - p[s + 2][which]()) / dt2;
                            t1 *= dt1;
                            t2 *= dt1;
                            coeffs[which][s] = that._initCubicPoly(p[s + 1][which](), p[s + 2][which](), tau * t1, tau * t2);
                        } else {
                            coeffs[which][s] = that._initCubicPoly(p[s + 1][which](), p[s + 2][which](), tau * (p[s + 2][which]() - p[s][which]()), tau * (p[s + 3][which]() - p[s + 1][which]()));
                        }
                    }
                }
                if (isNaN(t)) {
                    return NaN;
                }
                len = points.length;
                // This is necessary for our advanced plotting algorithm:
                if (t <= 0.0) {
                    return points[0][which]();
                }
                if (t >= len) {
                    return points[len - 1][which]();
                }
                s = Math.floor(t);
                if (s === t) {
                    return points[s][which]();
                }
                t -= s;
                c = coeffs[which][s];
                if (c === undefined) {
                    return NaN;
                }
                return ((c[3] * t + c[2]) * t + c[1]) * t + c[0];
            };
        };
        return [
            makeFct("X"),
            makeFct("Y"),
            0,
            function() {
                return points.length - 1;
            }
        ];
    },
    /**
     * Computes the cubic Catmull-Rom spline curve through a given set of points. The curve
     * is uniformly parametrized. The curve is the cardinal spline curve for tau=0.5.
     * Two artificial control points at the beginning and the end are added.
     * @param {Array} points Array consisting of JXG.Points.
     * @param {String} type (Optional) parameter which allows to choose between "uniform" (default) and
     * "centripetal" parameterization. Thus the two possible values are "uniform" or "centripetal".
     * @returns {Array} An Array consisting of four components: Two functions each of one parameter t
     * which return the x resp. y coordinates of the Catmull-Rom-spline curve in t, a zero value, and a function simply
     * returning the length of the points array minus three.
     * @memberof JXG.Math.Numerics
     */ CatmullRomSpline: function(points, type) {
        return this.CardinalSpline(points, 0.5, type);
    },
    /**
     * Computes the regression polynomial of a given degree through a given set of coordinates.
     * Returns the regression polynomial function.
     * @param {Number|function|Slider} degree number, function or slider.
     * Either
     * @param {Array} dataX Array containing either the x-coordinates of the data set or both coordinates in
     * an array of {@link JXG.Point}s or {@link JXG.Coords}.
     * In the latter case, the <tt>dataY</tt> parameter will be ignored.
     * @param {Array} dataY Array containing the y-coordinates of the data set,
     * @returns {function} A function of one parameter which returns the value of the regression polynomial of the given degree.
     * It possesses the method getTerm() which returns the string containing the function term of the polynomial.
     * The function returned will throw an exception, if the data set is malformed.
     * @memberof JXG.Math.Numerics
     */ regressionPolynomial: function(degree, dataX, dataY) {
        var coeffs, deg, dX, dY, inputType, fct, term = "";
        // Slider
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isPoint(degree) && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isFunction(degree.Value)) {
            /** @ignore */ deg = function() {
                return degree.Value();
            };
        // function
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isFunction(degree)) {
            deg = degree;
        // number
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(degree)) {
            /** @ignore */ deg = function() {
                return degree;
            };
        } else {
            throw new Error("JSXGraph: Can't create regressionPolynomial from degree of type'" + typeof degree + "'.");
        }
        // Parameters degree, dataX, dataY
        if (arguments.length === 3 && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(dataX) && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(dataY)) {
            inputType = 0;
        // Parameters degree, point array
        } else if (arguments.length === 2 && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(dataX) && dataX.length > 0 && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isPoint(dataX[0])) {
            inputType = 1;
        } else if (arguments.length === 2 && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(dataX) && dataX.length > 0 && dataX[0].usrCoords && dataX[0].scrCoords) {
            inputType = 2;
        } else {
            throw new Error("JSXGraph: Can't create regressionPolynomial. Wrong parameters.");
        }
        /** @ignore */ fct = function(x, suspendedUpdate) {
            var i, j, M, MT, y, B, c, s, d, // input data
            len = dataX.length;
            d = Math.floor(deg());
            if (!suspendedUpdate) {
                // point list as input
                if (inputType === 1) {
                    dX = [];
                    dY = [];
                    for(i = 0; i < len; i++){
                        dX[i] = dataX[i].X();
                        dY[i] = dataX[i].Y();
                    }
                }
                if (inputType === 2) {
                    dX = [];
                    dY = [];
                    for(i = 0; i < len; i++){
                        dX[i] = dataX[i].usrCoords[1];
                        dY[i] = dataX[i].usrCoords[2];
                    }
                }
                // check for functions
                if (inputType === 0) {
                    dX = [];
                    dY = [];
                    for(i = 0; i < len; i++){
                        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isFunction(dataX[i])) {
                            dX.push(dataX[i]());
                        } else {
                            dX.push(dataX[i]);
                        }
                        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isFunction(dataY[i])) {
                            dY.push(dataY[i]());
                        } else {
                            dY.push(dataY[i]);
                        }
                    }
                }
                M = [];
                for(j = 0; j < len; j++){
                    M.push([
                        1
                    ]);
                }
                for(i = 1; i <= d; i++){
                    for(j = 0; j < len; j++){
                        M[j][i] = M[j][i - 1] * dX[j];
                    }
                }
                y = dY;
                MT = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].transpose(M);
                B = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].matMatMult(MT, M);
                c = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].matVecMult(MT, y);
                coeffs = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Numerics.Gauss(B, c);
                term = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Numerics.generatePolynomialTerm(coeffs, d, "x", 3);
            }
            // Horner's scheme to evaluate polynomial
            s = coeffs[d];
            for(i = d - 1; i >= 0; i--){
                s = s * x + coeffs[i];
            }
            return s;
        };
        /** @ignore */ fct.getTerm = function() {
            return term;
        };
        return fct;
    },
    /**
     * Computes the cubic Bezier curve through a given set of points.
     * @param {Array} points Array consisting of 3*k+1 {@link JXG.Points}.
     * The points at position k with k mod 3 = 0 are the data points,
     * points at position k with k mod 3 = 1 or 2 are the control points.
     * @returns {Array} An array consisting of two functions of one parameter t which return the
     * x resp. y coordinates of the Bezier curve in t, one zero value, and a third function accepting
     * no parameters and returning one third of the length of the points.
     * @memberof JXG.Math.Numerics
     */ bezier: function(points) {
        var len, flen, /** @ignore */ makeFct = function(which) {
            return function(t, suspendedUpdate) {
                var z = Math.floor(t) * 3, t0 = t % 1, t1 = 1 - t0;
                if (!suspendedUpdate) {
                    flen = 3 * Math.floor((points.length - 1) / 3);
                    len = Math.floor(flen / 3);
                }
                if (t < 0) {
                    return points[0][which]();
                }
                if (t >= len) {
                    return points[flen][which]();
                }
                if (isNaN(t)) {
                    return NaN;
                }
                return t1 * t1 * (t1 * points[z][which]() + 3 * t0 * points[z + 1][which]()) + (3 * t1 * points[z + 2][which]() + t0 * points[z + 3][which]()) * t0 * t0;
            };
        };
        return [
            makeFct("X"),
            makeFct("Y"),
            0,
            function() {
                return Math.floor(points.length / 3);
            }
        ];
    },
    /**
     * Computes the B-spline curve of order k (order = degree+1) through a given set of points.
     * @param {Array} points Array consisting of JXG.Points.
     * @param {Number} order Order of the B-spline curve.
     * @returns {Array} An Array consisting of four components: Two functions each of one parameter t
     * which return the x resp. y coordinates of the B-spline curve in t, a zero value, and a function simply
     * returning the length of the points array minus one.
     * @memberof JXG.Math.Numerics
     */ bspline: function(points, order) {
        var knots, _knotVector = function(n, k) {
            var j, kn = [];
            for(j = 0; j < n + k + 1; j++){
                if (j < k) {
                    kn[j] = 0.0;
                } else if (j <= n) {
                    kn[j] = j - k + 1;
                } else {
                    kn[j] = n - k + 2;
                }
            }
            return kn;
        }, _evalBasisFuncs = function(t, kn, k, s) {
            var i, j, a, b, den, N = [];
            if (kn[s] <= t && t < kn[s + 1]) {
                N[s] = 1;
            } else {
                N[s] = 0;
            }
            for(i = 2; i <= k; i++){
                for(j = s - i + 1; j <= s; j++){
                    if (j <= s - i + 1 || j < 0) {
                        a = 0.0;
                    } else {
                        a = N[j];
                    }
                    if (j >= s) {
                        b = 0.0;
                    } else {
                        b = N[j + 1];
                    }
                    den = kn[j + i - 1] - kn[j];
                    if (den === 0) {
                        N[j] = 0;
                    } else {
                        N[j] = (t - kn[j]) / den * a;
                    }
                    den = kn[j + i] - kn[j + 1];
                    if (den !== 0) {
                        N[j] += (kn[j + i] - t) / den * b;
                    }
                }
            }
            return N;
        }, /** @ignore */ makeFct = function(which) {
            return function(t, suspendedUpdate) {
                var y, j, s, N = [], len = points.length, n = len - 1, k = order;
                if (n <= 0) {
                    return NaN;
                }
                if (n + 2 <= k) {
                    k = n + 1;
                }
                if (t <= 0) {
                    return points[0][which]();
                }
                if (t >= n - k + 2) {
                    return points[n][which]();
                }
                s = Math.floor(t) + k - 1;
                knots = _knotVector(n, k);
                N = _evalBasisFuncs(t, knots, k, s);
                y = 0.0;
                for(j = s - k + 1; j <= s; j++){
                    if (j < len && j >= 0) {
                        y += points[j][which]() * N[j];
                    }
                }
                return y;
            };
        };
        return [
            makeFct("X"),
            makeFct("Y"),
            0,
            function() {
                return points.length - 1;
            }
        ];
    },
    /**
     * Numerical (symmetric) approximation of derivative. suspendUpdate is piped through,
     * see {@link JXG.Curve#updateCurve}
     * and {@link JXG.Curve#hasPoint}.
     * @param {function} f Function in one variable to be differentiated.
     * @param {object} [obj] Optional object that is treated as "this" in the function body. This is useful, if the function is a
     * method of an object and contains a reference to its parent object via "this".
     * @returns {function} Derivative function of a given function f.
     * @memberof JXG.Math.Numerics
     */ D: function(f, obj) {
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(obj)) {
            return function(x, suspendedUpdate) {
                var h = 0.00001, h2 = h * 2.0;
                // Experiments with Richardsons rule
                /*
                    var phi = (f(x + h, suspendedUpdate) - f(x - h, suspendedUpdate)) / h2;
                    var phi2;
                    h *= 0.5;
                    h2 *= 0.5;
                    phi2 = (f(x + h, suspendedUpdate) - f(x - h, suspendedUpdate)) / h2;

                    return phi2 + (phi2 - phi) / 3.0;
                    */ return (f(x + h, suspendedUpdate) - f(x - h, suspendedUpdate)) / h2;
            };
        }
        return function(x, suspendedUpdate) {
            var h = 0.00001, h2 = h * 2.0;
            return (f.apply(obj, [
                x + h,
                suspendedUpdate
            ]) - f.apply(obj, [
                x - h,
                suspendedUpdate
            ])) / h2;
        };
    },
    /**
     * Evaluate the function term for {@link JXG.Math.Numerics.riemann}.
     * @private
     * @param {Number} x function argument
     * @param {function} f JavaScript function returning a number
     * @param {String} type Name of the Riemann sum type, e.g. 'lower'.
     * @param {Number} delta Width of the bars in user coordinates
     * @returns {Number} Upper (delta > 0) or lower (delta < 0) value of the bar containing x of the Riemann sum.
     * @see JXG.Math.Numerics.riemann
     * @private
     * @memberof JXG.Math.Numerics
     */ _riemannValue: function(x, f, type, delta) {
        var y, y1, x1, delta1;
        if (delta < 0) {
            // delta is negative if the lower function term is evaluated
            if (type !== "trapezoidal") {
                x = x + delta;
            }
            delta *= -1;
            if (type === "lower") {
                type = "upper";
            } else if (type === "upper") {
                type = "lower";
            }
        }
        delta1 = delta * 0.01; // for 'lower' and 'upper'
        if (type === "right") {
            y = f(x + delta);
        } else if (type === "middle") {
            y = f(x + delta * 0.5);
        } else if (type === "left" || type === "trapezoidal") {
            y = f(x);
        } else if (type === "lower") {
            y = f(x);
            for(x1 = x + delta1; x1 <= x + delta; x1 += delta1){
                y1 = f(x1);
                if (y1 < y) {
                    y = y1;
                }
            }
            y1 = f(x + delta);
            if (y1 < y) {
                y = y1;
            }
        } else if (type === "upper") {
            y = f(x);
            for(x1 = x + delta1; x1 <= x + delta; x1 += delta1){
                y1 = f(x1);
                if (y1 > y) {
                    y = y1;
                }
            }
            y1 = f(x + delta);
            if (y1 > y) {
                y = y1;
            }
        } else if (type === "random") {
            y = f(x + delta * Math.random());
        } else if (type === "simpson") {
            y = (f(x) + 4 * f(x + delta * 0.5) + f(x + delta)) / 6.0;
        } else {
            y = f(x); // default is lower
        }
        return y;
    },
    /**
     * Helper function to create curve which displays Riemann sums.
     * Compute coordinates for the rectangles showing the Riemann sum.
     * <p>
     * In case of type "simpson" and "trapezoidal", the horizontal line approximating the function value
     * is replaced by a parabola or a secant. IN case of "simpson",
     * the parabola is approximated visually by a polygonal chain of fixed step width.
     *
     * @param {Function|Array} f Function or array of two functions.
     * If f is a function the integral of this function is approximated by the Riemann sum.
     * If f is an array consisting of two functions the area between the two functions is filled
     * by the Riemann sum bars.
     * @param {Number} n number of rectangles.
     * @param {String} type Type of approximation. Possible values are: 'left', 'right', 'middle', 'lower', 'upper', 'random', 'simpson', or 'trapezoidal'.
     * "simpson" is Simpson's 1/3 rule.
     * @param {Number} start Left border of the approximation interval
     * @param {Number} end Right border of the approximation interval
     * @returns {Array} An array of two arrays containing the x and y coordinates for the rectangles showing the Riemann sum. This
     * array may be used as parent array of a {@link JXG.Curve}. The third parameteris the riemann sum, i.e. the sum of the volumes of all
     * rectangles.
     * @memberof JXG.Math.Numerics
     */ riemann: function(gf, n, type, start, end) {
        var i, delta, k, a, b, c, f0, f1, f2, xx, h, steps = 30, xarr = [], yarr = [], x = start, sum = 0, y, f, g;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(gf)) {
            g = gf[0];
            f = gf[1];
        } else {
            f = gf;
        }
        n = Math.floor(n);
        if (n <= 0) {
            return [
                xarr,
                yarr,
                sum
            ];
        }
        delta = (end - start) / n;
        // "Upper" horizontal line defined by function
        for(i = 0; i < n; i++){
            if (type === "simpson") {
                sum += this._riemannValue(x, f, type, delta) * delta;
                h = delta * 0.5;
                f0 = f(x);
                f1 = f(x + h);
                f2 = f(x + 2 * h);
                a = (f2 + f0 - 2 * f1) / (h * h) * 0.5;
                b = (f2 - f0) / (2 * h);
                c = f1;
                for(k = 0; k < steps; k++){
                    xx = k * delta / steps - h;
                    xarr.push(x + xx + h);
                    yarr.push(a * xx * xx + b * xx + c);
                }
                x += delta;
                y = f2;
            } else {
                y = this._riemannValue(x, f, type, delta);
                xarr.push(x);
                yarr.push(y);
                x += delta;
                if (type === "trapezoidal") {
                    f2 = f(x);
                    sum += (y + f2) * 0.5 * delta;
                    y = f2;
                } else {
                    sum += y * delta;
                }
                xarr.push(x);
                yarr.push(y);
            }
            xarr.push(x);
            yarr.push(y);
        }
        // "Lower" horizontal line
        // Go backwards
        for(i = 0; i < n; i++){
            if (type === "simpson" && g) {
                sum -= this._riemannValue(x, g, type, -delta) * delta;
                h = delta * 0.5;
                f0 = g(x);
                f1 = g(x - h);
                f2 = g(x - 2 * h);
                a = (f2 + f0 - 2 * f1) / (h * h) * 0.5;
                b = (f2 - f0) / (2 * h);
                c = f1;
                for(k = 0; k < steps; k++){
                    xx = k * delta / steps - h;
                    xarr.push(x - xx - h);
                    yarr.push(a * xx * xx + b * xx + c);
                }
                x -= delta;
                y = f2;
            } else {
                if (g) {
                    y = this._riemannValue(x, g, type, -delta);
                } else {
                    y = 0.0;
                }
                xarr.push(x);
                yarr.push(y);
                x -= delta;
                if (g) {
                    if (type === "trapezoidal") {
                        f2 = g(x);
                        sum -= (y + f2) * 0.5 * delta;
                        y = f2;
                    } else {
                        sum -= y * delta;
                    }
                }
            }
            xarr.push(x);
            yarr.push(y);
            // Draw the vertical lines
            xarr.push(x);
            yarr.push(f(x));
        }
        return [
            xarr,
            yarr,
            sum
        ];
    },
    /**
     * Approximate the integral by Riemann sums.
     * Compute the area described by the riemann sum rectangles.
     *
     * If there is an element of type {@link Riemannsum}, then it is more efficient
     * to use the method JXG.Curve.Value() of this element instead.
     *
     * @param {Function_Array} f Function or array of two functions.
     * If f is a function the integral of this function is approximated by the Riemann sum.
     * If f is an array consisting of two functions the area between the two functions is approximated
     * by the Riemann sum.
     * @param {Number} n number of rectangles.
     * @param {String} type Type of approximation. Possible values are: 'left', 'right', 'middle', 'lower', 'upper', 'random', 'simpson' or 'trapezoidal'.
     *
     * @param {Number} start Left border of the approximation interval
     * @param {Number} end Right border of the approximation interval
     * @returns {Number} The sum of the areas of the rectangles.
     * @memberof JXG.Math.Numerics
     */ riemannsum: function(f, n, type, start, end) {
        __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].deprecated("Numerics.riemannsum()", "Numerics.riemann()[2]");
        return this.riemann(f, n, type, start, end)[2];
    },
    /**
     * Solve initial value problems numerically using <i>explicit</i> Runge-Kutta methods.
     * See {@link https://en.wikipedia.org/wiki/Runge-Kutta_methods} for more information on the algorithm.
     * @param {object|String} butcher Butcher tableau describing the Runge-Kutta method to use. This can be either a string describing
     * a Runge-Kutta method with a Butcher tableau predefined in JSXGraph like 'euler', 'heun', 'rk4' or an object providing the structure
     * <pre>
     * {
     *     s: &lt;Number&gt;,
     *     A: &lt;matrix&gt;,
     *     b: &lt;Array&gt;,
     *     c: &lt;Array&gt;
     * }
     * </pre>
     * which corresponds to the Butcher tableau structure
     * shown here: https://en.wikipedia.org/w/index.php?title=List_of_Runge%E2%80%93Kutta_methods&oldid=357796696 .
     * <i>Default</i> is 'euler'.
     * @param {Array} x0 Initial value vector. Even if the problem is one-dimensional, the initial value has to be given in an array.
     * @param {Array} I Interval on which to integrate.
     * @param {Number} N Number of integration intervals, i.e. there are <i>N+1</i> evaluation points.
     * @param {function} f Function describing the right hand side of the first order ordinary differential equation, i.e. if the ode
     * is given by the equation <pre>dx/dt = f(t, x(t))</pre>. So, f has to take two parameters, a number <tt>t</tt> and a
     * vector <tt>x</tt>, and has to return a vector of the same length as <tt>x</tt> has.
     * @returns {Array} An array of vectors describing the solution of the ode on the given interval I.
     * @example
     * // A very simple autonomous system dx(t)/dt = x(t);
     * var f = function(t, x) {
     *     return [x[0]];
     * }
     *
     * // Solve it with initial value x(0) = 1 on the interval [0, 2]
     * // with 20 evaluation points.
     * var data = JXG.Math.Numerics.rungeKutta('heun', [1], [0, 2], 20, f);
     *
     * // Prepare data for plotting the solution of the ode using a curve.
     * var dataX = [];
     * var dataY = [];
     * var h = 0.1;        // (I[1] - I[0])/N  = (2-0)/20
     * var i;
     * for(i=0; i&lt;data.length; i++) {
     *     dataX[i] = i*h;
     *     dataY[i] = data[i][0];
     * }
     * var g = board.create('curve', [dataX, dataY], {strokeWidth:'2px'});
     * </pre><div class="jxgbox" id="JXGd2432d04-4ef7-4159-a90b-a2eb8d38c4f6" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     * var board = JXG.JSXGraph.initBoard('JXGd2432d04-4ef7-4159-a90b-a2eb8d38c4f6', {boundingbox: [-1, 5, 5, -1], axis: true, showcopyright: false, shownavigation: false});
     * var f = function(t, x) {
     *     // we have to copy the value.
     *     // return x; would just return the reference.
     *     return [x[0]];
     * }
     * var data = JXG.Math.Numerics.rungeKutta('heun', [1], [0, 2], 20, f);
     * var dataX = [];
     * var dataY = [];
     * var h = 0.1;
     * for(var i=0; i<data.length; i++) {
     *     dataX[i] = i*h;
     *     dataY[i] = data[i][0];
     * }
     * var g = board.create('curve', [dataX, dataY], {strokeColor:'red', strokeWidth:'2px'});
     * </script><pre>
     * @memberof JXG.Math.Numerics
     */ rungeKutta: function(butcher, x0, I, N, f) {
        var e, i, j, k, l, s, x = [], y = [], h = (I[1] - I[0]) / N, t = I[0], dim = x0.length, result = [], r = 0;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isString(butcher)) {
            butcher = predefinedButcher[butcher] || predefinedButcher.euler;
        }
        s = butcher.s;
        // Don't change x0, so copy it
        x = x0.slice();
        for(i = 0; i <= N; i++){
            result[r] = x.slice();
            r++;
            k = [];
            for(j = 0; j < s; j++){
                // Init y = 0
                for(e = 0; e < dim; e++){
                    y[e] = 0.0;
                }
                // Calculate linear combination of former k's and save it in y
                for(l = 0; l < j; l++){
                    for(e = 0; e < dim; e++){
                        y[e] += butcher.A[j][l] * h * k[l][e];
                    }
                }
                // Add x(t) to y
                for(e = 0; e < dim; e++){
                    y[e] += x[e];
                }
                // Calculate new k and add it to the k matrix
                k.push(f(t + butcher.c[j] * h, y));
            }
            // Init y = 0
            for(e = 0; e < dim; e++){
                y[e] = 0.0;
            }
            for(l = 0; l < s; l++){
                for(e = 0; e < dim; e++){
                    y[e] += butcher.b[l] * k[l][e];
                }
            }
            for(e = 0; e < dim; e++){
                x[e] = x[e] + h * y[e];
            }
            t += h;
        }
        return result;
    },
    /**
     * Maximum number of iterations in {@link JXG.Math.Numerics.fzero} and
     * {@link JXG.Math.Numerics.chandrupatla}
     * @type Number
     * @default 80
     * @memberof JXG.Math.Numerics
     */ maxIterationsRoot: 80,
    /**
     * Maximum number of iterations in {@link JXG.Math.Numerics.fminbr}
     * @type Number
     * @default 500
     * @memberof JXG.Math.Numerics
     */ maxIterationsMinimize: 500,
    /**
     * Given a number x_0, this function tries to find a second number x_1 such that
     * the function f has opposite signs at x_0 and x_1.
     * The return values have to be tested if the method succeeded.
     *
     * @param {Function} f Function, whose root is to be found
     * @param {Number} x0 Start value
     * @param {Object} [context] Parent object in case f is method of it
     * @returns {Array} [x_0, f(x_0), x_1, f(x_1)] in case that x_0 <= x_1
     *   or [x_1, f(x_1), x_0, f(x_0)] in case that x_1 < x_0.
     *
     * @see JXG.Math.Numerics.fzero
     * @see JXG.Math.Numerics.chandrupatla
     *
     * @memberof JXG.Math.Numerics
     */ findBracket: function(f, x0, context) {
        var a, aa, fa, blist, b, fb, u, fu, i, len;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(x0)) {
            return x0;
        }
        a = x0;
        fa = f.call(context, a);
        // nfev += 1;
        // Try to get b, by trying several values related to a
        aa = a === 0 ? 1 : a;
        blist = [
            a - 0.1 * aa,
            a + 0.1 * aa,
            a - 1,
            a + 1,
            a - 0.5 * aa,
            a + 0.5 * aa,
            a - 0.6 * aa,
            a + 0.6 * aa,
            a - 1 * aa,
            a + 1 * aa,
            a - 2 * aa,
            a + 2 * aa,
            a - 5 * aa,
            a + 5 * aa,
            a - 10 * aa,
            a + 10 * aa,
            a - 50 * aa,
            a + 50 * aa,
            a - 100 * aa,
            a + 100 * aa
        ];
        len = blist.length;
        for(i = 0; i < len; i++){
            b = blist[i];
            fb = f.call(context, b);
            // nfev += 1;
            if (fa * fb <= 0) {
                break;
            }
        }
        if (b < a) {
            u = a;
            a = b;
            b = u;
            fu = fa;
            fa = fb;
            fb = fu;
        }
        return [
            a,
            fa,
            b,
            fb
        ];
    },
    /**
     *
     * Find zero of an univariate function f.
     * @param {function} f Function, whose root is to be found
     * @param {Array|Number} x0  Start value or start interval enclosing the root.
     * If x0 is an interval [a,b], it is required that f(a)f(b) <= 0, otherwise the minimum of f in [a, b] will be returned.
     * If x0 is a number, the algorithms tries to enclose the root by an interval [a, b] containing x0 and the root and
     * f(a)f(b) <= 0. If this fails, the algorithm falls back to Newton's method.
     * @param {Object} [context] Parent object in case f is method of it
     * @returns {Number} the approximation of the root
     * Algorithm:
     *  Brent's root finder from
     *  G.Forsythe, M.Malcolm, C.Moler, Computer methods for mathematical
     *  computations. M., Mir, 1980, p.180 of the Russian edition
     *  https://www.netlib.org/c/brent.shar
     *
     * If x0 is an array containing lower and upper bound for the zero
     * algorithm 748 is applied. Otherwise, if x0 is a number,
     * the algorithm tries to bracket a zero of f starting from x0.
     * If this fails, we fall back to Newton's method.
     *
     * @see JXG.Math.Numerics.chandrupatla
     * @see JXG.Math.Numerics.root
     * @see JXG.Math.Numerics.findBracket
     * @see JXG.Math.Numerics.Newton
     * @see JXG.Math.Numerics.fminbr
     * @memberof JXG.Math.Numerics
     */ fzero: function(f, x0, context) {
        var a, b, c, fa, fb, fc, res, x00, prev_step, t1, t2, cb, tol_act, p, q, new_step, eps = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps, maxiter = this.maxIterationsRoot, niter = 0;
        // nfev = 0;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(x0)) {
            if (x0.length < 2) {
                throw new Error("JXG.Math.Numerics.fzero: length of array x0 has to be at least two.");
            }
            x00 = this.findDomain(f, x0, context);
            a = x00[0];
            b = x00[1];
            // a = x0[0];
            // b = x0[1];
            fa = f.call(context, a);
            // nfev += 1;
            fb = f.call(context, b);
        // nfev += 1;
        } else {
            res = this.findBracket(f, x0, context);
            a = res[0];
            fa = res[1];
            b = res[2];
            fb = res[3];
        }
        if (Math.abs(fa) <= eps) {
            return a;
        }
        if (Math.abs(fb) <= eps) {
            return b;
        }
        if (fa * fb > 0) {
            // Bracketing not successful, fall back to Newton's method or to fminbr
            if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(x0)) {
                return this.fminbr(f, [
                    a,
                    b
                ], context);
            }
            return this.Newton(f, a, context);
        }
        // OK, we have enclosed a zero of f.
        // Now we can start Brent's method
        c = a;
        fc = fa;
        // Main iteration loop
        while(niter < maxiter){
            // Distance from the last but one to the last approximation
            prev_step = b - a;
            // Swap data for b to be the best approximation
            if (Math.abs(fc) < Math.abs(fb)) {
                a = b;
                b = c;
                c = a;
                fa = fb;
                fb = fc;
                fc = fa;
            }
            tol_act = 2 * eps * Math.abs(b) + eps * 0.5;
            new_step = (c - b) * 0.5;
            if (Math.abs(new_step) <= tol_act || Math.abs(fb) <= eps) {
                //  Acceptable approx. is found
                return b;
            }
            // Decide if the interpolation can be tried
            // If prev_step was large enough and was in true direction Interpolatiom may be tried
            if (Math.abs(prev_step) >= tol_act && Math.abs(fa) > Math.abs(fb)) {
                cb = c - b;
                // If we have only two distinct points linear interpolation can only be applied
                if (a === c) {
                    t1 = fb / fa;
                    p = cb * t1;
                    q = 1.0 - t1;
                // Quadric inverse interpolation
                } else {
                    q = fa / fc;
                    t1 = fb / fc;
                    t2 = fb / fa;
                    p = t2 * (cb * q * (q - t1) - (b - a) * (t1 - 1.0));
                    q = (q - 1.0) * (t1 - 1.0) * (t2 - 1.0);
                }
                // p was calculated with the opposite sign; make p positive
                if (p > 0) {
                    q = -q;
                // and assign possible minus to q
                } else {
                    p = -p;
                }
                // If b+p/q falls in [b,c] and isn't too large it is accepted
                // If p/q is too large then the bissection procedure can reduce [b,c] range to more extent
                if (p < 0.75 * cb * q - Math.abs(tol_act * q) * 0.5 && p < Math.abs(prev_step * q * 0.5)) {
                    new_step = p / q;
                }
            }
            // Adjust the step to be not less than tolerance
            if (Math.abs(new_step) < tol_act) {
                new_step = new_step > 0 ? tol_act : -tol_act;
            }
            // Save the previous approx.
            a = b;
            fa = fb;
            b += new_step;
            fb = f.call(context, b);
            // Do step to a new approxim.
            // nfev += 1;
            // Adjust c for it to have a sign opposite to that of b
            if (fb > 0 && fc > 0 || fb < 0 && fc < 0) {
                c = a;
                fc = fa;
            }
            niter++;
        } // End while
        return b;
    },
    /**
     * Find zero of an univariate function f.
     * @param {function} f Function, whose root is to be found
     * @param {Array|Number} x0  Start value or start interval enclosing the root.
     * If x0 is an interval [a,b], it is required that f(a)f(b) <= 0, otherwise the minimum of f in [a, b] will be returned.
     * If x0 is a number, the algorithms tries to enclose the root by an interval [a, b] containing x0 and the root and
     * f(a)f(b) <= 0. If this fails, the algorithm falls back to Newton's method.
     * @param {Object} [context] Parent object in case f is method of it
     * @returns {Number} the approximation of the root
     * Algorithm:
     * Chandrupatla's method, see
     * Tirupathi R. Chandrupatla,
     * "A new hybrid quadratic/bisection algorithm for finding the zero of a nonlinear function without using derivatives",
     * Advances in Engineering Software, Volume 28, Issue 3, April 1997, Pages 145-149.
     *
     * If x0 is an array containing lower and upper bound for the zero
     * algorithm 748 is applied. Otherwise, if x0 is a number,
     * the algorithm tries to bracket a zero of f starting from x0.
     * If this fails, we fall back to Newton's method.
     *
     * @see JXG.Math.Numerics.root
     * @see JXG.Math.Numerics.fzero
     * @see JXG.Math.Numerics.findBracket
     * @see JXG.Math.Numerics.Newton
     * @see JXG.Math.Numerics.fminbr
     * @memberof JXG.Math.Numerics
     */ chandrupatla: function(f, x0, context) {
        var a, b, fa, fb, res, niter = 0, maxiter = this.maxIterationsRoot, rand = 1 + Math.random() * 0.001, t = 0.5 * rand, eps = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps, dlt = 0.00001, x1, x2, x3, x, f1, f2, f3, y, xm, fm, tol, tl, xi, ph, fl, fh, AL, A, B, C, D;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(x0)) {
            if (x0.length < 2) {
                throw new Error("JXG.Math.Numerics.fzero: length of array x0 has to be at least two.");
            }
            a = x0[0];
            fa = f.call(context, a);
            // nfev += 1;
            b = x0[1];
            fb = f.call(context, b);
        // nfev += 1;
        } else {
            res = this.findBracket(f, x0, context);
            a = res[0];
            fa = res[1];
            b = res[2];
            fb = res[3];
        }
        if (fa * fb > 0) {
            // Bracketing not successful, fall back to Newton's method or to fminbr
            if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(x0)) {
                return this.fminbr(f, [
                    a,
                    b
                ], context);
            }
            return this.Newton(f, a, context);
        }
        x1 = a;
        x2 = b;
        f1 = fa;
        f2 = fb;
        do {
            x = x1 + t * (x2 - x1);
            y = f.call(context, x);
            // Arrange 2-1-3: 2-1 interval, 1 middle, 3 discarded point
            if (Math.sign(y) === Math.sign(f1)) {
                x3 = x1;
                x1 = x;
                f3 = f1;
                f1 = y;
            } else {
                x3 = x2;
                x2 = x1;
                f3 = f2;
                f2 = f1;
            }
            x1 = x;
            f1 = y;
            xm = x1;
            fm = f1;
            if (Math.abs(f2) < Math.abs(f1)) {
                xm = x2;
                fm = f2;
            }
            tol = 2 * eps * Math.abs(xm) + 0.5 * dlt;
            tl = tol / Math.abs(x2 - x1);
            if (tl > 0.5 || fm === 0) {
                break;
            }
            // If inverse quadratic interpolation holds, use it
            xi = (x1 - x2) / (x3 - x2);
            ph = (f1 - f2) / (f3 - f2);
            fl = 1 - Math.sqrt(1 - xi);
            fh = Math.sqrt(xi);
            if (fl < ph && ph < fh) {
                AL = (x3 - x1) / (x2 - x1);
                A = f1 / (f2 - f1);
                B = f3 / (f2 - f3);
                C = f1 / (f3 - f1);
                D = f2 / (f3 - f2);
                t = A * B + C * D * AL;
            } else {
                t = 0.5 * rand;
            }
            // Adjust t away from the interval boundary
            if (t < tl) {
                t = tl;
            }
            if (t > 1 - tl) {
                t = 1 - tl;
            }
            niter++;
        }while (niter <= maxiter)
        // console.log(niter);
        return xm;
    },
    /**
     * Find a small enclosing interval of the domain of a function by
     * tightening the input interval x0.
     * <p>
     * This is a helper function which is used in {@link JXG.Math.Numerics.fminbr},
     * {@link JXG.Math.Numerics.fzero}, and  {@link JXG.Curve.getLabelPosition}
     * to avoid search in an interval where the function is mostly undefined.
     *
     * @param {function} f
     * @param {Array} x0 Start interval
     * @param {Object} context Parent object in case f is method of it
     * @param {Boolean} [outer=true] if true take a proper enclosing array. If false return the domain such that the function is defined
     * at its  borders.
     * @returns Array
     *
     * @example
     * var f = (x) => Math.sqrt(x);
     * console.log(JXG.Math.Numerics.findDomain(f, [-5, 5]));
     *
     * // Output: [ -0.00020428174445492973, 5 ]
     *
     * @example
     * var f = (x) => Math.sqrt(x);
     * console.log(JXG.Math.Numerics.findDomain(f, [-5, 5], null, false));
     *
     * // Output: [ 0.00020428174562965915, 5 ]
     */ findDomain: function(f, x0, context, outer) {
        var a, b, c, fc, x, gr = 1 - 1 / 1.61803398875, eps = 0.001, cnt, max_cnt = 20;
        if (outer === undefined) {
            outer = true;
        }
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(x0) || x0.length < 2) {
            throw new Error("JXG.Math.Numerics.findDomain: length of array x0 has to be at least two.");
        }
        x = x0.slice();
        a = x[0];
        b = x[1];
        fc = f.call(context, a);
        if (isNaN(fc)) {
            // Divide the interval with the golden ratio
            // and keep a such that f(a) = NaN
            cnt = 0;
            while(b - a > eps && cnt < max_cnt){
                c = (b - a) * gr + a;
                fc = f.call(context, c);
                if (isNaN(fc)) {
                    a = c;
                } else {
                    b = c;
                }
                cnt++;
            }
            if (outer) {
                x[0] = a;
            } else {
                x[0] = b;
            }
        // x[0] = a;
        }
        a = x[0];
        b = x[1];
        fc = f.call(context, b);
        if (isNaN(fc)) {
            // Divide the interval with the golden ratio
            // and keep b such that f(b) = NaN
            cnt = 0;
            while(b - a > eps && cnt < max_cnt){
                c = b - (b - a) * gr;
                fc = f.call(context, c);
                if (isNaN(fc)) {
                    b = c;
                } else {
                    a = c;
                }
                cnt++;
            }
            if (outer) {
                x[1] = b;
            } else {
                x[1] = a;
            }
        // x[1] = b;
        }
        return x;
    },
    /**
     *
     * Find minimum of an univariate function f.
     * <p>
     * Algorithm:
     *  G.Forsythe, M.Malcolm, C.Moler, Computer methods for mathematical
     *  computations. M., Mir, 1980, p.180 of the Russian edition
     *
     * @param {function} f Function, whose minimum is to be found
     * @param {Array} x0  Start interval enclosing the minimum
     * @param {Object} [context] Parent object in case f is method of it
     * @returns {Number} the approximation of the minimum value position
     * @memberof JXG.Math.Numerics
     **/ fminbr: function(f, x0, context) {
        var a, b, x, v, w, fx, fv, fw, x00, range, middle_range, tol_act, new_step, p, q, t, ft, r = (3.0 - Math.sqrt(5.0)) * 0.5, tol = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps, sqrteps = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps, maxiter = this.maxIterationsMinimize, niter = 0;
        // nfev = 0;
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(x0) || x0.length < 2) {
            throw new Error("JXG.Math.Numerics.fminbr: length of array x0 has to be at least two.");
        }
        x00 = this.findDomain(f, x0, context);
        a = x00[0];
        b = x00[1];
        v = a + r * (b - a);
        fv = f.call(context, v);
        // First step - always gold section
        // nfev += 1;
        x = v;
        w = v;
        fx = fv;
        fw = fv;
        while(niter < maxiter){
            // Range over the interval in which we are looking for the minimum
            range = b - a;
            middle_range = (a + b) * 0.5;
            // Actual tolerance
            tol_act = sqrteps * Math.abs(x) + tol / 3.0;
            if (Math.abs(x - middle_range) + range * 0.5 <= 2.0 * tol_act) {
                // Acceptable approx. is found
                return x;
            }
            // Obtain the golden section step
            new_step = r * (x < middle_range ? b - x : a - x);
            // Decide if the interpolation can be tried. If x and w are distinct, interpolatiom may be tried
            if (Math.abs(x - w) >= tol_act) {
                // Interpolation step is calculated as p/q;
                // division operation is delayed until last moment
                t = (x - w) * (fx - fv);
                q = (x - v) * (fx - fw);
                p = (x - v) * q - (x - w) * t;
                q = 2 * (q - t);
                if (q > 0) {
                    p = -p; // q was calculated with the opposite sign; make q positive
                } else {
                    q = -q; // // and assign possible minus to p
                }
                if (Math.abs(p) < Math.abs(new_step * q) && // If x+p/q falls in [a,b]
                p > q * (a - x + 2 * tol_act) && //  not too close to a and
                p < q * (b - x - 2 * tol_act)) {
                    // b, and isn't too large
                    new_step = p / q; // it is accepted
                }
            // If p / q is too large then the
            // golden section procedure can
            // reduce [a,b] range to more
            // extent
            }
            // Adjust the step to be not less than tolerance
            if (Math.abs(new_step) < tol_act) {
                if (new_step > 0) {
                    new_step = tol_act;
                } else {
                    new_step = -tol_act;
                }
            }
            // Obtain the next approximation to min
            // and reduce the enveloping range
            // Tentative point for the min
            t = x + new_step;
            ft = f.call(context, t);
            // nfev += 1;
            // t is a better approximation
            if (ft <= fx) {
                // Reduce the range so that t would fall within it
                if (t < x) {
                    b = x;
                } else {
                    a = x;
                }
                // Assign the best approx to x
                v = w;
                w = x;
                x = t;
                fv = fw;
                fw = fx;
                fx = ft;
            // x remains the better approx
            } else {
                // Reduce the range enclosing x
                if (t < x) {
                    a = t;
                } else {
                    b = t;
                }
                if (ft <= fw || w === x) {
                    v = w;
                    w = t;
                    fv = fw;
                    fw = ft;
                } else if (ft <= fv || v === x || v === w) {
                    v = t;
                    fv = ft;
                }
            }
            niter += 1;
        }
        return x;
    },
    /**
     * GLOMIN seeks a global minimum of a function F(X) in an interval [A,B]
     * and is the adaption of the algorithm GLOMIN by Richard Brent.
     *
     * Here is the original documentation:
     * <pre>
     *
     * Discussion:
     *
     * This function assumes that F(X) is twice continuously differentiable over [A,B]
     * and that |F''(X)| <= M for all X in [A,B].
     *
     * Licensing:
     *   This code is distributed under the GNU LGPL license.
     *
     * Modified:
     *
     *   17 April 2008
     *
     * Author:
     *
     *   Original FORTRAN77 version by Richard Brent.
     *   C version by John Burkardt.
     *   https://people.math.sc.edu/Burkardt/c_src/brent/brent.c
     *
     * Reference:
     *
     *   Richard Brent,
     *  Algorithms for Minimization Without Derivatives,
     *   Dover, 2002,
     *  ISBN: 0-486-41998-3,
     *   LC: QA402.5.B74.
     *
     * Parameters:
     *
     *   Input, double A, B, the endpoints of the interval.
     *  It must be the case that A < B.
     *
     *   Input, double C, an initial guess for the global
     *  minimizer.  If no good guess is known, C = A or B is acceptable.
     *
     *  Input, double M, the bound on the second derivative.
     *
     *   Input, double MACHEP, an estimate for the relative machine
     *  precision.
     *
     *   Input, double E, a positive tolerance, a bound for the
     *  absolute error in the evaluation of F(X) for any X in [A,B].
     *
     *   Input, double T, a positive error tolerance.
     *
     *    Input, double F (double x ), a user-supplied
     *  function whose global minimum is being sought.
     *
     *   Output, double *X, the estimated value of the abscissa
     *  for which F attains its global minimum value in [A,B].
     *
     *   Output, double GLOMIN, the value F(X).
     * </pre>
     *
     * In JSXGraph, some parameters of the original algorithm are set to fixed values:
     * <ul>
     *  <li> M = 10000000.0
     *  <li> C = A or B, depending if f(A) <= f(B)
     *  <li> T = JXG.Math.eps
     *  <li> E = JXG.Math.eps * JXG.Math.eps
     *  <li> MACHEP = JXG.Math.eps * JXG.Math.eps * JXG.Math.eps
     * </ul>
     * @param {function} f Function, whose global minimum is to be found
     * @param {Array} x0 Array of length 2 determining the interval [A, B] for which the global minimum is to be found
     * @returns {Array} [x, y] x is the position of the global minimum and y = f(x).
     */ glomin: function(f, x0) {
        var a0, a2, a3, d0, d1, d2, h, k, m2, p, q, qs, r, s, sc, y, y0, y1, y2, y3, yb, z0, z1, z2, a, b, c, x, m = 10000000.0, t = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps, e = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps * __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps, machep = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps * __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps * __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps;
        a = x0[0];
        b = x0[1];
        c = f(a) < f(b) ? a : b;
        a0 = b;
        x = a0;
        a2 = a;
        y0 = f(b);
        yb = y0;
        y2 = f(a);
        y = y2;
        if (y0 < y) {
            y = y0;
        } else {
            x = a;
        }
        if (m <= 0.0 || b <= a) {
            return y;
        }
        m2 = 0.5 * (1.0 + 16.0 * machep) * m;
        if (c <= a || b <= c) {
            sc = 0.5 * (a + b);
        } else {
            sc = c;
        }
        y1 = f(sc);
        k = 3;
        d0 = a2 - sc;
        h = 9.0 / 11.0;
        if (y1 < y) {
            x = sc;
            y = y1;
        }
        for(;;){
            d1 = a2 - a0;
            d2 = sc - a0;
            z2 = b - a2;
            z0 = y2 - y1;
            z1 = y2 - y0;
            r = d1 * d1 * z0 - d0 * d0 * z1;
            p = r;
            qs = 2.0 * (d0 * z1 - d1 * z0);
            q = qs;
            if (k < 1000000 || y2 <= y) {
                for(;;){
                    if (q * (r * (yb - y2) + z2 * q * (y2 - y + t)) < z2 * m2 * r * (z2 * q - r)) {
                        a3 = a2 + r / q;
                        y3 = f(a3);
                        if (y3 < y) {
                            x = a3;
                            y = y3;
                        }
                    }
                    k = 1611 * k % 1048576;
                    q = 1.0;
                    r = (b - a) * 0.00001 * k;
                    if (z2 <= r) {
                        break;
                    }
                }
            } else {
                k = 1611 * k % 1048576;
                q = 1.0;
                r = (b - a) * 0.00001 * k;
                while(r < z2){
                    if (q * (r * (yb - y2) + z2 * q * (y2 - y + t)) < z2 * m2 * r * (z2 * q - r)) {
                        a3 = a2 + r / q;
                        y3 = f(a3);
                        if (y3 < y) {
                            x = a3;
                            y = y3;
                        }
                    }
                    k = 1611 * k % 1048576;
                    q = 1.0;
                    r = (b - a) * 0.00001 * k;
                }
            }
            r = m2 * d0 * d1 * d2;
            s = Math.sqrt((y2 - y + t) / m2);
            h = 0.5 * (1.0 + h);
            p = h * (p + 2.0 * r * s);
            q = q + 0.5 * qs;
            r = -0.5 * (d0 + (z0 + 2.01 * e) / (d0 * m2));
            if (r < s || d0 < 0.0) {
                r = a2 + s;
            } else {
                r = a2 + r;
            }
            if (0.0 < p * q) {
                a3 = a2 + p / q;
            } else {
                a3 = r;
            }
            for(;;){
                a3 = Math.max(a3, r);
                if (b <= a3) {
                    a3 = b;
                    y3 = yb;
                } else {
                    y3 = f(a3);
                }
                if (y3 < y) {
                    x = a3;
                    y = y3;
                }
                d0 = a3 - a2;
                if (a3 <= r) {
                    break;
                }
                p = 2.0 * (y2 - y3) / (m * d0);
                if ((1.0 + 9.0 * machep) * d0 <= Math.abs(p)) {
                    break;
                }
                if (0.5 * m2 * (d0 * d0 + p * p) <= y2 - y + (y3 - y) + 2.0 * t) {
                    break;
                }
                a3 = 0.5 * (a2 + a3);
                h = 0.9 * h;
            }
            if (b <= a3) {
                break;
            }
            a0 = sc;
            sc = a2;
            a2 = a3;
            y0 = y1;
            y1 = y2;
            y2 = y3;
        }
        return [
            x,
            y
        ];
    },
    /**
     * Determine all roots of a polynomial with real or complex coefficients by using the
     * iterative method attributed to Weierstrass, Durand, Kerner, Aberth, and Ehrlich. In particular,
     * the iteration method with cubic convergence is used that is usually attributed to Ehrlich-Aberth.
     * <p>
     * The returned roots are sorted with respect to their real values.
     * <p> This method makes use of the JSXGraph classes {@link JXG.Complex} and {@link JXG.C} to handle
     * complex numbers.
     *
     * @param {Array} a Array of coefficients of the polynomial a[0] + a[1]*x+ a[2]*x**2...
     * The coefficients are of type Number or JXG.Complex.
     * @param {Number} [deg] Optional degree of the polynomial. Otherwise all entries are taken, with
     * leading zeros removed.
     * @param {Number} [tol=Number.EPSILON] Approximation tolerance
     * @param {Number} [max_it=30] Maximum number of iterations
     * @param {Array} [initial_values=null] Array of initial values for the roots. If not given,
     * starting values are determined by the method of Ozawa.
     * @returns {Array} Array of complex numbers (of JXG.Complex) approximating the roots of the polynomial.
     * @memberof JXG.Math.Numerics
     * @see JXG.Complex
     * @see JXG.C
     *
     * @example
     * // Polynomial p(z) = -1 + 1z^2
     * var i, roots,
     *     p = [-1, 0, 1];
     *
     * roots = JXG.Math.Numerics.polzeros(p);
     * for (i = 0; i < roots.length; i++) {
     *     console.log(i, roots[i].toString());
     * }
     * // Output:
     *   0 -1 + -3.308722450212111e-24i
     *   1 1 + 0i
     *
     * @example
     * // Polynomial p(z) = -1 + 3z - 9z^2 + z^3 - 8z^6 + 9z^7 - 9z^8 + z^9
     * var i, roots,
     *     p = [-1, 3, -9, 1, 0, 0, -8, 9, -9, 1];
     *
     * roots = JXG.Math.Numerics.polzeros(p);
     * for (i = 0; i < roots.length; i++) {
     *     console.log(i, roots[i].toString());
     * }
     * // Output:
     * 0 -0.7424155888401961 + 0.4950476539211721i
     * 1 -0.7424155888401961 + -0.4950476539211721i
     * 2 0.16674869833354108 + 0.2980502714610669i
     * 3 0.16674869833354108 + -0.29805027146106694i
     * 4 0.21429002063640837 + 1.0682775088132996i
     * 5 0.21429002063640842 + -1.0682775088132999i
     * 6 0.861375497926218 + -0.6259177003583295i
     * 7 0.8613754979262181 + 0.6259177003583295i
     * 8 8.000002743888055 + -1.8367099231598242e-40i
     *
     */ polzeros: function(coeffs, deg, tol, max_it, initial_values) {
        var i, le, off, it, debug = false, cc = [], obvious = [], roots = [], /**
             * Horner method to evaluate polynomial or the derivative thereof for complex numbers,
             * i.e. coefficients and variable are complex.
             * @function
             * @param {Array} a Array of complex coefficients of the polynomial a[0] + a[1]*x+ a[2]*x**2...
             * @param {JXG.Complex} z Value for which the polynomial will be evaluated.
             * @param {Boolean} [derivative=false] If true the derivative will be evaluated.
             * @ignore
             */ hornerComplex = function(a, z, derivative) {
            var i, s, n = a.length - 1;
            derivative = derivative || false;
            if (derivative) {
                // s = n * a_n
                s = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].C.mult(n, a[n]);
                for(i = n - 1; i > 0; i--){
                    // s = s * z + i * a_i
                    s.mult(z);
                    s.add(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].C.mult(a[i], i));
                }
            } else {
                // s = a_n
                s = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].C.copy(a[n]);
                for(i = n - 1; i >= 0; i--){
                    // s = s * z + a_i
                    s.mult(z);
                    s.add(a[i]);
                }
            }
            return s;
        }, /**
             * Horner method to evaluate reciprocal polynomial or the derivative thereof for complex numbers,
             * i.e. coefficients and variable are complex.
             * @function
             * @param {Array} a Array of complex coefficients of the polynomial a[0] + a[1]*x+ a[2]*x**2...
             * @param {JXG.Complex} z Value for which the reciprocal polynomial will be evaluated.
             * @param {Boolean} [derivative=false] If true the derivative will be evaluated.
             * @ignore
             */ hornerRec = function(a, x, derivative) {
            var i, s, n = a.length - 1;
            derivative = derivative || false;
            if (derivative) {
                // s = n * a_0
                s = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].C.mult(n, a[0]);
                for(i = n - 1; i > 0; i--){
                    // s = s * x + i * a_{n-i}
                    s.mult(x);
                    s.add(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].C.mult(a[n - i], i));
                }
            } else {
                // s = a_0
                s = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].C.copy(a[0]);
                for(i = n - 1; i >= 0; i--){
                    // s = s * x + a_{n-i}
                    s.mult(x);
                    s.add(a[n - i]);
                }
            }
            return s;
        }, /**
             * Horner method to evaluate real polynomial at a real value.
             * @function
             * @param {Array} a Array of real coefficients of the polynomial a[0] + a[1]*x+ a[2]*x**2...
             * @param {Number} z Value for which the polynomial will be evaluated.
             * @ignore
             */ horner = function(a, x) {
            var i, s, n = a.length - 1;
            s = a[n];
            for(i = n - 1; i >= 0; i--){
                s = s * x + a[i];
            }
            return s;
        }, /**
             * Determine start values for the Aberth iteration, see
             * Ozawa, "An experimental study of the starting values
             * of the Durand-Kerner-Aberth iteration" (1995).
             *
             * @function
             * @param {Array} a Array of complex coefficients of the polynomial a[0] + a[1]*x+ a[2]*x**2...
             * @returns {Array} Array Initial values for the roots.
             * @ignore
             */ initial_guess = function(a) {
            var i, r, n = a.length - 1, alpha1 = Math.PI * 2 / n, alpha0 = Math.PI / n * 0.5, b, z, init = [];
            // From Ozawa, "An experimental study of the starting values
            // of the Durand-Kerner-Aberth iteration" (1995)
            // b is the arithmetic mean of the roots.
            // With is Vieta's formula <https://en.wikipedia.org/wiki/Vieta%27s_formulas>
            //   b = -a_{n-1} / (n * a_n)
            b = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].C.mult(-1, a[n - 1]);
            b.div(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].C.mult(n, a[n]));
            // r is the geometric mean of the deviations |b - root_i|.
            // Using
            //   p(z) = a_n prod(z - root_i)
            // and therefore
            //   |p(b)| = |a_n| prod(|b - root_i|)
            // we arrive at:
            //   r = |p(b)/a_n|^(1/n)
            z = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].C.div(hornerComplex(a, b), a[n]);
            r = Math.pow(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].C.abs(z), 1 / n);
            if (r === 0) {
                r = 1;
            }
            for(i = 0; i < n; i++){
                a = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Complex(r * Math.cos(alpha1 * i + alpha0), r * Math.sin(alpha1 * i + alpha0));
                init[i] = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].C.add(b, a);
            }
            return init;
        }, /**
             * Ehrlich-Aberth iteration. The stopping criterion is from
             * D.A. Bini, "Numerical computation of polynomial zeros
             * by means of Aberths's method", Numerical Algorithms (1996).
             *
             * @function
             * @param {Array} a Array of complex coefficients of the polynomial a[0] + a[1]*x+ a[2]*x**2...
             * @param {Number} mu Machine precision
             * @param {Number} max_it Maximum number of iterations
             * @param {Array} z Initial guess for the roots. Will be changed in place.
             * @returns {Number} Number of iterations
             * @ignore
             */ aberthIteration = function(cc, mu, max_it, z) {
            var k, i, j, done = [], cr = [], gamma, x, done_sum = 0, num, denom, s, pp, n = z.length;
            for(i = 0; i < n; i++){
                done.push(false);
            }
            for(i = 0; i < cc.length; i++){
                cr.push(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].C.abs(cc[i]) * (4 * i + 1));
            }
            for(k = 0; k < max_it && done_sum < n; k++){
                for(i = 0; i < n; i++){
                    if (done[i]) {
                        continue;
                    }
                    num = hornerComplex(cc, z[i]);
                    x = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].C.abs(z[i]);
                    // Stopping criterion by D.A. Bini
                    // "Numerical computation of polynomial zeros
                    // by means of Aberths's method", Numerical Algorithms (1996).
                    //
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].C.abs(num) < mu * horner(cr, x)) {
                        done[i] = true;
                        done_sum++;
                        if (done_sum === n) {
                            break;
                        }
                        continue;
                    }
                    // num = P(z_i) / P'(z_i)
                    if (x > 1) {
                        gamma = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].C.div(1, z[i]);
                        pp = hornerRec(cc, gamma, true);
                        pp.div(hornerRec(cc, gamma));
                        pp.mult(gamma);
                        num = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].C.sub(n, pp);
                        num = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].C.div(z[i], num);
                    } else {
                        num.div(hornerComplex(cc, z[i], true));
                    }
                    // denom = sum_{i\neq j} 1 / (z_i  - z_j)
                    denom = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Complex(0);
                    for(j = 0; j < n; j++){
                        if (j === i) {
                            continue;
                        }
                        s = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].C.sub(z[i], z[j]);
                        s = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].C.div(1, s);
                        denom.add(s);
                    }
                    // num = num / 1 - num * sum_{i\neq j} 1 / (z_i - z_j)
                    denom.mult(num);
                    denom = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].C.sub(1, denom);
                    num.div(denom);
                    // z_i = z_i - num
                    z[i].sub(num);
                }
            }
            return k;
        };
        tol = tol || Number.EPSILON;
        max_it = max_it || 30;
        le = coeffs.length;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(deg) && deg >= 0 && deg < le - 1) {
            le = deg + 1;
        }
        // Convert coefficient array to complex numbers
        for(i = 0; i < le; i++){
            cc.push(new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Complex(coeffs[i]));
        }
        // Search for (multiple) roots at x=0
        for(i = 0; i < le; i++){
            if (cc[i].real !== 0 || cc[i].imaginary !== 0) {
                off = i;
                break;
            }
        }
        // Deflate root x=0, store roots at x=0 in obvious
        for(i = 0; i < off; i++){
            obvious.push(new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Complex(0));
        }
        cc = cc.slice(off);
        le = cc.length;
        // Remove leading zeros from the coefficient array
        for(i = le - 1; i >= 0; i--){
            if (cc[i].real !== 0 || cc[i].imaginary !== 0) {
                break;
            }
            cc.pop();
        }
        le = cc.length;
        if (le === 0) {
            return [];
        }
        // From now on we can assume that the
        // constant coefficient and the leading coefficient
        // are not zero.
        if (initial_values) {
            for(i = 0; i < le - 1; i++){
                roots.push(new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Complex(initial_values[i]));
            }
        } else {
            roots = initial_guess(cc);
        }
        it = aberthIteration(cc, tol, max_it, roots);
        // Append the roots at x=0
        roots = obvious.concat(roots);
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        // Sort roots according to their real part
        roots.sort(function(a, b) {
            if (a.real < b.real) {
                return -1;
            }
            if (a.real > b.real) {
                return 1;
            }
            return 0;
        });
        return roots;
    },
    /**
     * Implements the Ramer-Douglas-Peucker algorithm.
     * It discards points which are not necessary from the polygonal line defined by the point array
     * pts. The computation is done in screen coordinates.
     * Average runtime is O(nlog(n)), worst case runtime is O(n^2), where n is the number of points.
     * @param {Array} pts Array of {@link JXG.Coords}
     * @param {Number} eps If the absolute value of a given number <tt>x</tt> is smaller than <tt>eps</tt> it is considered to be equal <tt>0</tt>.
     * @returns {Array} An array containing points which represent an apparently identical curve as the points of pts do, but contains fewer points.
     * @memberof JXG.Math.Numerics
     */ RamerDouglasPeucker: function(pts, eps) {
        var allPts = [], newPts = [], i, k, len, endless = true, /**
             * findSplit() is a subroutine of {@link JXG.Math.Numerics.RamerDouglasPeucker}.
             * It searches for the point between index i and j which
             * has the largest distance from the line between the points i and j.
             * @param {Array} pts Array of {@link JXG.Coords}
             * @param {Number} i Index of a point in pts
             * @param {Number} j Index of a point in pts
             * @ignore
             * @private
             */ findSplit = function(pts, i, j) {
            var d, k, ci, cj, ck, x0, y0, x1, y1, den, lbda, eps = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps * __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps, huge = 10000, dist = 0, f = i;
            if (j - i < 2) {
                return [
                    -1.0,
                    0
                ];
            }
            ci = pts[i].scrCoords;
            cj = pts[j].scrCoords;
            if (isNaN(ci[1]) || isNaN(ci[2])) {
                return [
                    NaN,
                    i
                ];
            }
            if (isNaN(cj[1]) || isNaN(cj[2])) {
                return [
                    NaN,
                    j
                ];
            }
            for(k = i + 1; k < j; k++){
                ck = pts[k].scrCoords;
                if (isNaN(ck[1]) || isNaN(ck[2])) {
                    return [
                        NaN,
                        k
                    ];
                }
                x0 = ck[1] - ci[1];
                y0 = ck[2] - ci[2];
                x1 = cj[1] - ci[1];
                y1 = cj[2] - ci[2];
                x0 = x0 === Infinity ? huge : x0;
                y0 = y0 === Infinity ? huge : y0;
                x1 = x1 === Infinity ? huge : x1;
                y1 = y1 === Infinity ? huge : y1;
                x0 = x0 === -Infinity ? -huge : x0;
                y0 = y0 === -Infinity ? -huge : y0;
                x1 = x1 === -Infinity ? -huge : x1;
                y1 = y1 === -Infinity ? -huge : y1;
                den = x1 * x1 + y1 * y1;
                if (den > eps) {
                    lbda = (x0 * x1 + y0 * y1) / den;
                    if (lbda < 0.0) {
                        lbda = 0.0;
                    } else if (lbda > 1.0) {
                        lbda = 1.0;
                    }
                    x0 = x0 - lbda * x1;
                    y0 = y0 - lbda * y1;
                    d = x0 * x0 + y0 * y0;
                } else {
                    lbda = 0.0;
                    d = x0 * x0 + y0 * y0;
                }
                if (d > dist) {
                    dist = d;
                    f = k;
                }
            }
            return [
                Math.sqrt(dist),
                f
            ];
        }, /**
             * RDP() is a private subroutine of {@link JXG.Math.Numerics.RamerDouglasPeucker}.
             * It runs recursively through the point set and searches the
             * point which has the largest distance from the line between the first point and
             * the last point. If the distance from the line is greater than eps, this point is
             * included in our new point set otherwise it is discarded.
             * If it is taken, we recursively apply the subroutine to the point set before
             * and after the chosen point.
             * @param {Array} pts Array of {@link JXG.Coords}
             * @param {Number} i Index of an element of pts
             * @param {Number} j Index of an element of pts
             * @param {Number} eps If the absolute value of a given number <tt>x</tt> is smaller than <tt>eps</tt> it is considered to be equal <tt>0</tt>.
             * @param {Array} newPts Array of {@link JXG.Coords}
             * @ignore
             * @private
             */ RDP = function(pts, i, j, eps, newPts) {
            var result = findSplit(pts, i, j), k = result[1];
            if (isNaN(result[0])) {
                RDP(pts, i, k - 1, eps, newPts);
                newPts.push(pts[k]);
                do {
                    ++k;
                }while (k <= j && isNaN(pts[k].scrCoords[1] + pts[k].scrCoords[2]))
                if (k <= j) {
                    newPts.push(pts[k]);
                }
                RDP(pts, k + 1, j, eps, newPts);
            } else if (result[0] > eps) {
                RDP(pts, i, k, eps, newPts);
                RDP(pts, k, j, eps, newPts);
            } else {
                newPts.push(pts[j]);
            }
        };
        len = pts.length;
        i = 0;
        while(endless){
            // Search for the next point without NaN coordinates
            while(i < len && isNaN(pts[i].scrCoords[1] + pts[i].scrCoords[2])){
                i += 1;
            }
            // Search for the next position of a NaN point
            k = i + 1;
            while(k < len && !isNaN(pts[k].scrCoords[1] + pts[k].scrCoords[2])){
                k += 1;
            }
            k--;
            // Only proceed if something is left
            if (i < len && k > i) {
                newPts = [];
                newPts[0] = pts[i];
                RDP(pts, i, k, eps, newPts);
                allPts = allPts.concat(newPts);
            }
            if (i >= len) {
                break;
            }
            // Push the NaN point
            if (k < len - 1) {
                allPts.push(pts[k + 1]);
            }
            i = k + 1;
        }
        return allPts;
    },
    /**
     * Old name for the implementation of the Ramer-Douglas-Peucker algorithm.
     * @deprecated Use {@link JXG.Math.Numerics.RamerDouglasPeucker}
     * @memberof JXG.Math.Numerics
     */ RamerDouglasPeuker: function(pts, eps) {
        __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].deprecated("Numerics.RamerDouglasPeuker()", "Numerics.RamerDouglasPeucker()");
        return this.RamerDouglasPeucker(pts, eps);
    },
    /**
     * Implements the Visvalingam-Whyatt algorithm.
     * See M. Visvalingam, J. D. Whyatt:
     * "Line generalisation by repeated elimination of the smallest area", C.I.S.R.G Discussion paper 10, July 1992
     *
     * The algorithm discards points which are not necessary from the polygonal line defined by the point array
     * pts (consisting of type JXG.Coords).
     * @param {Array} pts Array of {@link JXG.Coords}
     * @param {Number} numPoints Number of remaining intermediate points. The first and the last point of the original points will
     *    be taken in any case.
     * @returns {Array} An array containing points which approximates the curve defined by pts.
     * @memberof JXG.Math.Numerics
     *
     * @example
     *     var i, p = [];
     *     for (i = 0; i < 5; ++i) {
     *         p.push(board.create('point', [Math.random() * 12 - 6, Math.random() * 12 - 6]));
     *     }
     *
     *     // Plot a cardinal spline curve
     *     var splineArr = JXG.Math.Numerics.CardinalSpline(p, 0.5);
     *     var cu1 = board.create('curve', splineArr, {strokeColor: 'green'});
     *
     *     var c = board.create('curve', [[0],[0]], {strokeWidth: 2, strokeColor: 'black'});
     *     c.updateDataArray = function() {
     *         var i, len, points;
     *
     *         // Reduce number of intermediate points with Visvakingam-Whyatt to 6
     *         points = JXG.Math.Numerics.Visvalingam(cu1.points, 6);
     *         // Plot the remaining points
     *         len = points.length;
     *         this.dataX = [];
     *         this.dataY = [];
     *         for (i = 0; i < len; i++) {
     *             this.dataX.push(points[i].usrCoords[1]);
     *             this.dataY.push(points[i].usrCoords[2]);
     *         }
     *     };
     *     board.update();
     *
     * </pre><div id="JXGce0cc55c-b592-11e6-8270-104a7d3be7eb" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXGce0cc55c-b592-11e6-8270-104a7d3be7eb',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *
     *         var i, p = [];
     *         for (i = 0; i < 5; ++i) {
     *             p.push(board.create('point', [Math.random() * 12 - 6, Math.random() * 12 - 6]));
     *         }
     *
     *         // Plot a cardinal spline curve
     *         var splineArr = JXG.Math.Numerics.CardinalSpline(p, 0.5);
     *         var cu1 = board.create('curve', splineArr, {strokeColor: 'green'});
     *
     *         var c = board.create('curve', [[0],[0]], {strokeWidth: 2, strokeColor: 'black'});
     *         c.updateDataArray = function() {
     *             var i, len, points;
     *
     *             // Reduce number of intermediate points with Visvakingam-Whyatt to 6
     *             points = JXG.Math.Numerics.Visvalingam(cu1.points, 6);
     *             // Plot the remaining points
     *             len = points.length;
     *             this.dataX = [];
     *             this.dataY = [];
     *             for (i = 0; i < len; i++) {
     *                 this.dataX.push(points[i].usrCoords[1]);
     *                 this.dataY.push(points[i].usrCoords[2]);
     *             }
     *         };
     *         board.update();
     *
     *     })();
     *
     * </script><pre>
     *
     */ Visvalingam: function(pts, numPoints) {
        var i, len, vol, lastVol, linkedList = [], heap = [], points = [], lft, rt, lft2, rt2, obj;
        len = pts.length;
        // At least one intermediate point is needed
        if (len <= 2) {
            return pts;
        }
        // Fill the linked list
        // Add first point to the linked list
        linkedList[0] = {
            used: true,
            lft: null,
            node: null
        };
        // Add all intermediate points to the linked list,
        // whose triangle area is nonzero.
        lft = 0;
        for(i = 1; i < len - 1; i++){
            vol = Math.abs(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Math.Numerics.det([
                pts[i - 1].usrCoords,
                pts[i].usrCoords,
                pts[i + 1].usrCoords
            ]));
            if (!isNaN(vol)) {
                obj = {
                    v: vol,
                    idx: i
                };
                heap.push(obj);
                linkedList[i] = {
                    used: true,
                    lft: lft,
                    node: obj
                };
                linkedList[lft].rt = i;
                lft = i;
            }
        }
        // Add last point to the linked list
        linkedList[len - 1] = {
            used: true,
            rt: null,
            lft: lft,
            node: null
        };
        linkedList[lft].rt = len - 1;
        // Remove points until only numPoints intermediate points remain
        lastVol = -Infinity;
        while(heap.length > numPoints){
            // Sort the heap with the updated volume values
            heap.sort(function(a, b) {
                // descending sort
                return b.v - a.v;
            });
            // Remove the point with the smallest triangle
            i = heap.pop().idx;
            linkedList[i].used = false;
            lastVol = linkedList[i].node.v;
            // Update the pointers of the linked list
            lft = linkedList[i].lft;
            rt = linkedList[i].rt;
            linkedList[lft].rt = rt;
            linkedList[rt].lft = lft;
            // Update the values for the volumes in the linked list
            lft2 = linkedList[lft].lft;
            if (lft2 !== null) {
                vol = Math.abs(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Math.Numerics.det([
                    pts[lft2].usrCoords,
                    pts[lft].usrCoords,
                    pts[rt].usrCoords
                ]));
                linkedList[lft].node.v = vol >= lastVol ? vol : lastVol;
            }
            rt2 = linkedList[rt].rt;
            if (rt2 !== null) {
                vol = Math.abs(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Math.Numerics.det([
                    pts[lft].usrCoords,
                    pts[rt].usrCoords,
                    pts[rt2].usrCoords
                ]));
                linkedList[rt].node.v = vol >= lastVol ? vol : lastVol;
            }
        }
        // Return an array with the remaining points
        i = 0;
        points = [
            pts[i]
        ];
        do {
            i = linkedList[i].rt;
            points.push(pts[i]);
        }while (linkedList[i].rt !== null)
        return points;
    }
};
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Numerics;
}),
"[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/geometry.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Andreas Walter,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */ /*global JXG: true, define: true*/ /*jslint nomen: true, plusplus: true*/ /**
 * @fileoverview This file contains the Math.Geometry namespace for calculating algebraic/geometric
 * stuff like intersection points, angles, midpoint, and so on.
 */ __turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/jxg.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/base/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/base/coords.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/math.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$statistics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/statistics.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$numerics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/numerics.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/utils/type.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$expect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/utils/expect.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
/**
 * Math.Geometry namespace definition. This namespace holds geometrical algorithms,
 * especially intersection algorithms.
 * @name JXG.Math.Geometry
 * @exports Mat.Geometry as JXG.Math.Geometry
 * @namespace
 */ __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Geometry = {};
// the splitting is necessary due to the shortcut for the circumcircleMidpoint method to circumcenter.
__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].extend(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Geometry, /** @lends JXG.Math.Geometry */ {
    /* ***************************************/ /* *** GENERAL GEOMETRIC CALCULATIONS ****/ /* ***************************************/ /**
         * Calculates the angle defined by the points A, B, C.
         * @param {JXG.Point|Array} A A point  or [x,y] array.
         * @param {JXG.Point|Array} B Another point or [x,y] array.
         * @param {JXG.Point|Array} C A circle - no, of course the third point or [x,y] array.
         * @deprecated Use {@link JXG.Math.Geometry.rad} instead.
         * @see JXG.Math.Geometry.rad
         * @see JXG.Math.Geometry.trueAngle
         * @returns {Number} The angle in radian measure.
         */ angle: function(A, B, C) {
        var u, v, s, t, a = [], b = [], c = [];
        __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].deprecated("Geometry.angle()", "Geometry.rad()");
        if (A.coords) {
            a[0] = A.coords.usrCoords[1];
            a[1] = A.coords.usrCoords[2];
        } else {
            a[0] = A[0];
            a[1] = A[1];
        }
        if (B.coords) {
            b[0] = B.coords.usrCoords[1];
            b[1] = B.coords.usrCoords[2];
        } else {
            b[0] = B[0];
            b[1] = B[1];
        }
        if (C.coords) {
            c[0] = C.coords.usrCoords[1];
            c[1] = C.coords.usrCoords[2];
        } else {
            c[0] = C[0];
            c[1] = C[1];
        }
        u = a[0] - b[0];
        v = a[1] - b[1];
        s = c[0] - b[0];
        t = c[1] - b[1];
        return Math.atan2(u * t - v * s, u * s + v * t);
    },
    /**
         * Calculates the angle defined by the three points A, B, C if you're going from A to C around B counterclockwise.
         * @param {JXG.Point|Array} A Point or [x,y] array
         * @param {JXG.Point|Array} B Point or [x,y] array
         * @param {JXG.Point|Array} C Point or [x,y] array
         * @see JXG.Math.Geometry.rad
         * @returns {Number} The angle in degrees.
         */ trueAngle: function(A, B, C) {
        return this.rad(A, B, C) * 57.295779513082323; // *180.0/Math.PI;
    },
    /**
         * Calculates the internal angle defined by the three points A, B, C if you're going from A to C around B counterclockwise.
         * @param {JXG.Point|Array} A Point or [x,y] array
         * @param {JXG.Point|Array} B Point or [x,y] array
         * @param {JXG.Point|Array} C Point or [x,y] array
         * @see JXG.Math.Geometry.trueAngle
         * @returns {Number} Angle in radians.
         */ rad: function(A, B, C) {
        var ax, ay, bx, by, cx, cy, phi;
        if (A.coords) {
            ax = A.coords.usrCoords[1];
            ay = A.coords.usrCoords[2];
        } else {
            ax = A[0];
            ay = A[1];
        }
        if (B.coords) {
            bx = B.coords.usrCoords[1];
            by = B.coords.usrCoords[2];
        } else {
            bx = B[0];
            by = B[1];
        }
        if (C.coords) {
            cx = C.coords.usrCoords[1];
            cy = C.coords.usrCoords[2];
        } else {
            cx = C[0];
            cy = C[1];
        }
        phi = Math.atan2(cy - by, cx - bx) - Math.atan2(ay - by, ax - bx);
        if (phi < 0) {
            phi += 6.2831853071795862;
        }
        return phi;
    },
    /**
         * Calculates a point on the bisection line between the three points A, B, C.
         * As a result, the bisection line is defined by two points:
         * Parameter B and the point with the coordinates calculated in this function.
         * Does not work for ideal points.
         * @param {JXG.Point} A Point
         * @param {JXG.Point} B Point
         * @param {JXG.Point} C Point
         * @param [board=A.board] Reference to the board
         * @returns {JXG.Coords} Coordinates of the second point defining the bisection.
         */ angleBisector: function(A, B, C, board) {
        var phiA, phiC, phi, Ac = A.coords.usrCoords, Bc = B.coords.usrCoords, Cc = C.coords.usrCoords, x, y;
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(board)) {
            board = A.board;
        }
        // Parallel lines
        if (Bc[0] === 0) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
                1,
                (Ac[1] + Cc[1]) * 0.5,
                (Ac[2] + Cc[2]) * 0.5
            ], board);
        }
        // Non-parallel lines
        x = Ac[1] - Bc[1];
        y = Ac[2] - Bc[2];
        phiA = Math.atan2(y, x);
        x = Cc[1] - Bc[1];
        y = Cc[2] - Bc[2];
        phiC = Math.atan2(y, x);
        phi = (phiA + phiC) * 0.5;
        if (phiA > phiC) {
            phi += Math.PI;
        }
        x = Math.cos(phi) + Bc[1];
        y = Math.sin(phi) + Bc[2];
        return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
            1,
            x,
            y
        ], board);
    },
    // /**
    //  * Calculates a point on the m-section line between the three points A, B, C.
    //  * As a result, the m-section line is defined by two points:
    //  * Parameter B and the point with the coordinates calculated in this function.
    //  * The m-section generalizes the bisector to any real number.
    //  * For example, the trisectors of an angle are simply the 1/3-sector and the 2/3-sector.
    //  * Does not work for ideal points.
    //  * @param {JXG.Point} A Point
    //  * @param {JXG.Point} B Point
    //  * @param {JXG.Point} C Point
    //  * @param {Number} m Number
    //  * @param [board=A.board] Reference to the board
    //  * @returns {JXG.Coords} Coordinates of the second point defining the bisection.
    //  */
    // angleMsector: function (A, B, C, m, board) {
    //     var phiA, phiC, phi,
    //         Ac = A.coords.usrCoords,
    //         Bc = B.coords.usrCoords,
    //         Cc = C.coords.usrCoords,
    //         x, y;
    //     if (!Type.exists(board)) {
    //         board = A.board;
    //     }
    //     // Parallel lines
    //     if (Bc[0] === 0) {
    //         return new Coords(Const.COORDS_BY_USER,
    //             [1, (Ac[1] + Cc[1]) * m, (Ac[2] + Cc[2]) * m], board);
    //     }
    //     // Non-parallel lines
    //     x = Ac[1] - Bc[1];
    //     y = Ac[2] - Bc[2];
    //     phiA =  Math.atan2(y, x);
    //     x = Cc[1] - Bc[1];
    //     y = Cc[2] - Bc[2];
    //     phiC =  Math.atan2(y, x);
    //     phi = phiA + ((phiC - phiA) * m);
    //     if (phiA - phiC > Math.PI) {
    //         phi += 2*m*Math.PI;
    //     }
    //     x = Math.cos(phi) + Bc[1];
    //     y = Math.sin(phi) + Bc[2];
    //     return new Coords(Const.COORDS_BY_USER, [1, x, y], board);
    // },
    /**
         * Reflects the point along the line.
         * @param {JXG.Line} line Axis of reflection.
         * @param {JXG.Point} point Point to reflect.
         * @param [board=point.board] Reference to the board
         * @returns {JXG.Coords} Coordinates of the reflected point.
         */ reflection: function(line, point, board) {
        // (v,w) defines the slope of the line
        var x0, y0, x1, y1, v, w, mu, pc = point.coords.usrCoords, p1c = line.point1.coords.usrCoords, p2c = line.point2.coords.usrCoords;
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(board)) {
            board = point.board;
        }
        v = p2c[1] - p1c[1];
        w = p2c[2] - p1c[2];
        x0 = pc[1] - p1c[1];
        y0 = pc[2] - p1c[2];
        mu = (v * y0 - w * x0) / (v * v + w * w);
        // point + mu*(-y,x) is the perpendicular foot
        x1 = pc[1] + 2 * mu * w;
        y1 = pc[2] - 2 * mu * v;
        return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
            x1,
            y1
        ], board);
    },
    /**
         * Computes the new position of a point which is rotated
         * around a second point (called rotpoint) by the angle phi.
         * @param {JXG.Point} rotpoint Center of the rotation
         * @param {JXG.Point} point point to be rotated
         * @param {Number} phi rotation angle in arc length
         * @param {JXG.Board} [board=point.board] Reference to the board
         * @returns {JXG.Coords} Coordinates of the new position.
         */ rotation: function(rotpoint, point, phi, board) {
        var x0, y0, c, s, x1, y1, pc = point.coords.usrCoords, rotpc = rotpoint.coords.usrCoords;
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(board)) {
            board = point.board;
        }
        x0 = pc[1] - rotpc[1];
        y0 = pc[2] - rotpc[2];
        c = Math.cos(phi);
        s = Math.sin(phi);
        x1 = x0 * c - y0 * s + rotpc[1];
        y1 = x0 * s + y0 * c + rotpc[2];
        return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
            x1,
            y1
        ], board);
    },
    /**
         * Calculates the coordinates of a point on the perpendicular to the given line through
         * the given point.
         * @param {JXG.Line} line A line.
         * @param {JXG.Point} point Point which is projected to the line.
         * @param {JXG.Board} [board=point.board] Reference to the board
         * @returns {Array} Array of length two containing coordinates of a point on the perpendicular to the given line
         *                  through the given point and boolean flag "change".
         */ perpendicular: function(line, point, board) {
        var x, y, change, c, z, A = line.point1.coords.usrCoords, B = line.point2.coords.usrCoords, C = point.coords.usrCoords;
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(board)) {
            board = point.board;
        }
        // special case: point is the first point of the line
        if (point === line.point1) {
            x = A[1] + B[2] - A[2];
            y = A[2] - B[1] + A[1];
            z = A[0] * B[0];
            if (Math.abs(z) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
                x = B[2];
                y = -B[1];
            }
            c = [
                z,
                x,
                y
            ];
            change = true;
        // special case: point is the second point of the line
        } else if (point === line.point2) {
            x = B[1] + A[2] - B[2];
            y = B[2] - A[1] + B[1];
            z = A[0] * B[0];
            if (Math.abs(z) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
                x = A[2];
                y = -A[1];
            }
            c = [
                z,
                x,
                y
            ];
            change = false;
        // special case: point lies somewhere else on the line
        } else if (Math.abs(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].innerProduct(C, line.stdform, 3)) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
            x = C[1] + B[2] - C[2];
            y = C[2] - B[1] + C[1];
            z = B[0];
            if (Math.abs(z) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
                x = B[2];
                y = -B[1];
            }
            change = true;
            if (Math.abs(z) > __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps && Math.abs(x - C[1]) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps && Math.abs(y - C[2]) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
                x = C[1] + A[2] - C[2];
                y = C[2] - A[1] + C[1];
                change = false;
            }
            c = [
                z,
                x,
                y
            ];
        // general case: point does not lie on the line
        // -> calculate the foot of the dropped perpendicular
        } else {
            c = [
                0,
                line.stdform[1],
                line.stdform[2]
            ];
            c = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].crossProduct(c, C); // perpendicuar to line
            c = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].crossProduct(c, line.stdform); // intersection of line and perpendicular
            change = true;
        }
        return [
            new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, c, board),
            change
        ];
    },
    /**
         * @deprecated Please use {@link JXG.Math.Geometry.circumcenter} instead.
         */ circumcenterMidpoint: function() {
        __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].deprecated("Geometry.circumcenterMidpoint()", "Geometry.circumcenter()");
        this.circumcenter.apply(this, arguments);
    },
    /**
         * Calculates the center of the circumcircle of the three given points.
         * @param {JXG.Point} point1 Point
         * @param {JXG.Point} point2 Point
         * @param {JXG.Point} point3 Point
         * @param {JXG.Board} [board=point1.board] Reference to the board
         * @returns {JXG.Coords} Coordinates of the center of the circumcircle of the given points.
         */ circumcenter: function(point1, point2, point3, board) {
        var u, v, m1, m2, A = point1.coords.usrCoords, B = point2.coords.usrCoords, C = point3.coords.usrCoords;
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(board)) {
            board = point1.board;
        }
        u = [
            B[0] - A[0],
            -B[2] + A[2],
            B[1] - A[1]
        ];
        v = [
            (A[0] + B[0]) * 0.5,
            (A[1] + B[1]) * 0.5,
            (A[2] + B[2]) * 0.5
        ];
        m1 = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].crossProduct(u, v);
        u = [
            C[0] - B[0],
            -C[2] + B[2],
            C[1] - B[1]
        ];
        v = [
            (B[0] + C[0]) * 0.5,
            (B[1] + C[1]) * 0.5,
            (B[2] + C[2]) * 0.5
        ];
        m2 = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].crossProduct(u, v);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].crossProduct(m1, m2), board);
    },
    /**
         * Calculates the Euclidean distance for two given arrays of the same length.
         * @param {Array} array1 Array of Number
         * @param {Array} array2 Array of Number
         * @param {Number} [n] Length of the arrays. Default is the minimum length of the given arrays.
         * @returns {Number} Euclidean distance of the given vectors.
         */ distance: function(array1, array2, n) {
        var i, sum = 0;
        if (!n) {
            n = Math.min(array1.length, array2.length);
        }
        for(i = 0; i < n; i++){
            sum += (array1[i] - array2[i]) * (array1[i] - array2[i]);
        }
        return Math.sqrt(sum);
    },
    /**
         * Calculates Euclidean distance for two given arrays of the same length.
         * If one of the arrays contains a zero in the first coordinate, and the Euclidean distance
         * is different from zero it is a point at infinity and we return Infinity.
         * @param {Array} array1 Array containing elements of type number.
         * @param {Array} array2 Array containing elements of type number.
         * @param {Number} [n] Length of the arrays. Default is the minimum length of the given arrays.
         * @returns {Number} Euclidean (affine) distance of the given vectors.
         */ affineDistance: function(array1, array2, n) {
        var d;
        d = this.distance(array1, array2, n);
        if (d > __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps && (Math.abs(array1[0]) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps || Math.abs(array2[0]) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps)) {
            return Infinity;
        }
        return d;
    },
    /**
         * Affine ratio of three collinear points a, b, c: (c - a) / (b - a).
         * If r > 1 or r < 0 then c is outside of the segment ab.
         *
         * @param {Array|JXG.Coords} a
         * @param {Array|JXG.Coords} b
         * @param {Array|JXG.Coords} c
         * @returns {Number} affine ratio (c - a) / (b - a)
         */ affineRatio: function(a, b, c) {
        var r = 0.0, dx;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(a.usrCoords)) {
            a = a.usrCoords;
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(b.usrCoords)) {
            b = b.usrCoords;
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(c.usrCoords)) {
            c = c.usrCoords;
        }
        dx = b[1] - a[1];
        if (Math.abs(dx) > __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
            r = (c[1] - a[1]) / dx;
        } else {
            r = (c[2] - a[2]) / (b[2] - a[2]);
        }
        return r;
    },
    /**
         * Sort vertices counter clockwise starting with the first point.
         * Used in Polygon.sutherlandHodgman, Geometry.signedPolygon.
         *
         * @param {Array} p An array containing {@link JXG.Point}, {@link JXG.Coords}, and/or arrays.
         *
         * @returns {Array}
         */ sortVertices: function(p) {
        var ll, ps = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$expect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].each(p, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$expect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].coordsArray), N = ps.length, lastPoint = null;
        // If the last point equals the first point, we take the last point out of the array.
        // It may be that the several points at the end of the array are equal to the first point.
        // The polygonal chain is been closed by JSXGraph, but this may also have been done by the user.
        // Therefore, we use a while loop to pop the last points.
        while(ps[0][0] === ps[N - 1][0] && ps[0][1] === ps[N - 1][1] && ps[0][2] === ps[N - 1][2]){
            lastPoint = ps.pop();
            N--;
        }
        ll = ps[0];
        // Sort ps in increasing order of the angle between a point and the first point ll.
        // If a point is equal to the first point ll, the angle is defined to be -Infinity.
        // Otherwise, atan2 would return zero, which is a value which also attained by points
        // on the same horizontal line.
        ps.sort(function(a, b) {
            var rad1 = a[2] === ll[2] && a[1] === ll[1] ? -Infinity : Math.atan2(a[2] - ll[2], a[1] - ll[1]), rad2 = b[2] === ll[2] && b[1] === ll[1] ? -Infinity : Math.atan2(b[2] - ll[2], b[1] - ll[1]);
            return rad1 - rad2;
        });
        // If the last point has been taken out of the array, we put it in again.
        if (lastPoint !== null) {
            ps.push(lastPoint);
        }
        return ps;
    },
    /**
         * Signed triangle area of the three points given. It can also be used
         * to test the orientation of the triangle.
         * <ul>
         * <li> If the return value is < 0, then the point p2 is left of the line [p1, p3] (i.e p3 is right from [p1, p2]).
         * <li> If the return value is > 0, then the point p2 is right of the line [p1, p3] (i.e p3 is left from [p1, p2]).
         * <li> If the return value is = 0, then the points p1, p2, p3 are collinear.
         * </ul>
         *
         * @param {JXG.Point|JXG.Coords|Array} p1
         * @param {JXG.Point|JXG.Coords|Array} p2
         * @param {JXG.Point|JXG.Coords|Array} p3
         *
         * @returns {Number}
         */ signedTriangle: function(p1, p2, p3) {
        var A = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$expect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].coordsArray(p1), B = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$expect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].coordsArray(p2), C = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$expect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].coordsArray(p3);
        return 0.5 * ((B[1] - A[1]) * (C[2] - A[2]) - (B[2] - A[2]) * (C[1] - A[1]));
    },
    /**
         * Determine the signed area of a non-self-intersecting polygon.
         * Surveyor's Formula
         *
         * @param {Array} p An array containing {@link JXG.Point}, {@link JXG.Coords}, and/or arrays.
         * @param {Boolean} [sort=true]
         *
         * @returns {Number}
         */ signedPolygon: function(p, sort) {
        var i, N, A = 0, ps = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$expect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].each(p, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$expect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].coordsArray);
        if (sort === undefined) {
            sort = true;
        }
        if (!sort) {
            ps = this.sortVertices(ps);
        } else {
            // Make sure the polygon is closed. If it is already closed this won't change the sum because the last
            // summand will be 0.
            ps.unshift(ps[ps.length - 1]);
        }
        N = ps.length;
        for(i = 1; i < N; i++){
            A += ps[i - 1][1] * ps[i][2] - ps[i][1] * ps[i - 1][2];
        }
        return 0.5 * A;
    },
    /**
         * Calculate the complex hull of a point cloud by the Graham scan algorithm.
         *
         * @param {Array} points An array containing {@link JXG.Point}, {@link JXG.Coords}, and/or arrays.
         *
         * @returns {Array} List of objects <pre>{i: index, c: coords}</pre> containing the convex hull points
         *  in form of the index in the original input array and a coords array.
         *
         * @example
         *     // Static example
         *
         *     var i, hull,
         *       p = [],
         *       q = [];
         *
         *     p.push( board.create('point', [4, 0], {withLabel:false }) );
         *     p.push( board.create('point', [0, 4], {withLabel:false }) );
         *     p.push( board.create('point', [0, 0], {withLabel:false }) );
         *     p.push([-1, 0]);
         *     p.push([-3, -3]);
         *
         *     hull = JXG.Math.Geometry.GrahamScan(p);
         *     for (i = 0; i < hull.length; i++) {
         *       console.log(hull[i]);
         *       q.push(hull[i].c);
         *     }
         *     board.create('polygon', q);
         *     // Output:
         *     // { i: 4, c: [1, -3, 3]}
         *     // { i: 0, c: [1, 4, 0]}
         *     // { i: 1, c: [1, 0, 4]}
         *
         * </pre><div id="JXGb310b874-595e-4020-b0c2-566482797836" class="jxgbox" style="width: 300px; height: 300px;"></div>
         * <script type="text/javascript">
         *     (function() {
         *         var board = JXG.JSXGraph.initBoard('JXGb310b874-595e-4020-b0c2-566482797836',
         *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
         *         var i, hull,
         *           p = [],
         *           q = [];
         *
         *         p.push( board.create('point', [4, 0], {withLabel:false }) );
         *         p.push( board.create('point', [0, 4], {withLabel:false }) );
         *         p.push( board.create('point', [0, 0], {withLabel:false }) );
         *         p.push([-1, 0]);
         *         p.push([-3, -3]);
         *
         *         hull = JXG.Math.Geometry.GrahamScan(p);
         *         for (i = 0; i < hull.length; i++) {
         *           console.log(hull[i]);
         *           q.push(hull[i].c);
         *         }
         *         board.create('polygon', q);
         *
         *     })();
         *
         * </script><pre>
         *
         */ GrahamScan: function(points) {
        var i, M, o, mi_idx, mi_x, mi_y, ma_x, ma_y, mi_xpy, mi_xmy, ma_xpy, ma_xmy, mi_x_i, ma_x_i, mi_y_i, ma_y_i, mi_xpy_i, mi_xmy_i, ma_xpy_i, ma_xmy_i, v, c, eps = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps * __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps, that = this, ps_idx = [], stack = [], ps = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$expect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].each(points, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$expect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].coordsArray), N, AklToussaint = 1024; // This is a rough threshold where the heuristic pays off.
        N = ps.length;
        if (N === 0) {
            return [];
        }
        if (N > AklToussaint) {
            //
            // Akl-Toussaint heuristic
            // Determine an irregular convex octagon whose inside can be discarded.
            //
            mi_x = ps[0][1];
            ma_x = mi_x;
            mi_y = ps[0][2];
            ma_y = mi_y;
            mi_xmy = ps[0][1] - ps[0][2];
            ma_xmy = mi_xmy;
            mi_xpy = ps[0][1] + ps[0][2];
            ma_xpy = mi_xpy;
            mi_x_i = 0;
            ma_x_i = 0;
            mi_y_i = 0;
            ma_y_i = 0;
            mi_xmy_i = 0;
            ma_xmy_i = 0;
            mi_xpy_i = 0;
            ma_xpy_i = 0;
            for(i = 1; i < N; i++){
                v = ps[i][1];
                if (v < mi_x) {
                    mi_x = v;
                    mi_x_i = i;
                } else if (v > ma_x) {
                    ma_x = v;
                    ma_x_i = i;
                }
                v = ps[i][2];
                if (v < mi_y) {
                    mi_y = v;
                    mi_y_i = i;
                } else if (v > ma_y) {
                    ma_y = v;
                    ma_y_i = i;
                }
                v = ps[i][1] - ps[i][2];
                if (v < mi_xmy) {
                    mi_xmy = v;
                    mi_xmy_i = i;
                } else if (v > ma_xmy) {
                    ma_xmy = v;
                    ma_xmy_i = i;
                }
                v = ps[i][1] + ps[i][2];
                if (v < mi_xpy) {
                    mi_xpy = v;
                    mi_xpy_i = i;
                } else if (v > ma_xpy) {
                    ma_xpy = v;
                    ma_xpy_i = i;
                }
            }
        }
        // Keep track of the indices of the input points.
        for(i = 0; i < N; i++){
            c = ps[i];
            if (N <= AklToussaint || // Discard inside of the octagon according to the Akl-Toussaint heuristic
            i in [
                mi_x_i,
                ma_x_i,
                mi_y_i,
                ma_y_i,
                mi_xpy_i,
                mi_xmy_i,
                ma_xpy_i,
                ma_xmy_i
            ] || mi_x_i !== mi_xmy_i && this.signedTriangle(ps[mi_x_i], ps[mi_xmy_i], c) >= -eps || mi_xmy_i !== ma_y_i && this.signedTriangle(ps[mi_xmy_i], ps[ma_y_i], c) >= -eps || ma_y_i !== ma_xpy_i && this.signedTriangle(ps[ma_y_i], ps[ma_xpy_i], c) >= -eps || ma_xpy_i !== ma_x_i && this.signedTriangle(ps[ma_xpy_i], ps[ma_x_i], c) >= -eps || ma_x_i !== ma_xmy_i && this.signedTriangle(ps[ma_x_i], ps[ma_xmy_i], c) >= -eps || ma_xmy_i !== mi_y_i && this.signedTriangle(ps[ma_xmy_i], ps[mi_y_i], c) >= -eps || mi_y_i !== mi_xpy_i && this.signedTriangle(ps[mi_y_i], ps[mi_xpy_i], c) >= -eps || mi_xpy_i !== mi_x_i && this.signedTriangle(ps[mi_xpy_i], ps[mi_x_i], c) >= -eps) {
                ps_idx.push({
                    i: i,
                    c: c
                });
            }
        }
        N = ps_idx.length;
        // Find the point with the lowest y value
        mi_idx = 0;
        mi_x = ps_idx[0].c[1];
        mi_y = ps_idx[0].c[2];
        for(i = 1; i < N; i++){
            if (ps_idx[i].c[2] < mi_y || ps_idx[i].c[2] === mi_y && ps_idx[i].c[1] < mi_x) {
                mi_x = ps_idx[i].c[1];
                mi_y = ps_idx[i].c[2];
                mi_idx = i;
            }
        }
        ps_idx = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].swap(ps_idx, mi_idx, 0);
        // Our origin o, i.e. the first point.
        o = ps_idx[0].c;
        // Sort according to the angle around o.
        ps_idx.sort(function(a_obj, b_obj) {
            var a = a_obj.c, b = b_obj.c, v = that.signedTriangle(o, a, b);
            if (v === 0) {
                // if o, a, b are collinear, the point which is further away
                // from o is considered greater.
                return __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].hypot(a[1] - o[1], a[2] - o[2]) - __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].hypot(b[1] - o[1], b[2] - o[2]);
            }
            // if v < 0, a is to the left of [o, b], i.e. angle(a) > angle(b)
            return -v;
        });
        // Do the Graham scan.
        M = 0;
        for(i = 0; i < N; i++){
            while(M > 1 && this.signedTriangle(stack[M - 2].c, stack[M - 1].c, ps_idx[i].c) <= 0){
                // stack[M - 1] is to the left of stack[M - 1], ps[i]: discard it
                stack.pop();
                M--;
            }
            stack.push(ps_idx[i]);
            M++;
        }
        return stack;
    },
    // Original method
    // GrahamScan: function (points, indices) {
    //     var i,
    //         M = 1,
    //         ps = Expect.each(points, Expect.coordsArray),
    //         N = ps.length;
    //     ps = this.sortVertices(ps);
    //     N = ps.length;
    //     for (i = 2; i < N; i++) {
    //         while (this.signedTriangle(ps[M - 1], ps[M], ps[i]) <= 0) {
    //             if (M > 1) {
    //                 M -= 1;
    //             } else if (i === N - 1) {
    //                 break;
    //             }
    //             i += 1;
    //         }
    //         M += 1;
    //         ps = Type.swap(ps, M, i);
    //         indices = Type.swap(indices, M, i);
    //     }
    //     return ps.slice(0, M);
    // },
    /**
         * Calculate the complex hull of a point cloud by the Graham scan algorithm.
         *
         * @param {Array} points An array containing {@link JXG.Point}, {@link JXG.Coords}, and/or arrays.
         * @param {Boolean} [returnCoords=false] If true, return an array of coords. Otherwise return a list of pointers
         * to the input list elements. That is, if the input is a list of {@link JXG.Point} elements, the returned list
         * will contain the points that form the convex hull.
         * @returns {Array} List containing the convex hull. Format depends on returnCoords.
         * @see JXG.Math.Geometry.GrahamScan
         *
         * @example
         *     // Static example
         *     var i, hull,
         *         p = [];
         *
         *     p.push( board.create('point', [4, 0], {withLabel:false }) );
         *     p.push( board.create('point', [0, 4], {withLabel:false }) );
         *     p.push( board.create('point', [0, 0], {withLabel:false }) );
         *     p.push( board.create('point', [1, 1], {withLabel:false }) );
         *     hull = JXG.Math.Geometry.convexHull(p);
         *     for (i = 0; i < hull.length; i++) {
         *       hull[i].setAttribute({color: 'blue'});
         *     }
         *
         * </pre><div id="JXGdfc76123-81b8-4250-96f9-419253bd95dd" class="jxgbox" style="width: 300px; height: 300px;"></div>
         * <script type="text/javascript">
         *     (function() {
         *         var board = JXG.JSXGraph.initBoard('JXGdfc76123-81b8-4250-96f9-419253bd95dd',
         *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
         *         var i, hull,
         *             p = [];
         *
         *         p.push( board.create('point', [4, 0], {withLabel:false }) );
         *         p.push( board.create('point', [0, 4], {withLabel:false }) );
         *         p.push( board.create('point', [0, 0], {withLabel:false }) );
         *         p.push( board.create('point', [1, 1], {withLabel:false }) );
         *         hull = JXG.Math.Geometry.convexHull(p);
         *         for (i = 0; i < hull.length; i++) {
         *           hull[i].setAttribute({color: 'blue'});
         *         }
         *
         *     })();
         *
         * </script><pre>
         *
         * @example
         *     // Dynamic version using returnCoords==true: drag the points
         *     var p = [];
         *
         *     p.push( board.create('point', [4, 0], {withLabel:false }) );
         *     p.push( board.create('point', [0, 4], {withLabel:false }) );
         *     p.push( board.create('point', [0, 0], {withLabel:false }) );
         *     p.push( board.create('point', [1, 1], {withLabel:false }) );
         *
         *     var c = board.create('curve', [[], []], {fillColor: 'yellow', fillOpacity: 0.3});
         *     c.updateDataArray = function() {
         *       var i,
         *         hull = JXG.Math.Geometry.convexHull(p, true);
         *
         *       this.dataX = [];
         *       this.dataY = [];
         *
         *       for (i = 0; i < hull.length; i ++) {
         *         this.dataX.push(hull[i][1]);
         *         this.dataY.push(hull[i][2]);
         *       }
         *       this.dataX.push(hull[0][1]);
         *       this.dataY.push(hull[0][2]);
         *     };
         *     board.update();
         *
         * </pre><div id="JXG61e51909-da0b-432f-9aa7-9fb0c8bb01c9" class="jxgbox" style="width: 300px; height: 300px;"></div>
         * <script type="text/javascript">
         *     (function() {
         *         var board = JXG.JSXGraph.initBoard('JXG61e51909-da0b-432f-9aa7-9fb0c8bb01c9',
         *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
         *         var p = [];
         *
         *         p.push( board.create('point', [4, 0], {withLabel:false }) );
         *         p.push( board.create('point', [0, 4], {withLabel:false }) );
         *         p.push( board.create('point', [0, 0], {withLabel:false }) );
         *         p.push( board.create('point', [1, 1], {withLabel:false }) );
         *
         *         var c = board.create('curve', [[], []], {fillColor: 'yellow', fillOpacity: 0.3});
         *         c.updateDataArray = function() {
         *           var i,
         *             hull = JXG.Math.Geometry.convexHull(p, true);
         *
         *           this.dataX = [];
         *           this.dataY = [];
         *
         *           for (i = 0; i < hull.length; i ++) {
         *             this.dataX.push(hull[i][1]);
         *             this.dataY.push(hull[i][2]);
         *           }
         *           this.dataX.push(hull[0][1]);
         *           this.dataY.push(hull[0][2]);
         *         };
         *         board.update();
         *
         *
         *     })();
         *
         * </script><pre>
         *
         */ convexHull: function(points, returnCoords) {
        var i, hull, res = [];
        hull = this.GrahamScan(points);
        for(i = 0; i < hull.length; i++){
            if (returnCoords) {
                res.push(hull[i].c);
            } else {
                res.push(points[hull[i].i]);
            }
        }
        return res;
    },
    // /**
    //  * Determine if a polygon or a path element is convex, non-convex or complex which are defined like this:
    //  * <ul>
    //  * <li> A polygon is convex if for every pair of points, the line segment connecting them does not intersect
    //  * an edge of the polygon in one point.
    //  * A single line segment or a a single point is considered as convex. A necessary condition for a polygon
    //  * to be convex that the angle sum of its interior angles equals &plusmn; 2 &pi;.
    //  * <li> A polygon is non-convex, if it does not self-intersect, but is not convex.
    //  * <li> A polygon is complex if its the angle sum is not equal to &plusmn; 2 &pi;.
    //  * That is, there must be self-intersection (contiguous coincident points in the path are not treated as self-intersection).
    //  * </ul>
    //  * A path  element might be specified as an array of coordinate arrays or {@link JXG.Coords}.
    //  *
    //  * @param {Array|Polygon|PolygonalChain} points Polygon or list of coordinates
    //  * @returns {Number} -1: if complex, 0: if non-convex, 1: if convex
    //  */
    /**
         * Determine if a polygon or a path element is convex:
         * <p>
         * A polygon is convex if for every pair of points, the line segment connecting them does not intersect
         * an edge of the polygon in one point.
         * A single line segment, a single point, or the empty set is considered as convex. A necessary condition for a polygon
         * to be convex that the angle sum of its interior angles equals &plusmn; 2 &pi;.
         * <p>
         * A path  element might be specified as an array of coordinate arrays or {@link JXG.Coords}.
         * See the discussion at <a href="https://stackoverflow.com/questions/471962/how-do-i-efficiently-determine-if-a-polygon-is-convex-non-convex-or-complex">stackoverflow</a>.
         *
         * @param {Array|Polygon|PolygonalChain} points Polygon or list of coordinates
         * @returns {Boolean} true if convex
         *
         * @example
         * var pol = board.create('polygon', [
         *     [-1, -1],
         *     [3, -1],
         *     [4, 2],
         *     [3, 3],
         *     [0, 4],
         *     [-3, 1]
         * ], {
         *     vertices: {
         *         color: 'blue',
         *         snapToGrid: true
         *     }
         * });
         *
         * console.log(JXG.Math.Geometry.isConvex(pol));
         * // > true
         *
         *
         *
         * </pre><div id="JXG9b43cc53-15b4-49be-92cc-2a1dfc06665b" class="jxgbox" style="width: 300px; height: 300px;"></div>
         * <script type="text/javascript">
         *     (function() {
         *         var board = JXG.JSXGraph.initBoard('JXG9b43cc53-15b4-49be-92cc-2a1dfc06665b',
         *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
         *     var pol = board.create('polygon', [
         *         [-1, -1],
         *         [3, -1],
         *         [4, 2],
         *         [3, 3],
         *         [0, 4],
         *         [-3, 1]
         *     ], {
         *         vertices: {
         *             color: 'blue',
         *             snapToGrid: true
         *         }
         *     });
         *
         *     console.log(JXG.Math.Geometry.isConvex(pol));
         *
         *
         *
         *     })();
         *
         * </script><pre>
         *
         */ isConvex: function(points) {
        var ps, le, i, eps = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps * __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps, old_x, old_y, old_dir, new_x, new_y, new_dir, angle, orient, angle_sum = 0.0;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(points)) {
            ps = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$expect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].each(points, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$expect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].coordsArray);
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(points.type) && points.type === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_TYPE_POLYGON) {
            ps = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$expect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].each(points.vertices, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$expect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].coordsArray);
        }
        le = ps.length;
        if (le === 0) {
            // Empty set is convex
            return true;
        }
        if (le < 3) {
            // Segments and points are convex
            return true;
        }
        orient = null;
        old_x = ps[le - 2][1];
        old_y = ps[le - 2][2];
        new_x = ps[le - 1][1];
        new_y = ps[le - 1][2];
        new_dir = Math.atan2(new_y - old_y, new_x - old_x);
        for(i = 0; i < le; i++){
            old_x = new_x;
            old_y = new_y;
            old_dir = new_dir;
            new_x = ps[i][1];
            new_y = ps[i][2];
            if (old_x === new_x && old_y === new_y) {
                continue;
            }
            new_dir = Math.atan2(new_y - old_y, new_x - old_x);
            angle = new_dir - old_dir;
            if (angle <= -Math.PI) {
                angle += 2 * Math.PI;
            } else if (angle > Math.PI) {
                angle -= 2 * Math.PI;
            }
            if (orient === null) {
                if (angle === 0.0) {
                    continue;
                }
                orient = angle > 0 ? 1 : -1;
            } else {
                if (orient * angle < -eps) {
                    return false;
                }
            }
            angle_sum += angle;
        }
        if (Math.abs(angle_sum / (2 * Math.PI)) - 1 < eps) {
            return true;
        }
        return false;
    },
    /**
         * A line can be a segment, a straight, or a ray. So it is not always delimited by point1 and point2
         * calcStraight determines the visual start point and end point of the line. A segment is only drawn
         * from start to end point, a straight line is drawn until it meets the boards boundaries.
         * @param {JXG.Line} el Reference to a line object, that needs calculation of start and end point.
         * @param {JXG.Coords} point1 Coordinates of the point where line drawing begins. This value is calculated and
         * set by this method.
         * @param {JXG.Coords} point2 Coordinates of the point where line drawing ends. This value is calculated and set
         * by this method.
         * @param {Number} margin Optional margin, to avoid the display of the small sides of lines.
         * @returns null
         * @see Line
         * @see JXG.Line
         */ calcStraight: function(el, point1, point2, margin) {
        var takePoint1, takePoint2, intersection, intersect1, intersect2, straightFirst, straightLast, c, p1, p2;
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(margin)) {
            // Enlarge the drawable region slightly. This hides the small sides
            // of thick lines in most cases.
            margin = 10;
        }
        straightFirst = el.evalVisProp('straightfirst');
        straightLast = el.evalVisProp('straightlast');
        // If one of the point is an ideal point in homogeneous coordinates
        // drawing of line segments or rays are not possible.
        if (Math.abs(point1.scrCoords[0]) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
            straightFirst = true;
        }
        if (Math.abs(point2.scrCoords[0]) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
            straightLast = true;
        }
        // Do nothing in case of line segments (inside or outside of the board)
        if (!straightFirst && !straightLast) {
            return;
        }
        // Compute the stdform of the line in screen coordinates.
        c = [];
        c[0] = el.stdform[0] - el.stdform[1] * el.board.origin.scrCoords[1] / el.board.unitX + el.stdform[2] * el.board.origin.scrCoords[2] / el.board.unitY;
        c[1] = el.stdform[1] / el.board.unitX;
        c[2] = -el.stdform[2] / el.board.unitY;
        // If p1=p2
        if (isNaN(c[0] + c[1] + c[2])) {
            return;
        }
        takePoint1 = false;
        takePoint2 = false;
        // Line starts at point1 and point1 is inside the board
        takePoint1 = !straightFirst && Math.abs(point1.usrCoords[0]) >= __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps && point1.scrCoords[1] >= 0.0 && point1.scrCoords[1] <= el.board.canvasWidth && point1.scrCoords[2] >= 0.0 && point1.scrCoords[2] <= el.board.canvasHeight;
        // Line ends at point2 and point2 is inside the board
        takePoint2 = !straightLast && Math.abs(point2.usrCoords[0]) >= __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps && point2.scrCoords[1] >= 0.0 && point2.scrCoords[1] <= el.board.canvasWidth && point2.scrCoords[2] >= 0.0 && point2.scrCoords[2] <= el.board.canvasHeight;
        // Intersect the line with the four borders of the board.
        intersection = this.meetLineBoard(c, el.board, margin);
        intersect1 = intersection[0];
        intersect2 = intersection[1];
        /**
             * At this point we have four points:
             * point1 and point2 are the first and the second defining point on the line,
             * intersect1, intersect2 are the intersections of the line with border around the board.
             */ /*
             * Here we handle rays where both defining points are outside of the board.
             */ // If both points are outside and the complete ray is outside we do nothing
        if (!takePoint1 && !takePoint2) {
            // Ray starting at point 1
            if (!straightFirst && straightLast && !this.isSameDirection(point1, point2, intersect1) && !this.isSameDirection(point1, point2, intersect2)) {
                return;
            }
            // Ray starting at point 2
            if (straightFirst && !straightLast && !this.isSameDirection(point2, point1, intersect1) && !this.isSameDirection(point2, point1, intersect2)) {
                return;
            }
        }
        /*
             * If at least one of the defining points is outside of the board
             * we take intersect1 or intersect2 as one of the end points
             * The order is also important for arrows of axes
             */ if (!takePoint1) {
            if (!takePoint2) {
                // Two border intersection points are used
                if (this.isSameDir(point1, point2, intersect1, intersect2)) {
                    p1 = intersect1;
                    p2 = intersect2;
                } else {
                    p2 = intersect1;
                    p1 = intersect2;
                }
            } else {
                // One border intersection points is used
                if (this.isSameDir(point1, point2, intersect1, intersect2)) {
                    p1 = intersect1;
                } else {
                    p1 = intersect2;
                }
            }
        } else {
            if (!takePoint2) {
                // One border intersection points is used
                if (this.isSameDir(point1, point2, intersect1, intersect2)) {
                    p2 = intersect2;
                } else {
                    p2 = intersect1;
                }
            }
        }
        if (p1) {
            //point1.setCoordinates(Const.COORDS_BY_USER, p1.usrCoords.slice(1));
            point1.setCoordinates(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, p1.usrCoords);
        }
        if (p2) {
            //point2.setCoordinates(Const.COORDS_BY_USER, p2.usrCoords.slice(1));
            point2.setCoordinates(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, p2.usrCoords);
        }
    },
    /**
         * A line can be a segment, a straight, or a ray. so it is not always delimited by point1 and point2.
         *
         * This method adjusts the line's delimiting points taking into account its nature, the viewport defined
         * by the board.
         *
         * A segment is delimited by start and end point, a straight line or ray is delimited until it meets the
         * boards boundaries. However, if the line has infinite ticks, it will be delimited by the projection of
         * the boards vertices onto itself.
         *
         * @param {JXG.Line} el Reference to a line object, that needs calculation of start and end point.
         * @param {JXG.Coords} point1 Coordinates of the point where line drawing begins. This value is calculated and
         * set by this method.
         * @param {JXG.Coords} point2 Coordinates of the point where line drawing ends. This value is calculated and set
         * by this method.
         * @see Line
         * @see JXG.Line
         */ calcLineDelimitingPoints: function(el, point1, point2) {
        var distP1P2, boundingBox, lineSlope, intersect1, intersect2, straightFirst, straightLast, c, p1, p2, takePoint1 = false, takePoint2 = false;
        straightFirst = el.evalVisProp('straightfirst');
        straightLast = el.evalVisProp('straightlast');
        // If one of the point is an ideal point in homogeneous coordinates
        // drawing of line segments or rays are not possible.
        if (Math.abs(point1.scrCoords[0]) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
            straightFirst = true;
        }
        if (Math.abs(point2.scrCoords[0]) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
            straightLast = true;
        }
        // Compute the stdform of the line in screen coordinates.
        c = [];
        c[0] = el.stdform[0] - el.stdform[1] * el.board.origin.scrCoords[1] / el.board.unitX + el.stdform[2] * el.board.origin.scrCoords[2] / el.board.unitY;
        c[1] = el.stdform[1] / el.board.unitX;
        c[2] = -el.stdform[2] / el.board.unitY;
        // p1=p2
        if (isNaN(c[0] + c[1] + c[2])) {
            return;
        }
        takePoint1 = !straightFirst;
        takePoint2 = !straightLast;
        // Intersect the board vertices on the line to establish the available visual space for the infinite ticks
        // Based on the slope of the line we can optimise and only project the two outer vertices
        // boundingBox = [x1, y1, x2, y2] upper left, lower right vertices
        boundingBox = el.board.getBoundingBox();
        lineSlope = el.getSlope();
        if (lineSlope >= 0) {
            // project vertices (x2,y1) (x1, y2)
            intersect1 = this.projectPointToLine({
                coords: {
                    usrCoords: [
                        1,
                        boundingBox[2],
                        boundingBox[1]
                    ]
                }
            }, el, el.board);
            intersect2 = this.projectPointToLine({
                coords: {
                    usrCoords: [
                        1,
                        boundingBox[0],
                        boundingBox[3]
                    ]
                }
            }, el, el.board);
        } else {
            // project vertices (x1, y1) (x2, y2)
            intersect1 = this.projectPointToLine({
                coords: {
                    usrCoords: [
                        1,
                        boundingBox[0],
                        boundingBox[1]
                    ]
                }
            }, el, el.board);
            intersect2 = this.projectPointToLine({
                coords: {
                    usrCoords: [
                        1,
                        boundingBox[2],
                        boundingBox[3]
                    ]
                }
            }, el, el.board);
        }
        /**
             * we have four points:
             * point1 and point2 are the first and the second defining point on the line,
             * intersect1, intersect2 are the intersections of the line with border around the board.
             */ /*
             * Here we handle rays/segments where both defining points are outside of the board.
             */ if (!takePoint1 && !takePoint2) {
            // Segment, if segment does not cross the board, do nothing
            if (!straightFirst && !straightLast) {
                distP1P2 = point1.distance(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, point2);
                // if  intersect1 not between point1 and point2
                if (Math.abs(point1.distance(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, intersect1) + intersect1.distance(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, point2) - distP1P2) > __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
                    return;
                }
                // if insersect2 not between point1 and point2
                if (Math.abs(point1.distance(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, intersect2) + intersect2.distance(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, point2) - distP1P2) > __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
                    return;
                }
            }
            // If both points are outside and the complete ray is outside we do nothing
            // Ray starting at point 1
            if (!straightFirst && straightLast && !this.isSameDirection(point1, point2, intersect1) && !this.isSameDirection(point1, point2, intersect2)) {
                return;
            }
            // Ray starting at point 2
            if (straightFirst && !straightLast && !this.isSameDirection(point2, point1, intersect1) && !this.isSameDirection(point2, point1, intersect2)) {
                return;
            }
        }
        /*
             * If at least one of the defining points is outside of the board
             * we take intersect1 or intersect2 as one of the end points
             * The order is also important for arrows of axes
             */ if (!takePoint1) {
            if (!takePoint2) {
                // Two border intersection points are used
                if (this.isSameDir(point1, point2, intersect1, intersect2)) {
                    p1 = intersect1;
                    p2 = intersect2;
                } else {
                    p2 = intersect1;
                    p1 = intersect2;
                }
            } else {
                // One border intersection points is used
                if (this.isSameDir(point1, point2, intersect1, intersect2)) {
                    p1 = intersect1;
                } else {
                    p1 = intersect2;
                }
            }
        } else {
            if (!takePoint2) {
                // One border intersection points is used
                if (this.isSameDir(point1, point2, intersect1, intersect2)) {
                    p2 = intersect2;
                } else {
                    p2 = intersect1;
                }
            }
        }
        if (p1) {
            //point1.setCoordinates(Const.COORDS_BY_USER, p1.usrCoords.slice(1));
            point1.setCoordinates(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, p1.usrCoords);
        }
        if (p2) {
            //point2.setCoordinates(Const.COORDS_BY_USER, p2.usrCoords.slice(1));
            point2.setCoordinates(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, p2.usrCoords);
        }
    },
    /**
         * Calculates the visProp.position corresponding to a given angle.
         * @param {number} angle angle in radians. Must be in range (-2pi,2pi).
         */ calcLabelQuadrant: function(angle) {
        var q;
        if (angle < 0) {
            angle += 2 * Math.PI;
        }
        q = Math.floor((angle + Math.PI / 8) / (Math.PI / 4)) % 8;
        return [
            "rt",
            "urt",
            "top",
            "ulft",
            "lft",
            "llft",
            "lrt"
        ][q];
    },
    /**
         * The vectors <tt>p2-p1</tt> and <tt>i2-i1</tt> are supposed to be collinear. If their cosine is positive
         * they point into the same direction otherwise they point in opposite direction.
         * @param {JXG.Coords} p1
         * @param {JXG.Coords} p2
         * @param {JXG.Coords} i1
         * @param {JXG.Coords} i2
         * @returns {Boolean} True, if <tt>p2-p1</tt> and <tt>i2-i1</tt> point into the same direction
         */ isSameDir: function(p1, p2, i1, i2) {
        var dpx = p2.usrCoords[1] - p1.usrCoords[1], dpy = p2.usrCoords[2] - p1.usrCoords[2], dix = i2.usrCoords[1] - i1.usrCoords[1], diy = i2.usrCoords[2] - i1.usrCoords[2];
        if (Math.abs(p2.usrCoords[0]) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
            dpx = p2.usrCoords[1];
            dpy = p2.usrCoords[2];
        }
        if (Math.abs(p1.usrCoords[0]) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
            dpx = -p1.usrCoords[1];
            dpy = -p1.usrCoords[2];
        }
        return dpx * dix + dpy * diy >= 0;
    },
    /**
         * If you're looking from point "start" towards point "s" and you can see the point "p", return true.
         * Otherwise return false.
         * @param {JXG.Coords} start The point you're standing on.
         * @param {JXG.Coords} p The point in which direction you're looking.
         * @param {JXG.Coords} s The point that should be visible.
         * @returns {Boolean} True, if from start the point p is in the same direction as s is, that means s-start = k*(p-start) with k>=0.
         */ isSameDirection: function(start, p, s) {
        var dx, dy, sx, sy, r = false;
        dx = p.usrCoords[1] - start.usrCoords[1];
        dy = p.usrCoords[2] - start.usrCoords[2];
        sx = s.usrCoords[1] - start.usrCoords[1];
        sy = s.usrCoords[2] - start.usrCoords[2];
        if (Math.abs(dx) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
            dx = 0;
        }
        if (Math.abs(dy) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
            dy = 0;
        }
        if (Math.abs(sx) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
            sx = 0;
        }
        if (Math.abs(sy) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
            sy = 0;
        }
        if (dx >= 0 && sx >= 0) {
            r = dy >= 0 && sy >= 0 || dy <= 0 && sy <= 0;
        } else if (dx <= 0 && sx <= 0) {
            r = dy >= 0 && sy >= 0 || dy <= 0 && sy <= 0;
        }
        return r;
    },
    /**
         * Determinant of three points in the Euclidean plane.
         * Zero, if the points are collinear. Used to determine of a point q is left or
         * right to a segment defined by points p1 and p2.
         * <p>
         * Non-homogeneous version.
         *
         * @param  {Array|JXG.Point} p1 First point or its coordinates of the segment. Point object or array of length 3. First (homogeneous) coordinate is equal to 1.
         * @param  {Array|JXG.Point} p2 Second point or its coordinates of the segment. Point object or array of length 3. First (homogeneous) coordinate is equal to 1.
         * @param  {Array|JXG.Point} q Point or its coordinates. Point object or array of length 3. First (homogeneous) coordinate is equal to 1.
         * @return {Number} Signed area of the triangle formed by these three points.
         *
         * @see JXG.Math.Geometry.windingNumber
         */ det3p: function(p1, p2, q) {
        var pp1, pp2, qq;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isPoint(p1)) {
            pp1 = p1.Coords(true);
        } else {
            pp1 = p1;
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isPoint(p2)) {
            pp2 = p2.Coords(true);
        } else {
            pp2 = p2;
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isPoint(q)) {
            qq = q.Coords(true);
        } else {
            qq = q;
        }
        return (pp1[1] - qq[1]) * (pp2[2] - qq[2]) - (pp2[1] - qq[1]) * (pp1[2] - qq[2]);
    },
    /**
         * Winding number of a point in respect to a polygon path.
         *
         * The point is regarded outside if the winding number is zero,
         * inside otherwise. The algorithm tries to find degenerate cases, i.e.
         * if the point is on the path. This is regarded as "outside".
         * If the point is a vertex of the path, it is regarded as "inside".
         *
         * Implementation of algorithm 7 from "The point in polygon problem for
         * arbitrary polygons" by Kai Hormann and Alexander Agathos, Computational Geometry,
         * Volume 20, Issue 3, November 2001, Pages 131-144.
         *
         * @param  {Array} usrCoords Homogenous coordinates of the point
         * @param  {Array} path      Array of points / coords determining a path, i.e. the vertices of the polygon / path. The array elements
         * do not have to be full points, but have to have a subobject "coords" or should be of type JXG.Coords.
         * @param  {Boolean} [doNotClosePath=false] If true the last point of the path is not connected to the first point.
         * This is necessary if the path consists of two or more closed subpaths, e.g. if the figure has a hole.
         *
         * @return {Number}          Winding number of the point. The point is
         *                           regarded outside if the winding number is zero,
         *                           inside otherwise.
         */ windingNumber: function(usrCoords, path, doNotClosePath) {
        var wn = 0, le = path.length, x = usrCoords[1], y = usrCoords[2], p0, p1, p2, d, sign, i, off = 0;
        if (le === 0) {
            return 0;
        }
        doNotClosePath = doNotClosePath || false;
        if (doNotClosePath) {
            off = 1;
        }
        // Infinite points are declared outside
        if (isNaN(x) || isNaN(y)) {
            return 1;
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(path[0].coords)) {
            p0 = path[0].coords;
            p1 = path[le - 1].coords;
        } else {
            p0 = path[0];
            p1 = path[le - 1];
        }
        // Handle the case if the point is the first vertex of the path, i.e. inside.
        if (p0.usrCoords[1] === x && p0.usrCoords[2] === y) {
            return 1;
        }
        for(i = 0; i < le - off; i++){
            // Consider the edge from p1 = path[i] to p2 = path[i+1]isClosedPath
            if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(path[i].coords)) {
                p1 = path[i].coords.usrCoords;
                p2 = path[(i + 1) % le].coords.usrCoords;
            } else {
                p1 = path[i].usrCoords;
                p2 = path[(i + 1) % le].usrCoords;
            }
            // If one of the two points p1, p2 is undefined or infinite,
            // move on.
            if (p1[0] === 0 || p2[0] === 0 || isNaN(p1[1]) || isNaN(p2[1]) || isNaN(p1[2]) || isNaN(p2[2])) {
                continue;
            }
            if (p2[2] === y) {
                if (p2[1] === x) {
                    return 1;
                }
                if (p1[2] === y && p2[1] > x === p1[1] < x) {
                    return 0;
                }
            }
            if (p1[2] < y !== p2[2] < y) {
                // Crossing
                sign = 2 * (p2[2] > p1[2] ? 1 : 0) - 1;
                if (p1[1] >= x) {
                    if (p2[1] > x) {
                        wn += sign;
                    } else {
                        d = this.det3p(p1, p2, usrCoords);
                        if (d === 0) {
                            // Point is on line, i.e. outside
                            return 0;
                        }
                        if (d > 0 + __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps === p2[2] > p1[2]) {
                            // Right crossing
                            wn += sign;
                        }
                    }
                } else {
                    if (p2[1] > x) {
                        d = this.det3p(p1, p2, usrCoords);
                        if (d > 0 + __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps === p2[2] > p1[2]) {
                            // Right crossing
                            wn += sign;
                        }
                    }
                }
            }
        }
        return wn;
    },
    /**
         * Decides if a point (x,y) is inside of a path / polygon.
         * Does not work correct if the path has hole. In this case, windingNumber is the preferred method.
         * Implements W. Randolf Franklin's pnpoly method.
         *
         * See <a href="https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html">https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html</a>.
         *
         * @param {Number} x_in x-coordinate (screen or user coordinates)
         * @param {Number} y_in y-coordinate (screen or user coordinates)
         * @param  {Array} path  Array of points / coords determining a path, i.e. the vertices of the polygon / path. The array elements
         * do not have to be full points, but have to have a subobject "coords" or should be of type JXG.Coords.
         * @param {Number} [coord_type=JXG.COORDS_BY_SCREEN] Type of coordinates used here.
         *   Possible values are <b>JXG.COORDS_BY_USER</b> and <b>JXG.COORDS_BY_SCREEN</b>.
         *   Default value is JXG.COORDS_BY_SCREEN.
         * @param {JXG.Board} board Board object
         *
         * @returns {Boolean} if (x_in, y_in) is inside of the polygon.
         * @see JXG.Polygon#hasPoint
         * @see JXG.Polygon#pnpoly
         * @see JXG.Math.Geometry.windingNumber
         *
         * @example
         * var pol = board.create('polygon', [[-1,2], [2,2], [-1,4]]);
         * var p = board.create('point', [4, 3]);
         * var txt = board.create('text', [-1, 0.5, function() {
         *   return 'Point A is inside of the polygon = ' +
         *     JXG.Math.Geometry.pnpoly(p.X(), p.Y(), pol.vertices, JXG.COORDS_BY_USER, board);
         * }]);
         *
         * </pre><div id="JXG4656ed42-f965-4e35-bb66-c334a4529683" class="jxgbox" style="width: 300px; height: 300px;"></div>
         * <script type="text/javascript">
         *     (function() {
         *         var board = JXG.JSXGraph.initBoard('JXG4656ed42-f965-4e35-bb66-c334a4529683',
         *             {boundingbox: [-2, 5, 5,-2], axis: true, showcopyright: false, shownavigation: false});
         *     var pol = board.create('polygon', [[-1,2], [2,2], [-1,4]]);
         *     var p = board.create('point', [4, 3]);
         *     var txt = board.create('text', [-1, 0.5, function() {
         *     		return 'Point A is inside of the polygon = ' + JXG.Math.Geometry.pnpoly(p.X(), p.Y(), pol.vertices, JXG.COORDS_BY_USER, board);
         *     }]);
         *
         *     })();
         *
         * </script><pre>
         *
         */ pnpoly: function(x_in, y_in, path, coord_type, board) {
        var i, j, vi, vj, len, x, y, crds, v = path, isIn = false;
        if (coord_type === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER) {
            crds = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
                x_in,
                y_in
            ], board);
            x = crds.scrCoords[1];
            y = crds.scrCoords[2];
        } else {
            x = x_in;
            y = y_in;
        }
        len = path.length;
        for(i = 0, j = len - 2; i < len - 1; j = i++){
            vi = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(v[i].coords) ? v[i].coords : v[i];
            vj = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(v[j].coords) ? v[j].coords : v[j];
            if (vi.scrCoords[2] > y !== vj.scrCoords[2] > y && x < (vj.scrCoords[1] - vi.scrCoords[1]) * (y - vi.scrCoords[2]) / (vj.scrCoords[2] - vi.scrCoords[2]) + vi.scrCoords[1]) {
                isIn = !isIn;
            }
        }
        return isIn;
    },
    /****************************************/ /****          INTERSECTIONS         ****/ /****************************************/ /**
         * Generate the function which computes the coordinates of the intersection point.
         * Primarily used in {@link JXG.Point.createIntersectionPoint}.
         * @param {JXG.Board} board object
         * @param {JXG.Line,JXG.Circle_JXG.Line,JXG.Circle_Number|Function} el1,el2,i The result will be a intersection point on el1 and el2.
         * i determines the intersection point if two points are available: <ul>
         *   <li>i==0: use the positive square root,</li>
         *   <li>i==1: use the negative square root.</li></ul>
         * @param {Boolean} alwaysintersect. Flag that determines if segments and arc can have an outer intersection point
         * on their defining line or circle.
         * @returns {Function} Function returning a {@link JXG.Coords} object that determines
         * the intersection point.
         *
         * @see JXG.Point.createIntersectionPoint
         */ intersectionFunction: function(board, el1, el2, i, j, alwaysintersect) {
        var func, that = this, el1_isArcType = false, el2_isArcType = false;
        el1_isArcType = el1.elementClass === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_CLASS_CURVE && (el1.type === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_TYPE_ARC || el1.type === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_TYPE_SECTOR) ? true : false;
        el2_isArcType = el2.elementClass === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_CLASS_CURVE && (el2.type === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_TYPE_ARC || el2.type === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_TYPE_SECTOR) ? true : false;
        if ((el1.elementClass === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_CLASS_CURVE || el2.elementClass === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_CLASS_CURVE) && (el1.elementClass === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_CLASS_CURVE || el1.elementClass === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_CLASS_CIRCLE) && (el2.elementClass === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_CLASS_CURVE || el2.elementClass === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_CLASS_CIRCLE)) {
            // curve - curve
            // with the exception that both elements are arc types
            /** @ignore */ func = function() {
                return that.meetCurveCurve(el1, el2, i, j, el1.board);
            };
        } else if (el1.elementClass === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_CLASS_CURVE && !el1_isArcType && el2.elementClass === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_CLASS_LINE || el2.elementClass === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_CLASS_CURVE && !el2_isArcType && el1.elementClass === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_CLASS_LINE) {
            // curve - line (this includes intersections between conic sections and lines)
            // with the exception that the curve is of arc type
            /** @ignore */ func = function() {
                return that.meetCurveLine(el1, el2, i, el1.board, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evaluate(alwaysintersect));
            };
        } else if (el1.type === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_TYPE_POLYGON || el2.type === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_TYPE_POLYGON) {
            // polygon - other
            // Uses the Greiner-Hormann clipping algorithm
            // Not implemented: polygon - point
            if (el1.elementClass === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_CLASS_LINE) {
                // line - path
                /** @ignore */ func = function() {
                    var first1 = el1.evalVisProp('straightfirst'), last1 = el1.evalVisProp('straightlast'), first2 = el2.evalVisProp('straightfirst'), last2 = el2.evalVisProp('straightlast'), a_not;
                    a_not = !__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evaluate(alwaysintersect) && (!first1 || !last1 || !first2 || !last2);
                    return that.meetPolygonLine(el2, el1, i, el1.board, a_not);
                };
            } else if (el2.elementClass === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_CLASS_LINE) {
                // path - line
                /** @ignore */ func = function() {
                    var first1 = el1.evalVisProp('straightfirst'), last1 = el1.evalVisProp('straightlast'), first2 = el2.evalVisProp('straightfirst'), last2 = el2.evalVisProp('straightlast'), a_not;
                    a_not = !__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evaluate(alwaysintersect) && (!first1 || !last1 || !first2 || !last2);
                    return that.meetPolygonLine(el1, el2, i, el1.board, a_not);
                };
            } else {
                // path - path
                /** @ignore */ func = function() {
                    return that.meetPathPath(el1, el2, i, el1.board);
                };
            }
        } else if (el1.elementClass === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_CLASS_LINE && el2.elementClass === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_CLASS_LINE) {
            // line - line, lines may also be segments.
            /** @ignore */ func = function() {
                var res, c, first1 = el1.evalVisProp('straightfirst'), last1 = el1.evalVisProp('straightlast'), first2 = el2.evalVisProp('straightfirst'), last2 = el2.evalVisProp('straightlast');
                /**
                     * If one of the lines is a segment or ray and
                     * the intersection point should disappear if outside
                     * of the segment or ray we call
                     * meetSegmentSegment
                     */ if (!__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evaluate(alwaysintersect) && (!first1 || !last1 || !first2 || !last2)) {
                    res = that.meetSegmentSegment(el1.point1.coords.usrCoords, el1.point2.coords.usrCoords, el2.point1.coords.usrCoords, el2.point2.coords.usrCoords);
                    if (!first1 && res[1] < 0 || !last1 && res[1] > 1 || !first2 && res[2] < 0 || !last2 && res[2] > 1) {
                        // Non-existent
                        c = [
                            0,
                            NaN,
                            NaN
                        ];
                    } else {
                        c = res[0];
                    }
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, c, el1.board);
                }
                return that.meet(el1.stdform, el2.stdform, i, el1.board);
            };
        } else {
            // All other combinations of circles and lines,
            // Arc types are treated as circles.
            /** @ignore */ func = function() {
                var res = that.meet(el1.stdform, el2.stdform, i, el1.board), has = true, first, last, r;
                if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evaluate(alwaysintersect)) {
                    return res;
                }
                if (el1.elementClass === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_CLASS_LINE) {
                    first = el1.evalVisProp('straightfirst');
                    last = el1.evalVisProp('straightlast');
                    if (!first || !last) {
                        r = that.affineRatio(el1.point1.coords, el1.point2.coords, res);
                        if (!last && r > 1 + __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps || !first && r < 0 - __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
                            return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
                                0,
                                NaN,
                                NaN
                            ], el1.board);
                        }
                    }
                }
                if (el2.elementClass === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_CLASS_LINE) {
                    first = el2.evalVisProp('straightfirst');
                    last = el2.evalVisProp('straightlast');
                    if (!first || !last) {
                        r = that.affineRatio(el2.point1.coords, el2.point2.coords, res);
                        if (!last && r > 1 + __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps || !first && r < 0 - __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
                            return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
                                0,
                                NaN,
                                NaN
                            ], el1.board);
                        }
                    }
                }
                if (el1_isArcType) {
                    has = that.coordsOnArc(el1, res);
                    if (has && el2_isArcType) {
                        has = that.coordsOnArc(el2, res);
                    }
                    if (!has) {
                        return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
                            0,
                            NaN,
                            NaN
                        ], el1.board);
                    }
                }
                return res;
            };
        }
        return func;
    },
    otherIntersectionFunction: function(input, others, alwaysintersect, precision) {
        var func, board, el1, el2, that = this;
        el1 = input[0];
        el2 = input[1];
        board = el1.board;
        /** @ignore */ func = function() {
            var i, k, c, d, isClose, le = others.length, eps = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evaluate(precision);
            for(i = le; i >= 0; i--){
                if (el1.elementClass === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_CLASS_CIRCLE && [
                    __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_CLASS_CIRCLE,
                    __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_CLASS_LINE
                ].indexOf(el2.elementClass) >= 0) {
                    // circle, circle|line
                    c = that.meet(el1.stdform, el2.stdform, i, board);
                } else if (el1.elementClass === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_CLASS_CURVE && [
                    __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_CLASS_CURVE,
                    __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_CLASS_CIRCLE
                ].indexOf(el2.elementClass) >= 0) {
                    // curve, circle|curve
                    c = that.meetCurveCurve(el1, el2, i, 0, board, 'segment');
                } else if (el1.elementClass === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_CLASS_CURVE && el2.elementClass === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_CLASS_LINE) {
                    // curve, line
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(el1.dataX)) {
                        c = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Math.Geometry.meetCurveLine(el1, el2, i, el1.board, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evaluate(alwaysintersect));
                    } else {
                        c = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Math.Geometry.meetCurveLineContinuous(el1, el2, i, el1.board);
                    }
                }
                // If the intersection is close to one of the points in other
                // we have to search for another intersection point.
                isClose = false;
                for(k = 0; !isClose && k < le; k++){
                    d = c.distance(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, others[k].coords);
                    if (d < eps) {
                        isClose = true;
                    }
                }
                if (!isClose) {
                    // We are done, the intersection is away from any other
                    // intersection point.
                    return c;
                }
            }
            // Otherwise we return the last intersection point
            return c;
        };
        return func;
    },
    /**
         * Returns true if the coordinates are on the arc element,
         * false otherwise. Usually, coords is an intersection
         * on the circle line. Now it is decided if coords are on the
         * circle restricted to the arc line.
         * @param  {Arc} arc arc or sector element
         * @param  {JXG.Coords} coords Coords object of an intersection
         * @returns {Boolean}
         * @private
         */ coordsOnArc: function(arc, coords) {
        var angle = this.rad(arc.radiuspoint, arc.center, coords.usrCoords.slice(1)), alpha = 0.0, beta = this.rad(arc.radiuspoint, arc.center, arc.anglepoint), ev_s = arc.evalVisProp('selection');
        if (ev_s === "minor" && beta > Math.PI || ev_s === "major" && beta < Math.PI) {
            alpha = beta;
            beta = 2 * Math.PI;
        }
        if (angle < alpha || angle > beta) {
            return false;
        }
        return true;
    },
    /**
         * Computes the intersection of a pair of lines, circles or both.
         * It uses the internal data array stdform of these elements.
         * @param {Array} el1 stdform of the first element (line or circle)
         * @param {Array} el2 stdform of the second element (line or circle)
         * @param {Number|Function} i Index of the intersection point that should be returned.
         * @param board Reference to the board.
         * @returns {JXG.Coords} Coordinates of one of the possible two or more intersection points.
         * Which point will be returned is determined by i.
         */ meet: function(el1, el2, i, board) {
        var result, eps = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps;
        if (Math.abs(el1[3]) < eps && Math.abs(el2[3]) < eps) {
            // line line
            result = this.meetLineLine(el1, el2, i, board);
        } else if (Math.abs(el1[3]) >= eps && Math.abs(el2[3]) < eps) {
            // circle line
            result = this.meetLineCircle(el2, el1, i, board);
        } else if (Math.abs(el1[3]) < eps && Math.abs(el2[3]) >= eps) {
            // line circle
            result = this.meetLineCircle(el1, el2, i, board);
        } else {
            // circle circle
            result = this.meetCircleCircle(el1, el2, i, board);
        }
        return result;
    },
    /**
         * Intersection of the line with the board
         * @param  {Array}     line   stdform of the line in screen coordinates
         * @param  {JXG.Board} board  reference to a board.
         * @param  {Number}    margin optional margin, to avoid the display of the small sides of lines.
         * @returns {Array}            [intersection coords 1, intersection coords 2]
         */ meetLineBoard: function(line, board, margin) {
        // Intersect the line with the four borders of the board.
        var s = [], intersect1, intersect2, i, j;
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(margin)) {
            margin = 0;
        }
        // top
        s[0] = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].crossProduct(line, [
            margin,
            0,
            1
        ]);
        // left
        s[1] = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].crossProduct(line, [
            margin,
            1,
            0
        ]);
        // bottom
        s[2] = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].crossProduct(line, [
            -margin - board.canvasHeight,
            0,
            1
        ]);
        // right
        s[3] = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].crossProduct(line, [
            -margin - board.canvasWidth,
            1,
            0
        ]);
        // Normalize the intersections
        for(i = 0; i < 4; i++){
            if (Math.abs(s[i][0]) > __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
                for(j = 2; j > 0; j--){
                    s[i][j] /= s[i][0];
                }
                s[i][0] = 1.0;
            }
        }
        // line is parallel to "left", take "top" and "bottom"
        if (Math.abs(s[1][0]) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
            intersect1 = s[0]; // top
            intersect2 = s[2]; // bottom
        // line is parallel to "top", take "left" and "right"
        } else if (Math.abs(s[0][0]) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
            intersect1 = s[1]; // left
            intersect2 = s[3]; // right
        // left intersection out of board (above)
        } else if (s[1][2] < 0) {
            intersect1 = s[0]; // top
            // right intersection out of board (below)
            if (s[3][2] > board.canvasHeight) {
                intersect2 = s[2]; // bottom
            } else {
                intersect2 = s[3]; // right
            }
        // left intersection out of board (below)
        } else if (s[1][2] > board.canvasHeight) {
            intersect1 = s[2]; // bottom
            // right intersection out of board (above)
            if (s[3][2] < 0) {
                intersect2 = s[0]; // top
            } else {
                intersect2 = s[3]; // right
            }
        } else {
            intersect1 = s[1]; // left
            // right intersection out of board (above)
            if (s[3][2] < 0) {
                intersect2 = s[0]; // top
            // right intersection out of board (below)
            } else if (s[3][2] > board.canvasHeight) {
                intersect2 = s[2]; // bottom
            } else {
                intersect2 = s[3]; // right
            }
        }
        return [
            new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_SCREEN, intersect1.slice(1), board),
            new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_SCREEN, intersect2.slice(1), board)
        ];
    },
    /**
         * Intersection of two lines.
         * @param {Array} l1 stdform of the first line
         * @param {Array} l2 stdform of the second line
         * @param {number} i unused
         * @param {JXG.Board} board Reference to the board.
         * @returns {JXG.Coords} Coordinates of the intersection point.
         */ meetLineLine: function(l1, l2, i, board) {
        var s = isNaN(l1[5] + l2[5]) ? [
            0,
            0,
            0
        ] : __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].crossProduct(l1, l2);
        // Make intersection of parallel lines more robust:
        if (Math.abs(s[0]) < 1.0e-14) {
            s[0] = 0;
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, s, board);
    },
    /**
         * Intersection of line and circle.
         * @param {Array} lin stdform of the line
         * @param {Array} circ stdform of the circle
         * @param {number|function} i number of the returned intersection point.
         *   i==0: use the positive square root,
         *   i==1: use the negative square root.
         * @param {JXG.Board} board Reference to a board.
         * @returns {JXG.Coords} Coordinates of the intersection point
         */ meetLineCircle: function(lin, circ, i, board) {
        var a, b, c, d, n, A, B, C, k, t;
        // Radius is zero, return center of circle
        if (circ[4] < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
            if (Math.abs(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].innerProduct([
                1,
                circ[6],
                circ[7]
            ], lin, 3)) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
                return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, circ.slice(6, 8), board);
            }
            return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
                NaN,
                NaN
            ], board);
        }
        c = circ[0];
        b = circ.slice(1, 3);
        a = circ[3];
        d = lin[0];
        n = lin.slice(1, 3);
        // Line is assumed to be normalized. Therefore, nn==1 and we can skip some operations:
        /*
             var nn = n[0]*n[0]+n[1]*n[1];
             A = a*nn;
             B = (b[0]*n[1]-b[1]*n[0])*nn;
             C = a*d*d - (b[0]*n[0]+b[1]*n[1])*d + c*nn;
             */ A = a;
        B = b[0] * n[1] - b[1] * n[0];
        C = a * d * d - (b[0] * n[0] + b[1] * n[1]) * d + c;
        k = B * B - 4 * A * C;
        if (k > -__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps * __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
            k = Math.sqrt(Math.abs(k));
            t = [
                (-B + k) / (2 * A),
                (-B - k) / (2 * A)
            ];
            return __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evaluate(i) === 0 ? new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
                -t[0] * -n[1] - d * n[0],
                -t[0] * n[0] - d * n[1]
            ], board) : new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
                -t[1] * -n[1] - d * n[0],
                -t[1] * n[0] - d * n[1]
            ], board);
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
            0,
            0,
            0
        ], board);
    },
    /**
         * Intersection of two circles.
         * @param {Array} circ1 stdform of the first circle
         * @param {Array} circ2 stdform of the second circle
         * @param {number|function} i number of the returned intersection point.
         *   i==0: use the positive square root,
         *   i==1: use the negative square root.
         * @param {JXG.Board} board Reference to the board.
         * @returns {JXG.Coords} Coordinates of the intersection point
         */ meetCircleCircle: function(circ1, circ2, i, board) {
        var radicalAxis;
        // Radius is zero, return center of circle, if on other circle
        if (circ1[4] < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
            if (Math.abs(this.distance(circ1.slice(6, 2), circ2.slice(6, 8)) - circ2[4]) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
                return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, circ1.slice(6, 8), board);
            }
            return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
                0,
                0,
                0
            ], board);
        }
        // Radius is zero, return center of circle, if on other circle
        if (circ2[4] < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
            if (Math.abs(this.distance(circ2.slice(6, 2), circ1.slice(6, 8)) - circ1[4]) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
                return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, circ2.slice(6, 8), board);
            }
            return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
                0,
                0,
                0
            ], board);
        }
        radicalAxis = [
            circ2[3] * circ1[0] - circ1[3] * circ2[0],
            circ2[3] * circ1[1] - circ1[3] * circ2[1],
            circ2[3] * circ1[2] - circ1[3] * circ2[2],
            0,
            1,
            Infinity,
            Infinity,
            Infinity
        ];
        radicalAxis = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalize(radicalAxis);
        return this.meetLineCircle(radicalAxis, circ1, i, board);
    },
    /**
         * Compute an intersection of the curves c1 and c2.
         * We want to find values t1, t2 such that
         * c1(t1) = c2(t2), i.e. (c1_x(t1)-c2_x(t2),c1_y(t1)-c2_y(t2)) = (0,0).
         *
         * Methods: segment-wise intersections (default) or generalized Newton method.
         * @param {JXG.Curve} c1 Curve, Line or Circle
         * @param {JXG.Curve} c2 Curve, Line or Circle
         * @param {Number|Function} nr the nr-th intersection point will be returned.
         * @param {Number} t2ini not longer used.
         * @param {JXG.Board} [board=c1.board] Reference to a board object.
         * @param {String} [method='segment'] Intersection method, possible values are 'newton' and 'segment'.
         * @returns {JXG.Coords} intersection point
         */ meetCurveCurve: function(c1, c2, nr, t2ini, board, method) {
        var co;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(method) && method === "newton") {
            co = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$numerics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].generalizedNewton(c1, c2, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evaluate(nr), t2ini);
        } else {
            if (c1.bezierDegree === 3 || c2.bezierDegree === 3) {
                co = this.meetBezierCurveRedBlueSegments(c1, c2, nr);
            } else {
                co = this.meetCurveRedBlueSegments(c1, c2, nr);
            }
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, co, board);
    },
    /**
         * Intersection of curve with line,
         * Order of input does not matter for el1 and el2.
         * From version 0.99.7 on this method calls
         * {@link JXG.Math.Geometry.meetCurveLineDiscrete}.
         * If higher precision is needed, {@link JXG.Math.Geometry.meetCurveLineContinuous}
         * has to be used.
         *
         * @param {JXG.Curve|JXG.Line} el1 Curve or Line
         * @param {JXG.Curve|JXG.Line} el2 Curve or Line
         * @param {Number|Function} nr the nr-th intersection point will be returned.
         * @param {JXG.Board} [board=el1.board] Reference to a board object.
         * @param {Boolean} alwaysIntersect If false just the segment between the two defining points are tested for intersection
         * @returns {JXG.Coords} Intersection point. In case no intersection point is detected,
         * the ideal point [0,1,0] is returned.
         */ meetCurveLine: function(el1, el2, nr, board, alwaysIntersect) {
        var v = [
            0,
            NaN,
            NaN
        ], cu, li;
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(board)) {
            board = el1.board;
        }
        if (el1.elementClass === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_CLASS_CURVE) {
            cu = el1;
            li = el2;
        } else {
            cu = el2;
            li = el1;
        }
        v = this.meetCurveLineDiscrete(cu, li, nr, board, !alwaysIntersect);
        return v;
    },
    /**
         * Intersection of line and curve, continuous case.
         * Finds the nr-the intersection point
         * Uses {@link JXG.Math.Geometry.meetCurveLineDiscrete} as a first approximation.
         * A more exact solution is then found with {@link JXG.Math.Numerics.root}.
         *
         * @param {JXG.Curve} cu Curve
         * @param {JXG.Line} li Line
         * @param {NumberFunction} nr Will return the nr-th intersection point.
         * @param {JXG.Board} board
         * @param {Boolean} testSegment Test if intersection has to be inside of the segment or somewhere on the
         * line defined by the segment
         * @returns {JXG.Coords} Coords object containing the intersection.
         */ meetCurveLineContinuous: function(cu, li, nr, board, testSegment) {
        var func0, func1, t, v, x, y, z, eps = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps, epsLow = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps, steps, delta, tnew, tmin, fmin, i, ft;
        v = this.meetCurveLineDiscrete(cu, li, nr, board, testSegment);
        x = v.usrCoords[1];
        y = v.usrCoords[2];
        func0 = function(t) {
            var c1, c2;
            if (t > cu.maxX() || t < cu.minX()) {
                return Infinity;
            }
            c1 = cu.X(t) - x;
            c2 = cu.Y(t) - y;
            return c1 * c1 + c2 * c2;
        // return c1 * (cu.X(t + h) - cu.X(t - h)) + c2 * (cu.Y(t + h) - cu.Y(t - h)) / h;
        };
        func1 = function(t) {
            var v = li.stdform[0] + li.stdform[1] * cu.X(t) + li.stdform[2] * cu.Y(t);
            return v * v;
        };
        // Find t
        steps = 50;
        delta = (cu.maxX() - cu.minX()) / steps;
        tnew = cu.minX();
        fmin = 0.0001; //eps;
        tmin = NaN;
        for(i = 0; i < steps; i++){
            t = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$numerics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].root(func0, [
                Math.max(tnew, cu.minX()),
                Math.min(tnew + delta, cu.maxX())
            ]);
            ft = Math.abs(func0(t));
            if (ft <= fmin) {
                fmin = ft;
                tmin = t;
                if (fmin < eps) {
                    break;
                }
            }
            tnew += delta;
        }
        t = tmin;
        // Compute "exact" t
        t = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$numerics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].root(func1, [
            Math.max(t - delta, cu.minX()),
            Math.min(t + delta, cu.maxX())
        ]);
        ft = func1(t);
        // Is the point on the line?
        if (isNaN(ft) || Math.abs(ft) > epsLow) {
            z = 0.0; //NaN;
        } else {
            z = 1.0;
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
            z,
            cu.X(t),
            cu.Y(t)
        ], board);
    },
    /**
         * Intersection of line and curve, discrete case.
         * Segments are treated as lines.
         * Finding the nr-th intersection point should work for all nr.
         * @param {JXG.Curve} cu
         * @param {JXG.Line} li
         * @param {Number|Function} nr
         * @param {JXG.Board} board
         * @param {Boolean} testSegment Test if intersection has to be inside of the segment or somewhere on the
         * line defined by the segment
         *
         * @returns {JXG.Coords} Intersection point. In case no intersection point is detected,
         * the ideal point [0,1,0] is returned.
         */ meetCurveLineDiscrete: function(cu, li, nr, board, testSegment) {
        var i, j, n = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evaluate(nr), p1, p2, p, q, lip1 = li.point1.coords.usrCoords, lip2 = li.point2.coords.usrCoords, d, res, cnt = 0, len = cu.numberPoints, ev_sf = li.evalVisProp('straightfirst'), ev_sl = li.evalVisProp('straightlast');
        // In case, no intersection will be found we will take this
        q = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
            0,
            NaN,
            NaN
        ], board);
        if (lip1[0] === 0.0) {
            lip1 = [
                1,
                lip2[1] + li.stdform[2],
                lip2[2] - li.stdform[1]
            ];
        } else if (lip2[0] === 0.0) {
            lip2 = [
                1,
                lip1[1] + li.stdform[2],
                lip1[2] - li.stdform[1]
            ];
        }
        p2 = cu.points[0].usrCoords;
        for(i = 1; i < len; i += cu.bezierDegree){
            p1 = p2.slice(0);
            p2 = cu.points[i].usrCoords;
            d = this.distance(p1, p2);
            // The defining points are not identical
            if (d > __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
                if (cu.bezierDegree === 3) {
                    res = this.meetBeziersegmentBeziersegment([
                        cu.points[i - 1].usrCoords.slice(1),
                        cu.points[i].usrCoords.slice(1),
                        cu.points[i + 1].usrCoords.slice(1),
                        cu.points[i + 2].usrCoords.slice(1)
                    ], [
                        lip1.slice(1),
                        lip2.slice(1)
                    ], testSegment);
                } else {
                    res = [
                        this.meetSegmentSegment(p1, p2, lip1, lip2)
                    ];
                }
                for(j = 0; j < res.length; j++){
                    p = res[j];
                    if (0 <= p[1] && p[1] <= 1) {
                        if (cnt === n) {
                            /**
                                 * If the intersection point is not part of the segment,
                                 * this intersection point is set to non-existent.
                                 * This prevents jumping behavior of the intersection points.
                                 * But it may be discussed if it is the desired behavior.
                                 */ if (testSegment && (!ev_sf && p[2] < 0 || !ev_sl && p[2] > 1)) {
                                return q; // break;
                            }
                            q = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, p[0], board);
                            return q; // break;
                        }
                        cnt += 1;
                    }
                }
            }
        }
        return q;
    },
    /**
         * Find the n-th intersection point of two curves named red (first parameter) and blue (second parameter).
         * We go through each segment of the red curve and search if there is an intersection with a segment of the blue curve.
         * This double loop, i.e. the outer loop runs along the red curve and the inner loop runs along the blue curve, defines
         * the n-th intersection point. The segments are either line segments or Bezier curves of degree 3. This depends on
         * the property bezierDegree of the curves.
         * <p>
         * This method works also for transformed curves, since only the already
         * transformed points are used.
         *
         * @param {JXG.Curve} red
         * @param {JXG.Curve} blue
         * @param {Number|Function} nr
         */ meetCurveRedBlueSegments: function(red, blue, nr) {
        var i, j, n = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evaluate(nr), red1, red2, blue1, blue2, m, minX, maxX, iFound = 0, lenBlue = blue.numberPoints, lenRed = red.numberPoints; //points.length;
        if (lenBlue <= 1 || lenRed <= 1) {
            return [
                0,
                NaN,
                NaN
            ];
        }
        for(i = 1; i < lenRed; i++){
            red1 = red.points[i - 1].usrCoords;
            red2 = red.points[i].usrCoords;
            minX = Math.min(red1[1], red2[1]);
            maxX = Math.max(red1[1], red2[1]);
            blue2 = blue.points[0].usrCoords;
            for(j = 1; j < lenBlue; j++){
                blue1 = blue2;
                blue2 = blue.points[j].usrCoords;
                if (Math.min(blue1[1], blue2[1]) < maxX && Math.max(blue1[1], blue2[1]) > minX) {
                    m = this.meetSegmentSegment(red1, red2, blue1, blue2);
                    if (m[1] >= 0.0 && m[2] >= 0.0 && // The two segments meet in the interior or at the start points
                    (m[1] < 1.0 && m[2] < 1.0 || i === lenRed - 1 && m[1] === 1.0 || j === lenBlue - 1 && m[2] === 1.0)) {
                        if (iFound === n) {
                            return m[0];
                        }
                        iFound++;
                    }
                }
            }
        }
        return [
            0,
            NaN,
            NaN
        ];
    },
    /**
         * (Virtual) Intersection of two segments.
         * @param {Array} p1 First point of segment 1 using normalized homogeneous coordinates [1,x,y]
         * @param {Array} p2 Second point or direction of segment 1 using normalized homogeneous coordinates [1,x,y] or point at infinity [0,x,y], respectively
         * @param {Array} q1 First point of segment 2 using normalized homogeneous coordinates [1,x,y]
         * @param {Array} q2 Second point or direction of segment 2 using normalized homogeneous coordinates [1,x,y] or point at infinity [0,x,y], respectively
         * @returns {Array} [Intersection point, t, u] The first entry contains the homogeneous coordinates
         * of the intersection point. The second and third entry give the position of the intersection with respect
         * to the definiting parameters. For example, the second entry t is defined by: intersection point = p1 + t * deltaP, where
         * deltaP = (p2 - p1) when both parameters are coordinates, and deltaP = p2 if p2 is a point at infinity.
         * If the two segments are collinear, [[0,0,0], Infinity, Infinity] is returned.
         **/ meetSegmentSegment: function(p1, p2, q1, q2) {
        var t, u, i, d, li1 = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].crossProduct(p1, p2), li2 = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].crossProduct(q1, q2), c = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].crossProduct(li1, li2);
        if (Math.abs(c[0]) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
            return [
                c,
                Infinity,
                Infinity
            ];
        }
        // Normalize the intersection coordinates
        c[1] /= c[0];
        c[2] /= c[0];
        c[0] /= c[0];
        // Now compute in principle:
        //    t = dist(c - p1) / dist(p2 - p1) and
        //    u = dist(c - q1) / dist(q2 - q1)
        // However: the points q1, q2, p1, p2 might be ideal points - or in general - the
        // coordinates might be not normalized.
        // Note that the z-coordinates of p2 and q2 are used to determine whether it should be interpreted
        // as a segment coordinate or a direction.
        i = Math.abs(p2[1] - p2[0] * p1[1]) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps ? 2 : 1;
        d = p1[i] / p1[0];
        t = (c[i] - d) / (p2[0] !== 0 ? p2[i] / p2[0] - d : p2[i]);
        i = Math.abs(q2[1] - q2[0] * q1[1]) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps ? 2 : 1;
        d = q1[i] / q1[0];
        u = (c[i] - d) / (q2[0] !== 0 ? q2[i] / q2[0] - d : q2[i]);
        return [
            c,
            t,
            u
        ];
    },
    /**
         * Find the n-th intersection point of two pathes, usually given by polygons. Uses parts of the
         * Greiner-Hormann algorithm in JXG.Math.Clip.
         *
         * @param {JXG.Circle|JXG.Curve|JXG.Polygon} path1
         * @param {JXG.Circle|JXG.Curve|JXG.Polygon} path2
         * @param {Number|Function} n
         * @param {JXG.Board} board
         *
         * @returns {JXG.Coords} Intersection point. In case no intersection point is detected,
         * the ideal point [0,0,0] is returned.
         *
         */ meetPathPath: function(path1, path2, nr, board) {
        var S, C, len, intersections, n = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evaluate(nr);
        S = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Math.Clip._getPath(path1, board);
        len = S.length;
        if (len > 0 && this.distance(S[0].coords.usrCoords, S[len - 1].coords.usrCoords, 3) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
            S.pop();
        }
        C = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Math.Clip._getPath(path2, board);
        len = C.length;
        if (len > 0 && this.distance(C[0].coords.usrCoords, C[len - 1].coords.usrCoords, 3) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps * __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
            C.pop();
        }
        // Handle cases where at least one of the paths is empty
        if (nr < 0 || __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Math.Clip.isEmptyCase(S, C, "intersection")) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
                0,
                0,
                0
            ], board);
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Math.Clip.makeDoublyLinkedList(S);
        __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Math.Clip.makeDoublyLinkedList(C);
        intersections = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Math.Clip.findIntersections(S, C, board)[0];
        if (n < intersections.length) {
            return intersections[n].coords;
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
            0,
            0,
            0
        ], board);
    },
    /**
         * Find the n-th intersection point between a polygon and a line.
         * @param {JXG.Polygon} path
         * @param {JXG.Line} line
         * @param {Number|Function} nr
         * @param {JXG.Board} board
         * @param {Boolean} alwaysIntersect If false just the segment between the two defining points of the line are tested for intersection.
         *
         * @returns {JXG.Coords} Intersection point. In case no intersection point is detected,
         * the ideal point [0,0,0] is returned.
         */ meetPolygonLine: function(path, line, nr, board, alwaysIntersect) {
        var i, n = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evaluate(nr), res, border, crds = [
            0,
            0,
            0
        ], len = path.borders.length, intersections = [];
        for(i = 0; i < len; i++){
            border = path.borders[i];
            res = this.meetSegmentSegment(border.point1.coords.usrCoords, border.point2.coords.usrCoords, line.point1.coords.usrCoords, line.point2.coords.usrCoords);
            if ((!alwaysIntersect || res[2] >= 0 && res[2] < 1) && res[1] >= 0 && res[1] < 1) {
                intersections.push(res[0]);
            }
        }
        if (n >= 0 && n < intersections.length) {
            crds = intersections[n];
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, crds, board);
    },
    /****************************************/ /****   BEZIER CURVE ALGORITHMS      ****/ /****************************************/ /**
         * Splits a Bezier curve segment defined by four points into
         * two Bezier curve segments. Dissection point is t=1/2.
         * @param {Array} curve Array of four coordinate arrays of length 2 defining a
         * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].
         * @returns {Array} Array consisting of two coordinate arrays for Bezier curves.
         */ _bezierSplit: function(curve) {
        var p0, p1, p2, p00, p22, p000;
        p0 = [
            (curve[0][0] + curve[1][0]) * 0.5,
            (curve[0][1] + curve[1][1]) * 0.5
        ];
        p1 = [
            (curve[1][0] + curve[2][0]) * 0.5,
            (curve[1][1] + curve[2][1]) * 0.5
        ];
        p2 = [
            (curve[2][0] + curve[3][0]) * 0.5,
            (curve[2][1] + curve[3][1]) * 0.5
        ];
        p00 = [
            (p0[0] + p1[0]) * 0.5,
            (p0[1] + p1[1]) * 0.5
        ];
        p22 = [
            (p1[0] + p2[0]) * 0.5,
            (p1[1] + p2[1]) * 0.5
        ];
        p000 = [
            (p00[0] + p22[0]) * 0.5,
            (p00[1] + p22[1]) * 0.5
        ];
        return [
            [
                curve[0],
                p0,
                p00,
                p000
            ],
            [
                p000,
                p22,
                p2,
                curve[3]
            ]
        ];
    },
    /**
         * Computes the bounding box [minX, maxY, maxX, minY] of a Bezier curve segment
         * from its control points.
         * @param {Array} curve Array of four coordinate arrays of length 2 defining a
         * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].
         * @returns {Array} Bounding box [minX, maxY, maxX, minY]
         */ _bezierBbox: function(curve) {
        var bb = [];
        if (curve.length === 4) {
            // bezierDegree == 3
            bb[0] = Math.min(curve[0][0], curve[1][0], curve[2][0], curve[3][0]); // minX
            bb[1] = Math.max(curve[0][1], curve[1][1], curve[2][1], curve[3][1]); // maxY
            bb[2] = Math.max(curve[0][0], curve[1][0], curve[2][0], curve[3][0]); // maxX
            bb[3] = Math.min(curve[0][1], curve[1][1], curve[2][1], curve[3][1]); // minY
        } else {
            // bezierDegree == 1
            bb[0] = Math.min(curve[0][0], curve[1][0]); // minX
            bb[1] = Math.max(curve[0][1], curve[1][1]); // maxY
            bb[2] = Math.max(curve[0][0], curve[1][0]); // maxX
            bb[3] = Math.min(curve[0][1], curve[1][1]); // minY
        }
        return bb;
    },
    /**
         * Decide if two Bezier curve segments overlap by comparing their bounding boxes.
         * @param {Array} bb1 Bounding box of the first Bezier curve segment
         * @param {Array} bb2 Bounding box of the second Bezier curve segment
         * @returns {Boolean} true if the bounding boxes overlap, false otherwise.
         */ _bezierOverlap: function(bb1, bb2) {
        return bb1[2] >= bb2[0] && bb1[0] <= bb2[2] && bb1[1] >= bb2[3] && bb1[3] <= bb2[1];
    },
    /**
         * Append list of intersection points to a list.
         * @private
         */ _bezierListConcat: function(L, Lnew, t1, t2) {
        var i, t2exists = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(t2), start = 0, len = Lnew.length, le = L.length;
        if (le > 0 && len > 0 && (L[le - 1][1] === 1 && Lnew[0][1] === 0 || t2exists && L[le - 1][2] === 1 && Lnew[0][2] === 0)) {
            start = 1;
        }
        for(i = start; i < len; i++){
            if (t2exists) {
                Lnew[i][2] *= 0.5;
                Lnew[i][2] += t2;
            }
            Lnew[i][1] *= 0.5;
            Lnew[i][1] += t1;
            L.push(Lnew[i]);
        }
    },
    /**
         * Find intersections of two Bezier curve segments by recursive subdivision.
         * Below maxlevel determine intersections by intersection line segments.
         * @param {Array} red Array of four coordinate arrays of length 2 defining the first
         * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].
         * @param {Array} blue Array of four coordinate arrays of length 2 defining the second
         * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].
         * @param {Number} level Recursion level
         * @returns {Array} List of intersection points (up to nine). Each intersection point is an
         * array of length three (homogeneous coordinates) plus preimages.
         */ _bezierMeetSubdivision: function(red, blue, level) {
        var bbb, bbr, ar, b0, b1, r0, r1, m, p0, p1, q0, q1, L = [], maxLev = 5; // Maximum recursion level
        bbr = this._bezierBbox(blue);
        bbb = this._bezierBbox(red);
        if (!this._bezierOverlap(bbr, bbb)) {
            return [];
        }
        if (level < maxLev) {
            ar = this._bezierSplit(red);
            r0 = ar[0];
            r1 = ar[1];
            ar = this._bezierSplit(blue);
            b0 = ar[0];
            b1 = ar[1];
            this._bezierListConcat(L, this._bezierMeetSubdivision(r0, b0, level + 1), 0.0, 0.0);
            this._bezierListConcat(L, this._bezierMeetSubdivision(r0, b1, level + 1), 0, 0.5);
            this._bezierListConcat(L, this._bezierMeetSubdivision(r1, b0, level + 1), 0.5, 0.0);
            this._bezierListConcat(L, this._bezierMeetSubdivision(r1, b1, level + 1), 0.5, 0.5);
            return L;
        }
        // Make homogeneous coordinates
        q0 = [
            1
        ].concat(red[0]);
        q1 = [
            1
        ].concat(red[3]);
        p0 = [
            1
        ].concat(blue[0]);
        p1 = [
            1
        ].concat(blue[3]);
        m = this.meetSegmentSegment(q0, q1, p0, p1);
        if (m[1] >= 0.0 && m[2] >= 0.0 && m[1] <= 1.0 && m[2] <= 1.0) {
            return [
                m
            ];
        }
        return [];
    },
    /**
         * @param {Boolean} testSegment Test if intersection has to be inside of the segment or somewhere on the line defined by the segment
         */ _bezierLineMeetSubdivision: function(red, blue, level, testSegment) {
        var bbb, bbr, ar, r0, r1, m, p0, p1, q0, q1, L = [], maxLev = 5; // Maximum recursion level
        bbb = this._bezierBbox(blue);
        bbr = this._bezierBbox(red);
        if (testSegment && !this._bezierOverlap(bbr, bbb)) {
            return [];
        }
        if (level < maxLev) {
            ar = this._bezierSplit(red);
            r0 = ar[0];
            r1 = ar[1];
            this._bezierListConcat(L, this._bezierLineMeetSubdivision(r0, blue, level + 1), 0.0);
            this._bezierListConcat(L, this._bezierLineMeetSubdivision(r1, blue, level + 1), 0.5);
            return L;
        }
        // Make homogeneous coordinates
        q0 = [
            1
        ].concat(red[0]);
        q1 = [
            1
        ].concat(red[3]);
        p0 = [
            1
        ].concat(blue[0]);
        p1 = [
            1
        ].concat(blue[1]);
        m = this.meetSegmentSegment(q0, q1, p0, p1);
        if (m[1] >= 0.0 && m[1] <= 1.0) {
            if (!testSegment || m[2] >= 0.0 && m[2] <= 1.0) {
                return [
                    m
                ];
            }
        }
        return [];
    },
    /**
         * Find the nr-th intersection point of two Bezier curve segments.
         * @param {Array} red Array of four coordinate arrays of length 2 defining the first
         * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].
         * @param {Array} blue Array of four coordinate arrays of length 2 defining the second
         * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].
         * @param {Boolean} testSegment Test if intersection has to be inside of the segment or somewhere on the line defined by the segment
         * @returns {Array} Array containing the list of all intersection points as homogeneous coordinate arrays plus
         * preimages [x,y], t_1, t_2] of the two Bezier curve segments.
         *
         */ meetBeziersegmentBeziersegment: function(red, blue, testSegment) {
        var L, L2, i;
        if (red.length === 4 && blue.length === 4) {
            L = this._bezierMeetSubdivision(red, blue, 0);
        } else {
            L = this._bezierLineMeetSubdivision(red, blue, 0, testSegment);
        }
        L.sort(function(a, b) {
            return (a[1] - b[1]) * 10000000.0 + (a[2] - b[2]);
        });
        L2 = [];
        for(i = 0; i < L.length; i++){
            // Only push entries different from their predecessor
            if (i === 0 || L[i][1] !== L[i - 1][1] || L[i][2] !== L[i - 1][2]) {
                L2.push(L[i]);
            }
        }
        return L2;
    },
    /**
         * Find the nr-th intersection point of two Bezier curves, i.e. curves with bezierDegree == 3.
         * @param {JXG.Curve} red Curve with bezierDegree == 3
         * @param {JXG.Curve} blue Curve with bezierDegree == 3
         * @param {Number|Function} nr The number of the intersection point which should be returned.
         * @returns {Array} The homogeneous coordinates of the nr-th intersection point.
         */ meetBezierCurveRedBlueSegments: function(red, blue, nr) {
        var p, i, j, k, n = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evaluate(nr), po, tmp, redArr, blueArr, bbr, bbb, intersections, startRed = 0, startBlue = 0, lenBlue, lenRed, L = [];
        if (blue.numberPoints < blue.bezierDegree + 1 || red.numberPoints < red.bezierDegree + 1) {
            return [
                0,
                NaN,
                NaN
            ];
        }
        if (red.bezierDegree === 1 && blue.bezierDegree === 3) {
            tmp = red;
            red = blue;
            blue = tmp;
        }
        lenBlue = blue.numberPoints - blue.bezierDegree;
        lenRed = red.numberPoints - red.bezierDegree;
        // For sectors, we ignore the "legs"
        if (red.type === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_TYPE_SECTOR) {
            startRed = 3;
            lenRed -= 3;
        }
        if (blue.type === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_TYPE_SECTOR) {
            startBlue = 3;
            lenBlue -= 3;
        }
        for(i = startRed; i < lenRed; i += red.bezierDegree){
            p = red.points;
            redArr = [
                p[i].usrCoords.slice(1),
                p[i + 1].usrCoords.slice(1)
            ];
            if (red.bezierDegree === 3) {
                redArr[2] = p[i + 2].usrCoords.slice(1);
                redArr[3] = p[i + 3].usrCoords.slice(1);
            }
            bbr = this._bezierBbox(redArr);
            for(j = startBlue; j < lenBlue; j += blue.bezierDegree){
                p = blue.points;
                blueArr = [
                    p[j].usrCoords.slice(1),
                    p[j + 1].usrCoords.slice(1)
                ];
                if (blue.bezierDegree === 3) {
                    blueArr[2] = p[j + 2].usrCoords.slice(1);
                    blueArr[3] = p[j + 3].usrCoords.slice(1);
                }
                bbb = this._bezierBbox(blueArr);
                if (this._bezierOverlap(bbr, bbb)) {
                    intersections = this.meetBeziersegmentBeziersegment(redArr, blueArr);
                    if (intersections.length === 0) {
                        continue;
                    }
                    for(k = 0; k < intersections.length; k++){
                        po = intersections[k];
                        if (po[1] < -__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps || po[1] > 1 + __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps || po[2] < -__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps || po[2] > 1 + __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
                            continue;
                        }
                        L.push(po);
                    }
                    if (L.length > n) {
                        return L[n][0];
                    }
                }
            }
        }
        if (L.length > n) {
            return L[n][0];
        }
        return [
            0,
            NaN,
            NaN
        ];
    },
    bezierSegmentEval: function(t, curve) {
        var f, x, y, t1 = 1.0 - t;
        x = 0;
        y = 0;
        f = t1 * t1 * t1;
        x += f * curve[0][0];
        y += f * curve[0][1];
        f = 3.0 * t * t1 * t1;
        x += f * curve[1][0];
        y += f * curve[1][1];
        f = 3.0 * t * t * t1;
        x += f * curve[2][0];
        y += f * curve[2][1];
        f = t * t * t;
        x += f * curve[3][0];
        y += f * curve[3][1];
        return [
            1.0,
            x,
            y
        ];
    },
    /**
         * Generate the defining points of a 3rd degree bezier curve that approximates
         * a circle sector defined by three coordinate points A, B, C, each defined by an array of length three.
         * The coordinate arrays are given in homogeneous coordinates.
         * @param {Array} A First point
         * @param {Array} B Second point (intersection point)
         * @param {Array} C Third point
         * @param {Boolean} withLegs Flag. If true the legs to the intersection point are part of the curve.
         * @param {Number} sgn Wither 1 or -1. Needed for minor and major arcs. In case of doubt, use 1.
         */ bezierArc: function(A, B, C, withLegs, sgn) {
        var p1, p2, p3, p4, r, phi, beta, delta, // PI2 = Math.PI * 0.5,
        x = B[1], y = B[2], z = B[0], dataX = [], dataY = [], co, si, ax, ay, bx, by, k, v, d, matrix;
        r = this.distance(B, A);
        // x,y, z is intersection point. Normalize it.
        x /= z;
        y /= z;
        phi = this.rad(A.slice(1), B.slice(1), C.slice(1));
        if (sgn === -1) {
            phi = 2 * Math.PI - phi;
        }
        // Always divide the arc into four Bezier arcs.
        // Otherwise, the position of gliders on this arc
        // will be wrong.
        delta = phi / 4;
        p1 = A;
        p1[1] /= p1[0];
        p1[2] /= p1[0];
        p1[0] /= p1[0];
        p4 = p1.slice(0);
        if (withLegs) {
            dataX = [
                x,
                x + 0.333 * (p1[1] - x),
                x + 0.666 * (p1[1] - x),
                p1[1]
            ];
            dataY = [
                y,
                y + 0.333 * (p1[2] - y),
                y + 0.666 * (p1[2] - y),
                p1[2]
            ];
        } else {
            dataX = [
                p1[1]
            ];
            dataY = [
                p1[2]
            ];
        }
        while(phi > __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps){
            // if (phi > PI2) {
            //     beta = PI2;
            //     phi -= PI2;
            // } else {
            //     beta = phi;
            //     phi = 0;
            // }
            if (phi > delta) {
                beta = delta;
                phi -= delta;
            } else {
                beta = phi;
                phi = 0;
            }
            co = Math.cos(sgn * beta);
            si = Math.sin(sgn * beta);
            matrix = [
                [
                    1,
                    0,
                    0
                ],
                [
                    x * (1 - co) + y * si,
                    co,
                    -si
                ],
                [
                    y * (1 - co) - x * si,
                    si,
                    co
                ]
            ];
            v = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].matVecMult(matrix, p1);
            p4 = [
                v[0] / v[0],
                v[1] / v[0],
                v[2] / v[0]
            ];
            ax = p1[1] - x;
            ay = p1[2] - y;
            bx = p4[1] - x;
            by = p4[2] - y;
            d = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].hypot(ax + bx, ay + by);
            if (Math.abs(by - ay) > __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
                k = (ax + bx) * (r / d - 0.5) / (by - ay) * 8 / 3;
            } else {
                k = (ay + by) * (r / d - 0.5) / (ax - bx) * 8 / 3;
            }
            p2 = [
                1,
                p1[1] - k * ay,
                p1[2] + k * ax
            ];
            p3 = [
                1,
                p4[1] + k * by,
                p4[2] - k * bx
            ];
            __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].concat(dataX, [
                p2[1],
                p3[1],
                p4[1]
            ]);
            __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].concat(dataY, [
                p2[2],
                p3[2],
                p4[2]
            ]);
            p1 = p4.slice(0);
        }
        if (withLegs) {
            __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].concat(dataX, [
                p4[1] + 0.333 * (x - p4[1]),
                p4[1] + 0.666 * (x - p4[1]),
                x
            ]);
            __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].concat(dataY, [
                p4[2] + 0.333 * (y - p4[2]),
                p4[2] + 0.666 * (y - p4[2]),
                y
            ]);
        }
        return [
            dataX,
            dataY
        ];
    },
    /****************************************/ /****           PROJECTIONS          ****/ /****************************************/ /**
         * Calculates the coordinates of the projection of a given point on a given circle. I.o.w. the
         * nearest one of the two intersection points of the line through the given point and the circles
         * center.
         * @param {JXG.Point|JXG.Coords} point Point to project or coords object to project.
         * @param {JXG.Circle} circle Circle on that the point is projected.
         * @param {JXG.Board} [board=point.board] Reference to the board
         * @returns {JXG.Coords} The coordinates of the projection of the given point on the given circle.
         */ projectPointToCircle: function(point, circle, board) {
        var dist, P, x, y, factor, M = circle.center.coords.usrCoords;
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(board)) {
            board = point.board;
        }
        // gave us a point
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isPoint(point)) {
            dist = point.coords.distance(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, circle.center.coords);
            P = point.coords.usrCoords;
        // gave us coords
        } else {
            dist = point.distance(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, circle.center.coords);
            P = point.usrCoords;
        }
        if (Math.abs(dist) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
            dist = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps;
        }
        factor = circle.Radius() / dist;
        x = M[1] + factor * (P[1] - M[1]);
        y = M[2] + factor * (P[2] - M[2]);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
            x,
            y
        ], board);
    },
    /**
         * Calculates the coordinates of the orthogonal projection of a given point on a given line. I.o.w. the
         * intersection point of the given line and its perpendicular through the given point.
         * @param {JXG.Point|JXG.Coords} point Point to project.
         * @param {JXG.Line} line Line on that the point is projected.
         * @param {JXG.Board} [board=point.board|board=line.board] Reference to a board.
         * @returns {JXG.Coords} The coordinates of the projection of the given point on the given line.
         */ projectPointToLine: function(point, line, board) {
        var v = [
            0,
            line.stdform[1],
            line.stdform[2]
        ], coords;
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(board)) {
            if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(point.coords)) {
                board = point.board;
            } else {
                board = line.board;
            }
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(point.coords)) {
            coords = point.coords.usrCoords;
        } else {
            coords = point.usrCoords;
        }
        v = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].crossProduct(v, coords);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].crossProduct(v, line.stdform), board);
    },
    /**
         * Calculates the coordinates of the orthogonal projection of a given coordinate array on a given line
         * segment defined by two coordinate arrays.
         * @param {Array} p Point to project.
         * @param {Array} q1 Start point of the line segment on that the point is projected.
         * @param {Array} q2 End point of the line segment on that the point is projected.
         * @returns {Array} The coordinates of the projection of the given point on the given segment
         * and the factor that determines the projected point as a convex combination of the
         * two endpoints q1 and q2 of the segment.
         */ projectCoordsToSegment: function(p, q1, q2) {
        var t, denom, s = [
            q2[1] - q1[1],
            q2[2] - q1[2]
        ], v = [
            p[1] - q1[1],
            p[2] - q1[2]
        ];
        /**
             * If the segment has length 0, i.e. is a point,
             * the projection is equal to that point.
             */ if (Math.abs(s[0]) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps && Math.abs(s[1]) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
            return [
                q1,
                0
            ];
        }
        t = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].innerProduct(v, s);
        denom = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].innerProduct(s, s);
        t /= denom;
        return [
            [
                1,
                t * s[0] + q1[1],
                t * s[1] + q1[2]
            ],
            t
        ];
    },
    /**
         * Finds the coordinates of the closest point on a Bezier segment of a
         * {@link JXG.Curve} to a given coordinate array.
         * @param {Array} pos Point to project in homogeneous coordinates.
         * @param {JXG.Curve} curve Curve of type "plot" having Bezier degree 3.
         * @param {Number} start Number of the Bezier segment of the curve.
         * @returns {Array} The coordinates of the projection of the given point
         * on the given Bezier segment and the preimage of the curve which
         * determines the closest point.
         */ projectCoordsToBeziersegment: function(pos, curve, start) {
        var t0, /** @ignore */ minfunc = function(t) {
            var z = [
                1,
                curve.X(start + t),
                curve.Y(start + t)
            ];
            z[1] -= pos[1];
            z[2] -= pos[2];
            return z[1] * z[1] + z[2] * z[2];
        };
        t0 = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Math.Numerics.fminbr(minfunc, [
            0.0,
            1.0
        ]);
        return [
            [
                1,
                curve.X(t0 + start),
                curve.Y(t0 + start)
            ],
            t0
        ];
    },
    /**
         * Calculates the coordinates of the projection of a given point on a given curve.
         * Uses {@link JXG.Math.Geometry.projectCoordsToCurve}.
         *
         * @param {JXG.Point} point Point to project.
         * @param {JXG.Curve} curve Curve on that the point is projected.
         * @param {JXG.Board} [board=point.board] Reference to a board.
         * @see JXG.Math.Geometry.projectCoordsToCurve
         * @returns {Array} [JXG.Coords, position] The coordinates of the projection of the given
         * point on the given graph and the relative position on the curve (real number).
         */ projectPointToCurve: function(point, curve, board) {
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(board)) {
            board = point.board;
        }
        var x = point.X(), y = point.Y(), t = point.position, result;
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(t)) {
            t = curve.evalVisProp('curvetype') === 'functiongraph' ? x : 0.0;
        }
        result = this.projectCoordsToCurve(x, y, t, curve, board);
        // point.position = result[1];
        return result;
    },
    /**
         * Calculates the coordinates of the projection of a coordinates pair on a given curve. In case of
         * function graphs this is the
         * intersection point of the curve and the parallel to y-axis through the given point.
         * @param {Number} x coordinate to project.
         * @param {Number} y coordinate to project.
         * @param {Number} t start value for newtons method
         * @param {JXG.Curve} curve Curve on that the point is projected.
         * @param {JXG.Board} [board=curve.board] Reference to a board.
         * @see JXG.Math.Geometry.projectPointToCurve
         * @returns {JXG.Coords} Array containing the coordinates of the projection of the given point on the given curve and
         * the position on the curve.
         */ projectCoordsToCurve: function(x, y, t, curve, board) {
        var newCoords, newCoordsObj, i, j, mindist, dist, lbda, v, coords, d, p1, p2, res, minfunc, t_new, f_new, f_old, dy, delta, delta1, delta2, steps, minX, maxX, minX_glob, maxX_glob, infty = Number.POSITIVE_INFINITY;
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(board)) {
            board = curve.board;
        }
        if (curve.evalVisProp('curvetype') === "plot") {
            t = 0;
            mindist = infty;
            if (curve.numberPoints === 0) {
                newCoords = [
                    0,
                    1,
                    1
                ];
            } else {
                newCoords = [
                    curve.Z(0),
                    curve.X(0),
                    curve.Y(0)
                ];
            }
            if (curve.numberPoints > 1) {
                v = [
                    1,
                    x,
                    y
                ];
                if (curve.bezierDegree === 3) {
                    j = 0;
                } else {
                    p1 = [
                        curve.Z(0),
                        curve.X(0),
                        curve.Y(0)
                    ];
                }
                for(i = 0; i < curve.numberPoints - 1; i++){
                    if (curve.bezierDegree === 3) {
                        res = this.projectCoordsToBeziersegment(v, curve, j);
                    } else {
                        p2 = [
                            curve.Z(i + 1),
                            curve.X(i + 1),
                            curve.Y(i + 1)
                        ];
                        res = this.projectCoordsToSegment(v, p1, p2);
                    }
                    lbda = res[1];
                    coords = res[0];
                    if (0.0 <= lbda && lbda <= 1.0) {
                        dist = this.distance(coords, v);
                        d = i + lbda;
                    } else if (lbda < 0.0) {
                        coords = p1;
                        dist = this.distance(p1, v);
                        d = i;
                    } else if (lbda > 1.0 && i === curve.numberPoints - 2) {
                        coords = p2;
                        dist = this.distance(coords, v);
                        d = curve.numberPoints - 1;
                    }
                    if (dist < mindist) {
                        mindist = dist;
                        t = d;
                        newCoords = coords;
                    }
                    if (curve.bezierDegree === 3) {
                        j++;
                        i += 2;
                    } else {
                        p1 = p2;
                    }
                }
            }
            newCoordsObj = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, newCoords, board);
        } else {
            // 'parameter', 'polar', 'functiongraph'
            minX_glob = curve.minX();
            maxX_glob = curve.maxX();
            minX = minX_glob;
            maxX = maxX_glob;
            if (curve.evalVisProp('curvetype') === 'functiongraph') {
                // Restrict the possible position of t
                // to the projection of a circle to the x-axis (= t-axis)
                dy = Math.abs(y - curve.Y(x));
                if (!isNaN(dy)) {
                    minX = x - dy;
                    maxX = x + dy;
                }
            }
            /**
                 * @ignore
                 * Find t such that the Euclidean distance between
                 * [x, y] and [curve.X(t), curve.Y(t)]
                 * is minimized.
                 */ minfunc = function(t) {
                var dx, dy;
                if (t < minX_glob || t > curve.maxX_glob) {
                    return Infinity;
                }
                dx = x - curve.X(t);
                dy = y - curve.Y(t);
                return dx * dx + dy * dy;
            };
            // Search t which minimizes minfunc(t)
            // in discrete steps
            f_old = minfunc(t);
            steps = 50;
            delta = (maxX - minX) / steps;
            t_new = minX;
            for(i = 0; i < steps; i++){
                f_new = minfunc(t_new);
                if (f_new < f_old || f_old === Infinity || isNaN(f_old)) {
                    t = t_new;
                    f_old = f_new;
                }
                t_new += delta;
            }
            // t = Numerics.root(Numerics.D(minfunc), t);
            // Ensure that minfunc is defined on the
            // enclosing interval [t-delta1, t+delta2]
            delta1 = delta;
            for(i = 0; i < 20 && isNaN(minfunc(t - delta1)); i++, delta1 *= 0.5);
            if (isNaN(minfunc(t - delta1))) {
                delta1 = 0.0;
            }
            delta2 = delta;
            for(i = 0; i < 20 && isNaN(minfunc(t + delta2)); i++, delta2 *= 0.5);
            if (isNaN(minfunc(t + delta2))) {
                delta2 = 0.0;
            }
            // Finally, apply mathemetical optimization in the determined interval
            t = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$numerics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fminbr(minfunc, [
                Math.max(t - delta1, minX),
                Math.min(t + delta2, maxX)
            ]);
            // Distinction between closed and open curves is not necessary.
            // If closed, the cyclic projection shift will work anyhow
            // if (Math.abs(curve.X(minX) - curve.X(maxX)) < Mat.eps &&
            //     Math.abs(curve.Y(minX) - curve.Y(maxX)) < Mat.eps) {
            //     // Cyclically
            //     if (t < minX) {console.log(t)
            //         t = maxX + t - minX;
            //     }
            //     if (t > maxX) {
            //         t = minX + t - maxX;
            //     }
            // } else {
            t = t < minX_glob ? minX_glob : t;
            t = t > maxX_glob ? maxX_glob : t;
            // }
            newCoordsObj = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
                curve.X(t),
                curve.Y(t)
            ], board);
        }
        return [
            curve.updateTransform(newCoordsObj),
            t
        ];
    },
    /**
         * Calculates the coordinates of the closest orthogonal projection of a given coordinate array onto the
         * border of a polygon.
         * @param {Array} p Point to project.
         * @param {JXG.Polygon} pol Polygon element
         * @returns {Array} The coordinates of the closest projection of the given point to the border of the polygon.
         */ projectCoordsToPolygon: function(p, pol) {
        var i, len = pol.vertices.length, d_best = Infinity, d, projection, proj, bestprojection;
        for(i = 0; i < len - 1; i++){
            projection = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Math.Geometry.projectCoordsToSegment(p, pol.vertices[i].coords.usrCoords, pol.vertices[i + 1].coords.usrCoords);
            if (0 <= projection[1] && projection[1] <= 1) {
                d = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Math.Geometry.distance(projection[0], p, 3);
                proj = projection[0];
            } else if (projection[1] < 0) {
                d = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Math.Geometry.distance(pol.vertices[i].coords.usrCoords, p, 3);
                proj = pol.vertices[i].coords.usrCoords;
            } else {
                d = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Math.Geometry.distance(pol.vertices[i + 1].coords.usrCoords, p, 3);
                proj = pol.vertices[i + 1].coords.usrCoords;
            }
            if (d < d_best) {
                bestprojection = proj.slice(0);
                d_best = d;
            }
        }
        return bestprojection;
    },
    /**
         * Calculates the coordinates of the projection of a given point on a given turtle. A turtle consists of
         * one or more curves of curveType 'plot'. Uses {@link JXG.Math.Geometry.projectPointToCurve}.
         * @param {JXG.Point} point Point to project.
         * @param {JXG.Turtle} turtle on that the point is projected.
         * @param {JXG.Board} [board=point.board] Reference to a board.
         * @returns {Array} [JXG.Coords, position] Array containing the coordinates of the projection of the given point on the turtle and
         * the position on the turtle.
         */ projectPointToTurtle: function(point, turtle, board) {
        var newCoords, t, x, y, i, dist, el, minEl, res, newPos, np = 0, npmin = 0, mindist = Number.POSITIVE_INFINITY, len = turtle.objects.length;
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(board)) {
            board = point.board;
        }
        // run through all curves of this turtle
        for(i = 0; i < len; i++){
            el = turtle.objects[i];
            if (el.elementClass === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_CLASS_CURVE) {
                res = this.projectPointToCurve(point, el);
                newCoords = res[0];
                newPos = res[1];
                dist = this.distance(newCoords.usrCoords, point.coords.usrCoords);
                if (dist < mindist) {
                    x = newCoords.usrCoords[1];
                    y = newCoords.usrCoords[2];
                    t = newPos;
                    mindist = dist;
                    minEl = el;
                    npmin = np;
                }
                np += el.numberPoints;
            }
        }
        newCoords = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
            x,
            y
        ], board);
        // point.position = t + npmin;
        // return minEl.updateTransform(newCoords);
        return [
            minEl.updateTransform(newCoords),
            t + npmin
        ];
    },
    /**
         * Trivial projection of a point to another point.
         * @param {JXG.Point} point Point to project (not used).
         * @param {JXG.Point} dest Point on that the point is projected.
         * @returns {JXG.Coords} The coordinates of the projection of the given point on the given circle.
         */ projectPointToPoint: function(point, dest) {
        return dest.coords;
    },
    /**
         *
         * @param {JXG.Point|JXG.Coords} point
         * @param {JXG.Board} [board]
         */ projectPointToBoard: function(point, board) {
        var i, l, c, brd = board || point.board, // comparison factor, point coord idx, bbox idx, 1st bbox corner x & y idx, 2nd bbox corner x & y idx
        config = [
            // left
            [
                1,
                1,
                0,
                0,
                3,
                0,
                1
            ],
            // top
            [
                -1,
                2,
                1,
                0,
                1,
                2,
                1
            ],
            // right
            [
                -1,
                1,
                2,
                2,
                1,
                2,
                3
            ],
            // bottom
            [
                1,
                2,
                3,
                0,
                3,
                2,
                3
            ]
        ], coords = point.coords || point, bbox = brd.getBoundingBox();
        for(i = 0; i < 4; i++){
            c = config[i];
            if (c[0] * coords.usrCoords[c[1]] < c[0] * bbox[c[2]]) {
                // define border
                l = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].crossProduct([
                    1,
                    bbox[c[3]],
                    bbox[c[4]]
                ], [
                    1,
                    bbox[c[5]],
                    bbox[c[6]]
                ]);
                l[3] = 0;
                l = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalize(l);
                // project point
                coords = this.projectPointToLine({
                    coords: coords
                }, {
                    stdform: l
                }, brd);
            }
        }
        return coords;
    },
    /**
         * Calculates the distance of a point to a line. The point and the line are given by homogeneous
         * coordinates. For lines this can be line.stdform.
         * @param {Array} point Homogeneous coordinates of a point.
         * @param {Array} line Homogeneous coordinates of a line ([C,A,B] where A*x+B*y+C*z=0).
         * @returns {Number} Distance of the point to the line.
         */ distPointLine: function(point, line) {
        var a = line[1], b = line[2], c = line[0], nom;
        if (Math.abs(a) + Math.abs(b) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
            return Number.POSITIVE_INFINITY;
        }
        nom = a * point[1] + b * point[2] + c;
        a *= a;
        b *= b;
        return Math.abs(nom) / Math.sqrt(a + b);
    },
    /**
         * Determine the (Euclidean) distance between a point q and a line segment
         * defined by two points p1 and p2. In case p1 equals p2, the distance to this
         * point is returned.
         *
         * @param {Array} q Homogeneous coordinates of q
         * @param {Array} p1 Homogeneous coordinates of p1
         * @param {Array} p2 Homogeneous coordinates of p2
         * @returns {Number} Distance of q to line segment [p1, p2]
         */ distPointSegment: function(q, p1, p2) {
        var x, y, dx, dy, den, lbda, eps = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps * __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps, huge = 1000000;
        // Difference q - p1
        x = q[1] - p1[1];
        y = q[2] - p1[2];
        x = x === Infinity ? huge : x === -Infinity ? -huge : x;
        y = y === Infinity ? huge : y === -Infinity ? -huge : y;
        // Difference p2 - p1
        dx = p2[1] - p1[1];
        dy = p2[2] - p1[2];
        dx = dx === Infinity ? huge : dx === -Infinity ? -huge : dx;
        dy = dy === Infinity ? huge : dy === -Infinity ? -huge : dy;
        // If den==0 then p1 and p2 are identical
        // In this case the distance to p1 is returned
        den = dx * dx + dy * dy;
        if (den > eps) {
            lbda = (x * dx + y * dy) / den;
            if (lbda < 0.0) {
                lbda = 0.0;
            } else if (lbda > 1.0) {
                lbda = 1.0;
            }
            x -= lbda * dx;
            y -= lbda * dy;
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].hypot(x, y);
    },
    /* ***************************************/ /* *** 3D CALCULATIONS ****/ /* ***************************************/ /**
         * Generate the function which computes the data of the intersection between
         * <ul>
         * <li> plane3d, plane3d,
         * <li> plane3d, sphere3d,
         * <li> sphere3d, plane3d,
         * <li> sphere3d, sphere3d
         * </ul>
         *
         * @param {JXG.GeometryElement3D} el1 Plane or sphere element
         * @param {JXG.GeometryElement3D} el2 Plane or sphere element
         * @returns {Array} of functions needed as input to create the intersecting line or circle.
         *
         */ intersectionFunction3D: function(view, el1, el2) {
        var func, that = this;
        if (el1.type === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_TYPE_PLANE3D) {
            if (el2.type === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_TYPE_PLANE3D) {
                // func = () => view.intersectionPlanePlane(el1, el2)[i];
                func = view.intersectionPlanePlane(el1, el2);
            } else if (el2.type === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_TYPE_SPHERE3D) {
                func = that.meetPlaneSphere(el1, el2);
            }
        } else if (el1.type === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_TYPE_SPHERE3D) {
            if (el2.type === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_TYPE_PLANE3D) {
                func = that.meetPlaneSphere(el2, el1);
            } else if (el2.type === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_TYPE_SPHERE3D) {
                func = that.meetSphereSphere(el1, el2);
            }
        }
        return func;
    },
    /**
         * Intersecting point of three planes in 3D. The planes
         * are given in Hesse normal form.
         *
         * @param {Array} n1 Hesse normal form vector of plane 1
         * @param {Number} d1 Hesse normal form right hand side of plane 1
         * @param {Array} n2 Hesse normal form vector of plane 2
         * @param {Number} d2 Hesse normal form right hand side of plane 2
         * @param {Array} n3 Hesse normal form vector of plane 1
         * @param {Number} d3 Hesse normal form right hand side of plane 3
         * @returns {Array} Coordinates array of length 4 of the intersecting point
         */ meet3Planes: function(n1, d1, n2, d2, n3, d3) {
        var p = [
            1,
            0,
            0,
            0
        ], n31, n12, n23, denom, i;
        n31 = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].crossProduct(n3.slice(1), n1.slice(1));
        n12 = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].crossProduct(n1.slice(1), n2.slice(1));
        n23 = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].crossProduct(n2.slice(1), n3.slice(1));
        denom = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].innerProduct(n1.slice(1), n23, 3);
        for(i = 0; i < 3; i++){
            p[i + 1] = (d1 * n23[i] + d2 * n31[i] + d3 * n12[i]) / denom;
        }
        return p;
    },
    /**
         * Direction of intersecting line of two planes in 3D.
         *
         * @param {Array} v11 First vector spanning plane 1 (homogeneous coordinates)
         * @param {Array} v12 Second vector spanning plane 1 (homogeneous coordinates)
         * @param {Array} v21 First vector spanning plane 2 (homogeneous coordinates)
         * @param {Array} v22 Second vector spanning plane 2 (homogeneous coordinates)
         * @returns {Array} Coordinates array of length 4 of the direction  (homogeneous coordinates)
         */ meetPlanePlane: function(v11, v12, v21, v22) {
        var no1, no2, v, w;
        v = v11.slice(1);
        w = v12.slice(1);
        no1 = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].crossProduct(v, w);
        v = v21.slice(1);
        w = v22.slice(1);
        no2 = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].crossProduct(v, w);
        w = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].crossProduct(no1, no2);
        w.unshift(0);
        return w;
    },
    meetPlaneSphere: function(el1, el2) {
        var dis = function() {
            return __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].innerProduct(el1.normal, el2.center.coords, 4) - el1.d;
        };
        return [
            // Center
            function() {
                return __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].axpy(-dis(), el1.normal, el2.center.coords);
            },
            // Normal
            el1.normal,
            // Radius
            function() {
                // Radius (returns NaN if spheres don't touch)
                var r = el2.Radius(), s = dis();
                return Math.sqrt(r * r - s * s);
            }
        ];
    },
    meetSphereSphere: function(el1, el2) {
        var skew = function() {
            var dist = el1.center.distance(el2.center), r1 = el1.Radius(), r2 = el2.Radius();
            return (r1 - r2) * (r1 + r2) / (dist * dist);
        };
        return [
            // Center
            function() {
                var s = skew();
                return [
                    1,
                    0.5 * ((1 - s) * el1.center.coords[1] + (1 + s) * el2.center.coords[1]),
                    0.5 * ((1 - s) * el1.center.coords[2] + (1 + s) * el2.center.coords[2]),
                    0.5 * ((1 - s) * el1.center.coords[3] + (1 + s) * el2.center.coords[3])
                ];
            },
            // Normal
            function() {
                return __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$statistics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].subtract(el2.center.coords, el1.center.coords);
            },
            // Radius
            function() {
                // Radius (returns NaN if spheres don't touch)
                var dist = el1.center.distance(el2.center), r1 = el1.Radius(), r2 = el2.Radius(), s = skew(), rIxnSq = 0.5 * (r1 * r1 + r2 * r2 - 0.5 * dist * dist * (1 + s * s));
                return Math.sqrt(rIxnSq);
            }
        ];
    },
    /**
         * Test if parameters are inside of allowed ranges
         *
         * @param {Array} params Array of length 1 or 2
         * @param {Array} r_u First range
         * @param {Array} [r_v] Second range
         * @returns Boolean
         * @private
         */ _paramsOutOfRange: function(params, r_u, r_v) {
        return params[0] < r_u[0] || params[0] > r_u[1] || params.length > 1 && (params[1] < r_v[0] || params[1] > r_v[1]);
    },
    /**
         * Given the 2D screen coordinates of a point, finds the nearest point on the given
         * parametric curve or surface, and returns its view-space coordinates.
         * @param {Array} p 3D coordinates for which the closest point on the curve point is searched.
         * @param {JXG.Curve3D|JXG.Surface3D} target Parametric curve or surface to project to.
         * @param {Array} params New position of point on the target (i.e. it is a return value),
         * modified in place during the search, ending up at the nearest point.
         * Usually, point.position is supplied for params.
         *
         * @returns {Array} Array of length 4 containing the coordinates of the nearest point on the curve or surface.
         */ projectCoordsToParametric: function(p, target, n, params) {
        // The variables and parameters for the Cobyla constrained
        // minimization algorithm are explained in the Cobyla.js comments
        var rhobeg, rhoend, iprint = 0, maxfun = 200, _minFunc, f = Math.random() * 0.01 + 0.5, r_u, r_v, m = 2 * n;
        // adapt simplex size to parameter range
        if (n === 1) {
            r_u = [
                __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evaluate(target.range[0]),
                __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evaluate(target.range[1])
            ];
            rhobeg = 0.1 * (r_u[1] - r_u[0]);
        } else if (n === 2) {
            r_u = [
                __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evaluate(target.range_u[0]),
                __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evaluate(target.range_u[1])
            ];
            r_v = [
                __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evaluate(target.range_v[0]),
                __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evaluate(target.range_v[1])
            ];
            rhobeg = 0.1 * Math.min(r_u[1] - r_u[0], r_v[1] - r_v[0]);
        }
        rhoend = rhobeg / 5e6;
        // Minimize distance of the new position to the original position
        _minFunc = function(n, m, w, con) {
            var p_new = [
                target.X.apply(target, w),
                target.Y.apply(target, w),
                target.Z.apply(target, w)
            ], xDiff = p[0] - p_new[0], yDiff = p[1] - p_new[1], zDiff = p[2] - p_new[2];
            if (m >= 2) {
                con[0] = w[0] - r_u[0];
                con[1] = -w[0] + r_u[1];
            }
            if (m >= 4) {
                con[2] = w[1] - r_v[0];
                con[3] = -w[1] + r_v[1];
            }
            return xDiff * xDiff + yDiff * yDiff + zDiff * zDiff;
        };
        // First optimization without range constraints to give a smooth draag experience on
        // cyclic structures.
        // Set the start values
        if (params.length === 0) {
            // If length > 0: take the previous position as start values for the optimization
            params[0] = f * (r_u[0] + r_u[1]);
            if (n === 2) {
                params[1] = f * (r_v[0] + r_v[1]);
            }
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Nlp.FindMinimum(_minFunc, n, 0, params, rhobeg, rhoend, iprint, maxfun);
        // Update p which is used subsequently in _minFunc
        p = [
            target.X.apply(target, params),
            target.Y.apply(target, params),
            target.Z.apply(target, params)
        ];
        // If the optimal params are outside of the rang
        // Second optimization to obey the range constraints
        if (this._paramsOutOfRange(params, r_u, r_v)) {
            // Set the start values again
            params[0] = f * (r_u[0] + r_u[1]);
            if (n === 2) {
                params[1] = f * (r_v[0] + r_v[1]);
            }
            __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Nlp.FindMinimum(_minFunc, n, m, params, rhobeg, rhoend, iprint, maxfun);
        }
        return [
            1,
            target.X.apply(target, params),
            target.Y.apply(target, params),
            target.Z.apply(target, params)
        ];
    },
    // /**
    //  * Given a the screen coordinates of a point, finds the point on the
    //  * given parametric curve or surface which is nearest in screen space,
    //  * and returns its view-space coordinates.
    //  * @param {Array} pScr Screen coordinates to project.
    //  * @param {JXG.Curve3D|JXG.Surface3D} target Parametric curve or surface to project to.
    //  * @param {Array} params Parameters of point on the target, initially specifying the starting point of
    //  * the search. The parameters are modified in place during the search, ending up at the nearest point.
    //  * @returns {Array} Array of length 4 containing the coordinates of the nearest point on the curve or surface.
    //  */
    // projectScreenCoordsToParametric: function (pScr, target, params) {
    //     // The variables and parameters for the Cobyla constrained
    //     // minimization algorithm are explained in the Cobyla.js comments
    //     var rhobeg, // initial size of simplex (Cobyla)
    //         rhoend, // finial size of simplex (Cobyla)
    //         iprint = 0, // no console output (Cobyla)
    //         maxfun = 200, // call objective function at most 200 times (Cobyla)
    //         dim = params.length,
    //         _minFunc; // objective function (Cobyla)
    //     // adapt simplex size to parameter range
    //     if (dim === 1) {
    //         rhobeg = 0.1 * (target.range[1] - target.range[0]);
    //     } else if (dim === 2) {
    //         rhobeg = 0.1 * Math.min(
    //             target.range_u[1] - target.range_u[0],
    //             target.range_v[1] - target.range_v[0]
    //         );
    //     }
    //     rhoend = rhobeg / 5e6;
    //     // minimize screen distance to cursor
    //     _minFunc = function (n, m, w, con) {
    //         var c3d = [
    //             1,
    //             target.X.apply(target, w),
    //             target.Y.apply(target, w),
    //             target.Z.apply(target, w)
    //         ],
    //         c2d = target.view.project3DTo2D(c3d),
    //         xDiff = pScr[0] - c2d[1],
    //         yDiff = pScr[1] - c2d[2];
    //         if (n === 1) {
    //             con[0] = w[0] - target.range[0];
    //             con[1] = -w[0] + target.range[1];
    //         } else if (n === 2) {
    //             con[0] = w[0] - target.range_u[0];
    //             con[1] = -w[0] + target.range_u[1];
    //             con[2] = w[1] - target.range_v[0];
    //             con[3] = -w[1] + target.range_v[1];
    //         }
    //         return xDiff * xDiff + yDiff * yDiff;
    //     };
    //     Mat.Nlp.FindMinimum(_minFunc, dim, 2 * dim, params, rhobeg, rhoend, iprint, maxfun);
    //     return [1, target.X.apply(target, params), target.Y.apply(target, params), target.Z.apply(target, params)];
    // },
    project3DTo3DPlane: function(point, normal, foot) {
        // TODO: homogeneous 3D coordinates
        var sol = [
            0,
            0,
            0
        ], le, d1, d2, lbda;
        foot = foot || [
            0,
            0,
            0
        ];
        le = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].norm(normal);
        d1 = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].innerProduct(point, normal, 3);
        d2 = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].innerProduct(foot, normal, 3);
        // (point - lbda * normal / le) * normal / le == foot * normal / le
        // => (point * normal - foot * normal) ==  lbda * le
        lbda = (d1 - d2) / le;
        sol = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].axpy(-lbda, normal, point);
        return sol;
    },
    getPlaneBounds: function(v1, v2, q, s, e) {
        var s1, s2, e1, e2, mat, rhs, sol;
        if (v1[2] + v2[0] !== 0) {
            mat = [
                [
                    v1[0],
                    v2[0]
                ],
                [
                    v1[1],
                    v2[1]
                ]
            ];
            rhs = [
                s - q[0],
                s - q[1]
            ];
            sol = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$numerics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Gauss(mat, rhs);
            s1 = sol[0];
            s2 = sol[1];
            rhs = [
                e - q[0],
                e - q[1]
            ];
            sol = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$numerics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Gauss(mat, rhs);
            e1 = sol[0];
            e2 = sol[1];
            return [
                s1,
                e1,
                s2,
                e2
            ];
        }
        return null;
    },
    /* ***************************************/ /* *** Various ****/ /* ***************************************/ /**
         * Helper function to create curve which displays a Reuleaux polygons.
         * @param {Array} points Array of points which should be the vertices of the Reuleaux polygon. Typically,
         * these point list is the array vertices of a regular polygon.
         * @param {Number} nr Number of vertices
         * @returns {Array} An array containing the two functions defining the Reuleaux polygon and the two values
         * for the start and the end of the paramtric curve. array may be used as parent array of a
         * {@link JXG.Curve}.
         *
         * @example
         * var A = brd.create('point',[-2,-2]);
         * var B = brd.create('point',[0,1]);
         * var pol = brd.create('regularpolygon',[A,B,3], {withLines:false, fillColor:'none', highlightFillColor:'none', fillOpacity:0.0});
         * var reuleauxTriangle = brd.create('curve', JXG.Math.Geometry.reuleauxPolygon(pol.vertices, 3),
         *                          {strokeWidth:6, strokeColor:'#d66d55', fillColor:'#ad5544', highlightFillColor:'#ad5544'});
         *
         * </pre><div class="jxgbox" id="JXG2543a843-46a9-4372-abc1-94d9ad2db7ac" style="width: 300px; height: 300px;"></div>
         * <script type="text/javascript">
         * var brd = JXG.JSXGraph.initBoard('JXG2543a843-46a9-4372-abc1-94d9ad2db7ac', {boundingbox: [-5, 5, 5, -5], axis: true, showcopyright:false, shownavigation: false});
         * var A = brd.create('point',[-2,-2]);
         * var B = brd.create('point',[0,1]);
         * var pol = brd.create('regularpolygon',[A,B,3], {withLines:false, fillColor:'none', highlightFillColor:'none', fillOpacity:0.0});
         * var reuleauxTriangle = brd.create('curve', JXG.Math.Geometry.reuleauxPolygon(pol.vertices, 3),
         *                          {strokeWidth:6, strokeColor:'#d66d55', fillColor:'#ad5544', highlightFillColor:'#ad5544'});
         * </script><pre>
         */ reuleauxPolygon: function(points, nr) {
        var beta, pi2 = Math.PI * 2, pi2_n = pi2 / nr, diag = (nr - 1) / 2, d = 0, makeFct = function(which, trig) {
            return function(t, suspendUpdate) {
                var t1 = (t % pi2 + pi2) % pi2, j = Math.floor(t1 / pi2_n) % nr;
                if (!suspendUpdate) {
                    d = points[0].Dist(points[diag]);
                    beta = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Geometry.rad([
                        points[0].X() + 1,
                        points[0].Y()
                    ], points[0], points[diag % nr]);
                }
                if (isNaN(j)) {
                    return j;
                }
                t1 = t1 * 0.5 + j * pi2_n * 0.5 + beta;
                return points[j][which]() + d * Math[trig](t1);
            };
        };
        return [
            makeFct("X", "cos"),
            makeFct("Y", "sin"),
            0,
            pi2
        ];
    }
});
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Geometry;
}),
"[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/qdt.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */ /*global JXG:true, define: true*/ /*jslint nomen: true, plusplus: true*/ __turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/math.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/geometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/utils/type.js [app-client] (ecmascript)");
;
;
;
/**
 * Instantiate a new quadtree.
 *
 * @name JXG.Math.Quadtree
 * @exports Mat.Quadtree as JXG.Math.Quadtree
 * @param {Array} bbox Bounding box of the new quad (sub)tree.
 * @param {Object} config Configuration object. Default value: to {capacity: 10}
 * @param {Object} [parent] Parent object or null if root.
 *
 * @constructor
 */ __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Quadtree = function(bbox, config, parent) {
    config = config || {
        capacity: 10,
        pointType: 'coords'
    };
    /**
     * Configuration object for quadtree.
     *
     * @name JXG.Math.Quadtree.config
     * @type Object
     */ this.config = {};
    /**
     * The maximum number of points stored in a quadtree node
     * before it is subdivided.
     * @name JXG.Math.Quadtree.config#capacity
     * @type Number
     * @default 10
     */ this.config.capacity = config.capacity || 10;
    /**
     * Type of a point object. Possible values are:
     * 'coords', 'object'.
     * @name JXG.Math.Quadtree.config#pointType
     * @type String
     * @default 'coords'
     */ this.config.pointType = config.pointType || 'coords';
    /**
     * Point storage.
     * @name JXG.Math.Quadtree#points
     * @type Array
     */ this.points = [];
    this.xlb = bbox[0];
    this.xub = bbox[2];
    this.ylb = bbox[3];
    this.yub = bbox[1];
    /**
     * Parent quadtree or null if there is not parent.
     *
     * @name JXG.Math.Quadtree#parent
     * @type JXG.Math.Quadtree
     *
     */ this.parent = parent || null;
    /**
     * In a subdivided quadtree this represents the top left subtree.
     * @name JXG.Math.Quadtree#northWest
     * @type JXG.Math.Quadtree
     */ this.northWest = null;
    /**
     * In a subdivided quadtree this represents the top right subtree.
     * @name JXG.Math.Quadtree#northEast
     * @type JXG.Math.Quadtree
     */ this.northEast = null;
    /**
     * In a subdivided quadtree this represents the bottom right subtree.
     * @name JXG.Math.Quadtree#southEast
     * @type JXG.Math.Quadtree
     */ this.southEast = null;
    /**
     * In a subdivided quadtree this represents the bottom left subtree.
     * @name JXG.Math.Quadtree#southWest
     * @type JXG.Math.Quadtree
     */ this.southWest = null;
};
__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].extend(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Quadtree.prototype, /** @lends JXG.Math.Quadtree.prototype */ {
    /**
         * Checks if the given coordinates are inside of the boundaries of the quadtree.
         * The quadtree is open to the left and botton and closed to
         * right and top.
         *
         * @param {Number} x
         * @param {Number} y
         * @returns {Boolean}
         */ contains: function(x, y) {
        return this.xlb < x && x <= this.xub && this.ylb < y && y <= this.yub;
    },
    /**
         * Insert a new point into this quadtree if it is inside of
         * the quadtree's boundaries.
         *
         * @param {JXG.Coords} p
         * @returns {Boolean} true if insert succeeded, false otherwise.
         */ insert: function(p) {
        switch(this.config.pointType){
            case 'coords':
                if (!this.contains(p.usrCoords[1], p.usrCoords[2])) {
                    return false;
                }
                break;
            case 'object':
                if (!this.contains(p.x, p.y)) {
                    return false;
                }
                break;
        }
        if (this.points.length < this.config.capacity && this.northWest === null) {
            this.points.push(p);
            return true;
        }
        // At this point the point has to be inserted into a subtree.
        if (this.northWest === null) {
            this.subdivide();
        }
        if (this.northWest.insert(p)) {
            return true;
        }
        if (this.northEast.insert(p)) {
            return true;
        }
        if (this.southEast.insert(p)) {
            return true;
        }
        return !!this.southWest.insert(p);
    },
    /**
         * Subdivide the quadtree.
         */ subdivide: function() {
        var cx = this.xlb + (this.xub - this.xlb) * 0.5, cy = this.ylb + (this.yub - this.ylb) * 0.5;
        this.northWest = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Quadtree([
            this.xlb,
            this.yub,
            cx,
            cy
        ], this.config, this);
        this.northEast = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Quadtree([
            cx,
            this.yub,
            this.xub,
            cy
        ], this.config, this);
        this.southEast = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Quadtree([
            this.xlb,
            cy,
            cx,
            this.ylb
        ], this.config, this);
        this.southWest = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Quadtree([
            cx,
            cy,
            this.xub,
            this.ylb
        ], this.config, this);
    // for (i = 0; i < le; i++) {
    //     if (this.northWest.insert(this.points[i])) { continue; }
    //     if (this.northEast.insert(this.points[i])) { continue; }
    //     if (this.southEast.insert(this.points[i])) { continue; }
    //     this.southWest.insert(this.points[i]);
    // }
    },
    /**
         * Internal _query method that lacks adjustment of the parameter.
         * @name JXG.Math.Quadtree#_query
         * @param {Number} x
         * @param {Number} y
         * @returns {Boolean|JXG.Quadtree} The quadtree if the point is found, false
         * if none of the quadtrees contains the point (i.e. the point is not inside
         * the root tree's AABB,i.e. axis-aligned bounding box).
         * @private
         */ _query: function(x, y) {
        var r;
        if (this.contains(x, y)) {
            if (this.northWest === null) {
                return this;
            }
            r = this.northWest._query(x, y);
            if (r) {
                return r;
            }
            r = this.northEast._query(x, y);
            if (r) {
                return r;
            }
            r = this.southEast._query(x, y);
            if (r) {
                return r;
            }
            r = this.southWest._query(x, y);
            if (r) {
                return r;
            }
        }
        return false;
    },
    /**
         * Retrieve the smallest quad tree that contains the given coordinate pair.
         * @name JXG.Math.Quadtree#query
         * @param {JXG.Coords|Number} xp
         * @param {Number} y
         * @returns {Boolean|JXG.Quadtree} The quadtree if the point is found, false
         * if none of the quadtrees contains the point (i.e. the point is not inside
         * the root tree's AABB (Axis-Aligned Bounding Box)).
         */ query: function(xp, y) {
        var _x, _y;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(y)) {
            _x = xp;
            _y = y;
        } else {
            _x = xp.usrCoords[1];
            _y = xp.usrCoords[2];
        }
        return this._query(_x, _y);
    },
    /**
         * Check if the quadtree has a point which is inside of a sphere of
         * radius tol around [x, y].
         * @param {Number} x
         * @param {Number} y
         * @param {Number} tol
         * @returns {Boolean}
         */ hasPoint: function(x, y, tol) {
        var r, i, le;
        if (this.contains(x, y)) {
            le = this.points.length;
            switch(this.config.pointType){
                case 'coords':
                    for(i = 0; i < le; i++){
                        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].distance([
                            x,
                            y
                        ], this.points[i].usrCoords.slice(1), 2) < tol) {
                            return true;
                        }
                    }
                    break;
                case 'object':
                    for(i = 0; i < le; i++){
                        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].distance([
                            x,
                            y
                        ], [
                            this.points[i].x,
                            this.points[i].y
                        ], 2) < tol) {
                            return true;
                        }
                    }
                    break;
            }
            if (this.northWest === null) {
                return false;
            }
            r = this.northWest.hasPoint(x, y, tol);
            if (r) {
                return r;
            }
            r = this.northEast.hasPoint(x, y, tol);
            if (r) {
                return r;
            }
            r = this.southEast.hasPoint(x, y, tol);
            if (r) {
                return r;
            }
            r = this.southWest.hasPoint(x, y, tol);
            if (r) {
                return r;
            }
        }
        return false;
    },
    /**
         *
         * @returns {Array}
         */ getAllPoints: function() {
        var pointsList = [];
        this.getAllPointsRecursive(pointsList);
        return pointsList;
    },
    /**
         *
         * @param {Array} pointsList
         * @private
         */ getAllPointsRecursive (pointsList) {
        Array.prototype.push.apply(pointsList, this.points.slice());
        if (this.northWest === null) {
            return;
        }
        this.northWest.getAllPointsRecursive(pointsList);
        this.northEast.getAllPointsRecursive(pointsList);
        this.southEast.getAllPointsRecursive(pointsList);
        this.southWest.getAllPointsRecursive(pointsList);
    }
});
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Quadtree;
}),
"[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/bqdt.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */ /*global JXG:true, define: true*/ /*jslint nomen: true, plusplus: true*/ __turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/math.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/utils/type.js [app-client] (ecmascript)");
;
;
/**
 * Instantiate a new box quadtree.
 * A box quadtree stores AABBs, i.e. axis-aligned bounding boxes.
 * The box quadtree has four sub-quadtress which maybe null if not needed.
 *
 * @name JXG.Math.BoxQuadtree
 * @exports Mat.BoxQuadtree as JXG.Math.BoxQuadtree
 *
 * @param {Number} depth Maximum recursion depth.
 * @param {Number} capacity Maximum number of items stored in this node.
 * @param {Array} [bbox] Optional bounding box of the box quadtree. If not given, the bounding box is
 * determined by the items in the insert method. This will only work correctly if the first
 * call of insert contains the maximum bounding box.
 *
 * @constructor
 */ __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].BoxQuadtree = function(depth, capacity, bbox) {
    var l, t, r, b;
    // console.log("---------------------------------------")
    depth--;
    /**
     * Maximum depth of the box quadtree node
     * @name JXG.Math.BoxQuadtree#depth
     * @type Number
     * @private
     */ this.depth = depth;
    /**
     * Capacity of the box quadtree node
     * @name JXG.Math.BoxQuadtree#capacity
     * @type Number
     * @private
     */ this.capacity = capacity;
    /**
     * Item storage.
     *
     * @name JXG.Math.BoxQuadtree#items
     * @type Array
     * @private
     */ this.items = [];
    /**
     * In a subdivided quadtree this represents the top left subtree.
     * @name JXG.Math.BoxQuadtree#northWest
     * @type JXG.Math.BoxQuadtree
     * @private
     */ this.northWest = null;
    /**
     * In a subdivided quadtree this represents the top right subtree.
     * @name JXG.Math.BoxQuadtree#northEast
     * @type JXG.Math.BoxQuadtree
     * @private
     */ this.northEast = null;
    /**
     * In a subdivided quadtree this represents the bottom right subtree.
     * @name JXG.Math.BoxQuadtree#southEast
     * @type JXG.Math.BoxQuadtree
     * @private
     */ this.southEast = null;
    /**
     * In a subdivided quadtree this represents the bottom left subtree.
     * @name JXG.Math.BoxQuadtree#southWest
     * @type JXG.Math.BoxQuadtree
     * @private
     */ this.southWest = null;
    /**
     * Bounding box [left, top, right, bottom].
     *
     * @name JXG.Math.BoxQuadtree#bbox
     * @type Array
     * @private
     */ this.bbox = null;
    /**
     * x-coordinate of bounding box center.
     *
     * @name JXG.Math.BoxQuadtree#cx
     * @type Number
     * @private
     */ this.cx = null;
    /**
     * y-coordinate of bounding box center.
     *
     * @name JXG.Math.BoxQuadtree#cy
     * @type Number
     * @private
     */ this.cy = null;
    if (bbox) {
        // Take supplied bounding box
        l = bbox[0];
        t = bbox[1];
        r = bbox[2];
        b = bbox[3];
        this.cx = (l + r) * 0.5;
        this.cy = (t + b) * 0.5;
        this.bbox = [
            l,
            t,
            r,
            b
        ];
    }
};
__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].extend(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].BoxQuadtree.prototype, /** @lends JXG.Math.BoxQuadtree.prototype */ {
    /**
         * Insert an array of items into the box quadtree. An item is an object
         * containing at least the properties
         * <ul>
         *  <li> xlb: lower bound on x
         *  <li> xub: upper bound on x
         *  <li> ylb: lower bound on y
         *  <li> yub: upper bound on y
         * </ul>
         * which define the axis-aligned bounding box (AABB) of that item. Additionally,
         * more properties can be given.
         *
         * @param {Array} items to be inserted
         * @returns {Object} reference to the box quadtree
         */ insert: function(items) {
        var i, le, l, t, r, b, it, nw_it = [], ne_it = [], sw_it = [], se_it = [], in_nw, in_ne, in_sw, in_se;
        if (this.bbox === null) {
            // Use bounding box of the supplied items
            le = items.length;
            l = b = Infinity;
            r = t = -Infinity;
            for(i = 0; i < items.length; i++){
                it = items[i];
                l = it.xlb < l ? it.xlb : l;
                t = it.yub > t ? it.yub : t;
                r = it.xub > r ? it.xub : r;
                b = it.ylb < b ? it.ylb : b;
            }
            this.cx = (l + r) * 0.5;
            this.cy = (t + b) * 0.5;
            this.bbox = [
                l,
                t,
                r,
                b
            ];
        } else {
            l = this.bbox[0];
            t = this.bbox[1];
            r = this.bbox[2];
            b = this.bbox[3];
        }
        if (this.depth === 0 || this.items.length + items.length < this.capacity) {
            // if (items.length + items.length < this.capacity) {
            //     console.log("Capacity sufficient, D=", this.depth, this.items.length, items.length);
            // }
            // if (depth === 0) {console.log("Max depth reached", items.length, this.capacity); }
            this.items = this.items.concat(items);
            return this;
        }
        le = items.length;
        for(i = 0; i < le; i++){
            it = items[i];
            in_nw = it.xlb <= this.cx && it.yub > this.cy;
            in_sw = it.xlb <= this.cx && it.ylb <= this.cy;
            in_ne = it.xub > this.cx && it.yub > this.cy;
            in_se = it.xub > this.cx && it.ylb <= this.cy;
            // If it overlaps all 4 quadrants then insert it at the current
            // depth, otherwise append it to a list to be inserted under every
            // quadrant that it overlaps.
            if (in_nw && in_ne && in_se && in_sw) {
                this.items.push(it);
            } else {
                if (in_nw) {
                    nw_it.push(it);
                }
                if (in_sw) {
                    sw_it.push(it);
                }
                if (in_ne) {
                    ne_it.push(it);
                }
                if (in_se) {
                    se_it.push(it);
                }
            }
        }
        // Create the sub-quadrants, recursively.
        this.subdivide(nw_it, sw_it, ne_it, se_it, l, t, r, b);
        return this;
    },
    /**
         * Insert an item into the box quadtree, where an item is an object
         * containing at least the properties
         *
         * <ul>
         *  <li> xlb: lower bound on x
         *  <li> xub: upper bound on x
         *  <li> ylb: lower bound on y
         *  <li> yub: upper bound on y
         * </ul>
         * which define the axis-aligned bounding box (AABB) of that item. Additionally,
         * more properties can be given.
         *
         * @param {Object} it Item to be inserted
         * @returns {Object} reference to the box quadtree
         */ insertItem: function(it) {
        var l, t, r, b, nw_it = [], ne_it = [], sw_it = [], se_it = [], in_nw, in_ne, in_sw, in_se;
        if (this.bbox === null) {
            // Use bounding box of the supplied items
            l = b = Infinity;
            r = t = -Infinity;
            l = it.xlb < l ? it.xlb : l;
            t = it.yub > t ? it.yub : t;
            r = it.xub > r ? it.xub : r;
            b = it.ylb < b ? it.ylb : b;
            this.cx = (l + r) * 0.5;
            this.cy = (t + b) * 0.5;
            this.bbox = [
                l,
                t,
                r,
                b
            ];
        } else {
            l = this.bbox[0];
            t = this.bbox[1];
            r = this.bbox[2];
            b = this.bbox[3];
        }
        if (this.depth === 0 || this.items.length + 1 < this.capacity) {
            this.items.push(it);
            return this;
        }
        in_nw = it.xlb <= this.cx && it.yub > this.cy;
        in_sw = it.xlb <= this.cx && it.ylb <= this.cy;
        in_ne = it.xub > this.cx && it.yub > this.cy;
        in_se = it.xub > this.cx && it.ylb <= this.cy;
        // If it overlaps all 4 quadrants then insert it at the current
        // depth, otherwise append it to a list to be inserted under every
        // quadrant that it overlaps.
        if (in_nw && in_ne && in_se && in_sw) {
            this.items.push(it);
        } else {
            if (in_nw) {
                nw_it.push(it);
            }
            if (in_sw) {
                sw_it.push(it);
            }
            if (in_ne) {
                ne_it.push(it);
            }
            if (in_se) {
                se_it.push(it);
            }
        }
        // Create the sub-quadrants, recursively.
        this.subdivide(nw_it, sw_it, ne_it, se_it, l, t, r, b);
        return this;
    },
    /**
         * Create the sub-quadrants if necessary, recursively
         * @param {Array} nw_it list of items for northWest subtree
         * @param {Array} sw_it list of items for southWest subtree
         * @param {Array} ne_it list of items for northEast subtree
         * @param {Array} se_it list of items for southEast subtree
         * @param {Number} l bounding box left
         * @param {Number} t bounding box top
         * @param {Number} r bounding box right
         * @param {Number} b bounding box bottom
         * @returns {Object} reference to the box quadtree
         * @private
         */ subdivide: function(nw_it, sw_it, ne_it, se_it, l, t, r, b) {
        if (nw_it.length > 0) {
            if (this.northWest === null) {
                this.northWest = new JXG.Math.BoxQuadtree(this.depth, this.capacity, [
                    l,
                    t,
                    this.cx,
                    this.cy
                ]);
            }
            this.northWest.insert(nw_it);
        }
        if (sw_it.length > 0) {
            if (this.southWest === null) {
                this.southWest = new JXG.Math.BoxQuadtree(this.depth, this.capacity, [
                    l,
                    this.cy,
                    this.cx,
                    b
                ]);
            }
            this.southWest.insert(sw_it);
        }
        if (ne_it.length > 0) {
            if (this.northEast === null) {
                this.northEast = new JXG.Math.BoxQuadtree(this.depth, this.capacity, [
                    this.cx,
                    t,
                    r,
                    this.cy
                ]);
            }
            this.northEast.insert(ne_it);
        }
        if (se_it.length > 0) {
            if (this.southEast === null) {
                this.southEast = new JXG.Math.BoxQuadtree(this.depth, this.capacity, [
                    this.cx,
                    this.cy,
                    r,
                    b
                ]);
            }
            this.southEast.insert(se_it);
        }
        return this;
    },
    /**
         * Find all entries of the box quadtree which have an overlap
         * with the given rectangle (AABB). Items may appear multiple times.
         *
         * @param {Array} box AABB of the form [l, t, r, b]
         * @returns {Array} list of items overlapping with box
         */ find: function(box) {
        var overlaps = function(item) {
            return box[2] >= item.xlb && box[0] <= item.xub && box[3] <= item.yub && box[1] >= item.ylb;
        }, hits = [], i, le;
        le = this.items.length;
        for(i = 0; i < le; i++){
            if (overlaps(this.items[i])) {
                hits.push(this.items[i]);
            }
        }
        if (this.northWest !== null && box[0] <= this.cx & box[1] >= this.cy) {
            __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].concat(hits, this.northWest.find(box));
        }
        if (this.southWest !== null && box[0] <= this.cx & box[3] <= this.cy) {
            __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].concat(hits, this.southWest.find(box));
        }
        if (this.northEast !== null && box[2] >= this.cx & box[1] >= this.cy) {
            __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].concat(hits, this.northEast.find(box));
        }
        if (this.southEast !== null && box[2] >= this.cx & box[3] <= this.cy) {
            __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].concat(hits, this.southEast.find(box));
        }
        return hits;
    },
    /**
         * Analyze the box quadtree.
         *
         * @returns {Object} data about the box quadtree
         */ analyzeTree: function() {
        var stats = {
            number_items: this.items.length,
            depth: 1
        }, tmp;
        if (this.northWest !== null) {
            tmp = this.northWest.analyzeTree();
            stats.number_items += tmp.number_items;
            stats.depth = Math.max(stats.depth, 1 + tmp.depth);
        }
        if (this.southWest !== null) {
            tmp = this.southWest.analyzeTree();
            stats.number_items += tmp.number_items;
            stats.depth = Math.max(stats.depth, 1 + tmp.depth);
        }
        if (this.northEast !== null) {
            tmp = this.northEast.analyzeTree();
            stats.number_items += tmp.number_items;
            stats.depth = Math.max(stats.depth, 1 + tmp.depth);
        }
        if (this.southEast !== null) {
            tmp = this.southEast.analyzeTree();
            stats.number_items += tmp.number_items;
            stats.depth = Math.max(stats.depth, 1 + tmp.depth);
        }
        return stats;
    },
    /**
         * Generate data to plot the box quadtree as curve using updateDataArray.
         *
         * @returns {Array} containing arrays dataX and dataY
         *
         * @example
         *
         * // qdt contains a BoxQuadtree
         *
         * var qdtcurve = board.create('curve', [[], []], { strokeWidth: 1, strokeColor: '#0000ff', strokeOpacity: 0.3 });
         * qdtcurve.updateDataArray = function () {
         *    var ret = qdt.plot();
         *
         *    this.dataX = ret[0];
         *    this.dataY = ret[1];
         *    console.log(qdt.analyzeTree());
         * };
         * board.update();
         */ plot: function() {
        var dataX = [], dataY = [], ret;
        dataX.push(this.bbox[0]);
        dataY.push(this.bbox[3]);
        dataX.push(this.bbox[2]);
        dataY.push(this.bbox[3]);
        dataX.push(this.bbox[2]);
        dataY.push(this.bbox[1]);
        dataX.push(this.bbox[0]);
        dataY.push(this.bbox[1]);
        dataX.push(this.bbox[0]);
        dataY.push(this.bbox[3]);
        dataX.push(NaN);
        dataY.push(NaN);
        if (this.northWest !== null) {
            ret = this.northWest.plot();
            __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].concat(dataX, ret[0]);
            __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].concat(dataY, ret[1]);
        }
        if (this.northEast !== null) {
            ret = this.northEast.plot();
            __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].concat(dataX, ret[0]);
            __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].concat(dataY, ret[1]);
        }
        if (this.southEast !== null) {
            ret = this.southEast.plot();
            __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].concat(dataX, ret[0]);
            __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].concat(dataY, ret[1]);
        }
        if (this.southWest !== null) {
            ret = this.southWest.plot();
            __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].concat(dataX, ret[0]);
            __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].concat(dataY, ret[1]);
        }
        return [
            dataX,
            dataY
        ];
    }
});
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].BoxQuadtree;
}),
"[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/nlp.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*
 Copyright 2008-2025
 Matthias Ehmann,
 Carsten Miller,
 Reinhard Oldenburg,
 Andreas Walter,
 Alfred Wassermann

 This file is part of JSXGraph.

 JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

 You can redistribute it and/or modify it under the terms of the

 * GNU Lesser General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version
 OR
 * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

 JSXGraph is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public License and
 the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
 and <https://opensource.org/licenses/MIT/>.

 This is a port of jcobyla

 - to JavaScript by Reihard Oldenburg and
 - to JSXGraph by Alfred Wassermann
 - optimized by Andreas Walter
 */ /*
 * jcobyla
 *
 * The MIT License
 *
 * Copyright (c) 2012 Anders Gustafsson, Cureos AB.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
 * FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Remarks:
 *
 * The original Fortran 77 version of this code was by Michael Powell (M.J.D.Powell @ damtp.cam.ac.uk)
 * The Fortran 90 version was by Alan Miller (Alan.Miller @ vic.cmis.csiro.au). Latest revision - 30 October 1998
 */ /**
 * Constrained Optimization BY Linear Approximation in Java.
 *
 * COBYLA2 is an implementation of Powell's nonlinear derivative free constrained optimization that uses
 * a linear approximation approach. The algorithm is a sequential trust region algorithm that employs linear
 * approximations to the objective and constraint functions, where the approximations are formed by linear
 * interpolation at n + 1 points in the space of the variables and tries to maintain a regular shaped simplex
 * over iterations.
 *
 * It solves nonsmooth NLP with a moderate number of variables (about 100). Inequality constraints only.
 *
 * The initial point X is taken as one vertex of the initial simplex with zero being another, so, X should
 * not be entered as the zero vector.
 *
 * @author Anders Gustafsson, Cureos AB. Translation to Javascript by Reinhard Oldenburg, Goethe-University
 */ /*global JXG: true, define: true*/ /*jslint nomen: true, plusplus: true, continue: true*/ __turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/jxg.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/math.js [app-client] (ecmascript)");
;
;
// import Type from "../utils/type.js";
/**
 * The JXG.Math.Nlp namespace holds numerical algorithms for non-linear optimization.
 * @name JXG.Math.Nlp
 * @namespace
 *
 */ __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Math.Nlp = {
    arr: function(n) {
        // Is 0 initialized
        return new Float64Array(n);
    },
    arr2: function(n, m) {
        var i = 0, a = new Array(n);
        while(i < n){
            a[i] = this.arr(m);
            i++;
        }
        return a;
    },
    arraycopy: function(x, a, iox, b, n) {
        var i = 0;
        while(i < n){
            iox[i + b] = x[i + a];
            i++;
        }
    },
    lastNumberOfEvaluations: 0,
    GetLastNumberOfEvaluations: function() {
        return this.lastNumberOfEvaluations;
    },
    // status Variables
    Normal: 0,
    MaxIterationsReached: 1,
    DivergingRoundingErrors: 2,
    /**
     * Minimizes the objective function F with respect to a set of inequality constraints CON,
     * and returns the optimal variable array. F and CON may be non-linear, and should preferably be smooth.
     * Calls {@link JXG.Math.Nlp#cobylb}.
     *
     * @param calcfc Interface implementation for calculating objective function and constraints.
     * @param n Number of variables.
     * @param m Number of constraints.
     * @param x On input initial values of the variables (zero-based array). On output
     * optimal values of the variables obtained in the COBYLA minimization.
     * @param rhobeg Initial size of the simplex.
     * @param rhoend Final value of the simplex.
     * @param iprint Print level, 0 <= iprint <= 3, where 0 provides no output and
     * 3 provides full output to the console.
     * @param maxfun Maximum number of function evaluations before terminating.
     * @param [testForRoundingErrors=false]
     * @returns {Number} Exit status of the COBYLA2 optimization.
     */ FindMinimum: function(calcfc, n, m, x, rhobeg, rhoend, iprint, maxfun, testForRoundingErrors) {
        // CobylaExitStatus FindMinimum(final Calcfc calcfc, int n, int m, double[] x, double rhobeg, double rhoend, int iprint, int maxfun)
        //     This subroutine minimizes an objective function F(X) subject to M
        //     inequality constraints on X, where X is a vector of variables that has
        //     N components.  The algorithm employs linear approximations to the
        //     objective and constraint functions, the approximations being formed by
        //     linear interpolation at N+1 points in the space of the variables.
        //     We regard these interpolation points as vertices of a simplex.  The
        //     parameter RHO controls the size of the simplex and it is reduced
        //     automatically from RHOBEG to RHOEND.  For each RHO the subroutine tries
        //     to achieve a good vector of variables for the current size, and then
        //     RHO is reduced until the value RHOEND is reached.  Therefore RHOBEG and
        //     RHOEND should be set to reasonable initial changes to and the required
        //     accuracy in the variables respectively, but this accuracy should be
        //     viewed as a subject for experimentation because it is not guaranteed.
        //     The subroutine has an advantage over many of its competitors, however,
        //     which is that it treats each constraint individually when calculating
        //     a change to the variables, instead of lumping the constraints together
        //     into a single penalty function.  The name of the subroutine is derived
        //     from the phrase Constrained Optimization BY Linear Approximations.
        //     The user must set the values of N, M, RHOBEG and RHOEND, and must
        //     provide an initial vector of variables in X.  Further, the value of
        //     IPRINT should be set to 0, 1, 2 or 3, which controls the amount of
        //     printing during the calculation. Specifically, there is no output if
        //     IPRINT=0 and there is output only at the end of the calculation if
        //     IPRINT=1.  Otherwise each new value of RHO and SIGMA is printed.
        //     Further, the vector of variables and some function information are
        //     given either when RHO is reduced or when each new value of F(X) is
        //     computed in the cases IPRINT=2 or IPRINT=3 respectively. Here SIGMA
        //     is a penalty parameter, it being assumed that a change to X is an
        //     improvement if it reduces the merit function
        //                F(X)+SIGMA*MAX(0.0, - C1(X), - C2(X),..., - CM(X)),
        //     where C1,C2,...,CM denote the constraint functions that should become
        //     nonnegative eventually, at least to the precision of RHOEND. In the
        //     printed output the displayed term that is multiplied by SIGMA is
        //     called MAXCV, which stands for 'MAXimum Constraint Violation'.  The
        //     argument ITERS is an integer variable that must be set by the user to a
        //     limit on the number of calls of CALCFC, the purpose of this routine being
        //     given below.  The value of ITERS will be altered to the number of calls
        //     of CALCFC that are made.
        //     In order to define the objective and constraint functions, we require
        //     a subroutine that has the name and arguments
        //                SUBROUTINE CALCFC (N,M,X,F,CON)
        //                DIMENSION X(:),CON(:)  .
        //     The values of N and M are fixed and have been defined already, while
        //     X is now the current vector of variables. The subroutine should return
        //     the objective and constraint functions at X in F and CON(1),CON(2),
        //     ...,CON(M).  Note that we are trying to adjust X so that F(X) is as
        //     small as possible subject to the constraint functions being nonnegative.
        // Local variables
        var mpp = m + 2, status, // Internal base-1 X array
        iox = this.arr(n + 1), that = this, fcalcfc;
        this.lastNumberOfEvaluations = 0;
        if (testForRoundingErrors) {
            console.log("Experimental feature 'testForRoundingErrors' is activated.");
        }
        iox[0] = 0.0;
        this.arraycopy(x, 0, iox, 1, n);
        // Internal representation of the objective and constraints calculation method,
        // accounting for that X and CON arrays in the cobylb method are base-1 arrays.
        fcalcfc = function(n, m, thisx, con) {
            // int n, int m, double[] x, double[] con
            var ix = that.arr(n), ocon, f;
            that.lastNumberOfEvaluations = that.lastNumberOfEvaluations + 1;
            that.arraycopy(thisx, 1, ix, 0, n);
            ocon = that.arr(m);
            f = calcfc(n, m, ix, ocon);
            that.arraycopy(ocon, 0, con, 1, m);
            return f;
        };
        status = this.cobylb(fcalcfc, n, m, mpp, iox, rhobeg, rhoend, iprint, maxfun, testForRoundingErrors);
        this.arraycopy(iox, 1, x, 0, n);
        return status;
    },
    //    private static CobylaExitStatus cobylb(Calcfc calcfc, int n, int m, int mpp, double[] x,
    //      double rhobeg, double rhoend, int iprint, int maxfun)
    /**
     * JavaScript implementation of the non-linear optimization method COBYLA.
     * @param {Function} calcfc
     * @param {Number} n
     * @param {Number} m
     * @param {Number} mpp
     * @param {Number} x
     * @param {Number} rhobeg
     * @param {Number} rhoend
     * @param {Number} iprint
     * @param {Number} maxfun
     * @param {Boolean} [testForRoundingErrors=false]
     * @returns {Number} Exit status of the COBYLA2 optimization
     */ cobylb: function(calcfc, n, m, mpp, x, rhobeg, rhoend, iprint, maxfun, testForRoundingErrors) {
        // calcf ist funktion die aufgerufen wird wie calcfc(n, m, ix, ocon)
        // N.B. Arguments CON, SIM, SIMI, DATMAT, A, VSIG, VETA, SIGBAR, DX, W & IACT
        //      have been removed.
        //     Set the initial values of some parameters. The last column of SIM holds
        //     the optimal vertex of the current simplex, and the preceding N columns
        //     hold the displacements from the optimal vertex to the other vertices.
        //     Further, SIMI holds the inverse of the matrix that is contained in the
        //     first N columns of SIM.
        // Local variables
        var status = -1, alpha = 0.25, beta = 2.1, gamma = 0.5, delta = 1.1, f = 0.0, resmax = 0.0, total, np = n + 1, mp = m + 1, rho = rhobeg, parmu = 0.0, iflag = false, ifull = false, parsig = 0.0, prerec = 0.0, prerem = 0.0, con = this.arr(1 + mpp), sim = this.arr2(1 + n, 1 + np), simi = this.arr2(1 + n, 1 + n), datmat = this.arr2(1 + mpp, 1 + np), a = this.arr2(1 + n, 1 + mp), vsig = this.arr(1 + n), veta = this.arr(1 + n), sigbar = this.arr(1 + n), dx = this.arr(1 + n), w = this.arr(1 + n), i, j, k, l, temp, tempa, nfvals, jdrop, ibrnch, skipVertexIdent, phimin, nbest, error, pareta, wsig, weta, cvmaxp, cvmaxm, dxsign, resnew, barmu, phi, vmold, vmnew, trured, ratio, edgmax, cmin, cmax, denom, endless = true;
        if (iprint >= 2) {
            console.log("The initial value of RHO is " + rho + " and PARMU is set to zero.");
        }
        nfvals = 0;
        temp = 1.0 / rho;
        for(i = 1; i <= n; ++i){
            sim[i][np] = x[i];
            sim[i][i] = rho;
            simi[i][i] = temp;
        }
        jdrop = np;
        ibrnch = false;
        //     Make the next call of the user-supplied subroutine CALCFC. These
        //     instructions are also used for calling CALCFC during the iterations of
        //     the algorithm.
        //alert("Iteration "+nfvals+" x="+x);
        L_40: do {
            if (nfvals >= maxfun && nfvals > 0) {
                status = this.MaxIterationsReached;
                break L_40;
            }
            ++nfvals;
            f = calcfc(n, m, x, con);
            resmax = 0.0;
            for(k = 1; k <= m; ++k){
                resmax = Math.max(resmax, -con[k]);
            }
            //alert(    "   f="+f+"  resmax="+resmax);
            if (nfvals === iprint - 1 || iprint === 3) {
                this.PrintIterationResult(nfvals, f, resmax, x, n, iprint);
            }
            con[mp] = f;
            con[mpp] = resmax;
            //     Set the recently calculated function values in a column of DATMAT. This
            //     array has a column for each vertex of the current simplex, the entries of
            //     each column being the values of the constraint functions (if any)
            //     followed by the objective function and the greatest constraint violation
            //     at the vertex.
            skipVertexIdent = true;
            if (!ibrnch) {
                skipVertexIdent = false;
                for(i = 1; i <= mpp; ++i){
                    datmat[i][jdrop] = con[i];
                }
                if (nfvals <= np) {
                    //     Exchange the new vertex of the initial simplex with the optimal vertex if
                    //     necessary. Then, if the initial simplex is not complete, pick its next
                    //     vertex and calculate the function values there.
                    if (jdrop <= n) {
                        if (datmat[mp][np] <= f) {
                            x[jdrop] = sim[jdrop][np];
                        } else {
                            sim[jdrop][np] = x[jdrop];
                            for(k = 1; k <= mpp; ++k){
                                datmat[k][jdrop] = datmat[k][np];
                                datmat[k][np] = con[k];
                            }
                            for(k = 1; k <= jdrop; ++k){
                                sim[jdrop][k] = -rho;
                                temp = 0.0;
                                for(i = k; i <= jdrop; ++i){
                                    temp -= simi[i][k];
                                }
                                simi[jdrop][k] = temp;
                            }
                        }
                    }
                    if (nfvals <= n) {
                        jdrop = nfvals;
                        x[jdrop] += rho;
                        continue L_40;
                    }
                }
                ibrnch = true;
            }
            L_140: do {
                L_550: do {
                    if (!skipVertexIdent) {
                        //     Identify the optimal vertex of the current simplex.
                        phimin = datmat[mp][np] + parmu * datmat[mpp][np];
                        nbest = np;
                        for(j = 1; j <= n; ++j){
                            temp = datmat[mp][j] + parmu * datmat[mpp][j];
                            if (temp < phimin) {
                                nbest = j;
                                phimin = temp;
                            } else if (temp === phimin && parmu === 0.0 && datmat[mpp][j] < datmat[mpp][nbest]) {
                                nbest = j;
                            }
                        }
                        //     Switch the best vertex into pole position if it is not there already,
                        //     and also update SIM, SIMI and DATMAT.
                        if (nbest <= n) {
                            for(i = 1; i <= mpp; ++i){
                                temp = datmat[i][np];
                                datmat[i][np] = datmat[i][nbest];
                                datmat[i][nbest] = temp;
                            }
                            for(i = 1; i <= n; ++i){
                                temp = sim[i][nbest];
                                sim[i][nbest] = 0.0;
                                sim[i][np] += temp;
                                tempa = 0.0;
                                for(k = 1; k <= n; ++k){
                                    sim[i][k] -= temp;
                                    tempa -= simi[k][i];
                                }
                                simi[nbest][i] = tempa;
                            }
                        }
                        //     Make an error return if SIGI is a poor approximation to the inverse of
                        //     the leading N by N submatrix of SIG.
                        error = 0.0;
                        if (testForRoundingErrors) {
                            for(i = 1; i <= n; ++i){
                                for(j = 1; j <= n; ++j){
                                    temp = this.DOT_PRODUCT_ROW_COL(simi, i, sim, j, 1, n) - (i === j ? 1.0 : 0.0);
                                    // temp = this.DOT_PRODUCT(
                                    //     this.PART(this.ROW(simi, i), 1, n),
                                    //     this.PART(this.COL(sim, j), 1, n)
                                    // ) - (i === j ? 1.0 : 0.0);
                                    error = Math.max(error, Math.abs(temp));
                                }
                            }
                        }
                        if (error > 0.1) {
                            status = this.DivergingRoundingErrors;
                            break L_40;
                        }
                        //     Calculate the coefficients of the linear approximations to the objective
                        //     and constraint functions, placing minus the objective function gradient
                        //     after the constraint gradients in the array A. The vector W is used for
                        //     working space.
                        for(k = 1; k <= mp; ++k){
                            con[k] = -datmat[k][np];
                            for(j = 1; j <= n; ++j){
                                w[j] = datmat[k][j] + con[k];
                            }
                            for(i = 1; i <= n; ++i){
                                a[i][k] = (k === mp ? -1.0 : 1.0) * this.DOT_PRODUCT_ROW_COL(w, -1, simi, i, 1, n);
                            // this.DOT_PRODUCT(this.PART(w, 1, n), this.PART(this.COL(simi, i), 1, n));
                            }
                        }
                        //     Calculate the values of sigma and eta, and set IFLAG = 0 if the current
                        //     simplex is not acceptable.
                        iflag = true;
                        parsig = alpha * rho;
                        pareta = beta * rho;
                        for(j = 1; j <= n; ++j){
                            wsig = 0.0;
                            weta = 0.0;
                            for(k = 1; k <= n; ++k){
                                wsig += simi[j][k] * simi[j][k];
                                weta += sim[k][j] * sim[k][j];
                            }
                            vsig[j] = 1.0 / Math.sqrt(wsig);
                            veta[j] = Math.sqrt(weta);
                            if (vsig[j] < parsig || veta[j] > pareta) {
                                iflag = false;
                            }
                        }
                        //     If a new vertex is needed to improve acceptability, then decide which
                        //     vertex to drop from the simplex.
                        if (!ibrnch && !iflag) {
                            jdrop = 0;
                            temp = pareta;
                            for(j = 1; j <= n; ++j){
                                if (veta[j] > temp) {
                                    jdrop = j;
                                    temp = veta[j];
                                }
                            }
                            if (jdrop === 0) {
                                for(j = 1; j <= n; ++j){
                                    if (vsig[j] < temp) {
                                        jdrop = j;
                                        temp = vsig[j];
                                    }
                                }
                            }
                            //     Calculate the step to the new vertex and its sign.
                            temp = gamma * rho * vsig[jdrop];
                            for(k = 1; k <= n; ++k){
                                dx[k] = temp * simi[jdrop][k];
                            }
                            cvmaxp = 0.0;
                            cvmaxm = 0.0;
                            total = 0.0;
                            for(k = 1; k <= mp; ++k){
                                // total = this.DOT_PRODUCT(this.PART(this.COL(a, k), 1, n), this.PART(dx, 1, n));
                                total = this.DOT_PRODUCT_ROW_COL(dx, -1, a, k, 1, n);
                                if (k < mp) {
                                    temp = datmat[k][np];
                                    cvmaxp = Math.max(cvmaxp, -total - temp);
                                    cvmaxm = Math.max(cvmaxm, total - temp);
                                }
                            }
                            dxsign = parmu * (cvmaxp - cvmaxm) > 2.0 * total ? -1.0 : 1.0;
                            //     Update the elements of SIM and SIMI, and set the next X.
                            temp = 0.0;
                            for(i = 1; i <= n; ++i){
                                dx[i] = dxsign * dx[i];
                                sim[i][jdrop] = dx[i];
                                temp += simi[jdrop][i] * dx[i];
                            }
                            for(k = 1; k <= n; ++k){
                                simi[jdrop][k] /= temp;
                            }
                            for(j = 1; j <= n; ++j){
                                if (j !== jdrop) {
                                    // temp = this.DOT_PRODUCT(this.PART(this.ROW(simi, j), 1, n), this.PART(dx, 1, n));
                                    temp = this.DOT_PRODUCT_ROW_COL(simi, j, dx, -1, 1, n);
                                    for(k = 1; k <= n; ++k){
                                        simi[j][k] -= temp * simi[jdrop][k];
                                    }
                                }
                                x[j] = sim[j][np] + dx[j];
                            }
                            continue L_40;
                        }
                        //     Calculate DX = x(*)-x(0).
                        //     Branch if the length of DX is less than 0.5*RHO.
                        ifull = this.trstlp(n, m, a, con, rho, dx);
                        if (!ifull) {
                            temp = 0.0;
                            for(k = 1; k <= n; ++k){
                                temp += dx[k] * dx[k];
                            }
                            if (temp < 0.25 * rho * rho) {
                                ibrnch = true;
                                break L_550;
                            }
                        }
                        //     Predict the change to F and the new maximum constraint violation if the
                        //     variables are altered from x(0) to x(0) + DX.
                        total = 0.0;
                        resnew = 0.0;
                        con[mp] = 0.0;
                        for(k = 1; k <= mp; ++k){
                            //total = con[k] - this.DOT_PRODUCT(this.PART(this.COL(a, k), 1, n), this.PART(dx, 1, n));
                            total = con[k] - this.DOT_PRODUCT_ROW_COL(dx, -1, a, k, 1, n);
                            if (k < mp) {
                                resnew = Math.max(resnew, total);
                            }
                        }
                        //     Increase PARMU if necessary and branch back if this change alters the
                        //     optimal vertex. Otherwise PREREM and PREREC will be set to the predicted
                        //     reductions in the merit function and the maximum constraint violation
                        //     respectively.
                        prerec = datmat[mpp][np] - resnew;
                        barmu = prerec > 0.0 ? total / prerec : 0.0;
                        if (parmu < 1.5 * barmu) {
                            parmu = 2.0 * barmu;
                            if (iprint >= 2) {
                                console.log("Increase in PARMU to " + parmu);
                            }
                            phi = datmat[mp][np] + parmu * datmat[mpp][np];
                            for(j = 1; j <= n; ++j){
                                temp = datmat[mp][j] + parmu * datmat[mpp][j];
                                if (temp < phi || temp === phi && parmu === 0.0 && datmat[mpp][j] < datmat[mpp][np]) {
                                    continue L_140;
                                }
                            }
                        }
                        prerem = parmu * prerec - total;
                        //     Calculate the constraint and objective functions at x(*).
                        //     Then find the actual reduction in the merit function.
                        for(k = 1; k <= n; ++k){
                            x[k] = sim[k][np] + dx[k];
                        }
                        ibrnch = true;
                        continue L_40;
                    }
                    skipVertexIdent = false;
                    vmold = datmat[mp][np] + parmu * datmat[mpp][np];
                    vmnew = f + parmu * resmax;
                    trured = vmold - vmnew;
                    if (parmu === 0.0 && f === datmat[mp][np]) {
                        prerem = prerec;
                        trured = datmat[mpp][np] - resmax;
                    }
                    //     Begin the operations that decide whether x(*) should replace one of the
                    //     vertices of the current simplex, the change being mandatory if TRURED is
                    //     positive. Firstly, JDROP is set to the index of the vertex that is to be
                    //     replaced.
                    ratio = trured <= 0.0 ? 1.0 : 0.0;
                    jdrop = 0;
                    for(j = 1; j <= n; ++j){
                        // temp = Math.abs(this.DOT_PRODUCT(this.PART(this.ROW(simi, j), 1, n), this.PART(dx, 1, n)));
                        temp = Math.abs(this.DOT_PRODUCT_ROW_COL(simi, j, dx, -1, 1, n));
                        if (temp > ratio) {
                            jdrop = j;
                            ratio = temp;
                        }
                        sigbar[j] = temp * vsig[j];
                    }
                    //     Calculate the value of ell.
                    edgmax = delta * rho;
                    l = 0;
                    for(j = 1; j <= n; ++j){
                        if (sigbar[j] >= parsig || sigbar[j] >= vsig[j]) {
                            temp = veta[j];
                            if (trured > 0.0) {
                                temp = 0.0;
                                for(k = 1; k <= n; ++k){
                                    temp += Math.pow(dx[k] - sim[k][j], 2.0);
                                }
                                temp = Math.sqrt(temp);
                            }
                            if (temp > edgmax) {
                                l = j;
                                edgmax = temp;
                            }
                        }
                    }
                    if (l > 0) {
                        jdrop = l;
                    }
                    if (jdrop !== 0) {
                        //     Revise the simplex by updating the elements of SIM, SIMI and DATMAT.
                        temp = 0.0;
                        for(i = 1; i <= n; ++i){
                            sim[i][jdrop] = dx[i];
                            temp += simi[jdrop][i] * dx[i];
                        }
                        for(k = 1; k <= n; ++k){
                            simi[jdrop][k] /= temp;
                        }
                        for(j = 1; j <= n; ++j){
                            if (j !== jdrop) {
                                // temp = this.DOT_PRODUCT(this.PART(this.ROW(simi, j), 1, n), this.PART(dx, 1, n));
                                temp = this.DOT_PRODUCT_ROW_COL(simi, j, dx, -1, 1, n);
                                for(k = 1; k <= n; ++k){
                                    simi[j][k] -= temp * simi[jdrop][k];
                                }
                            }
                        }
                        for(k = 1; k <= mpp; ++k){
                            datmat[k][jdrop] = con[k];
                        }
                        //     Branch back for further iterations with the current RHO.
                        if (trured > 0.0 && trured >= 0.1 * prerem) {
                            continue L_140;
                        }
                    }
                // If we end up here, we drop out.
                }while (!endless)
                if (!iflag) {
                    ibrnch = false;
                    continue L_140;
                }
                if (rho <= rhoend) {
                    status = this.Normal;
                    break L_40;
                }
                //     Otherwise reduce RHO if it is not at its least value and reset PARMU.
                cmin = 0.0;
                cmax = 0.0;
                rho *= 0.5;
                if (rho <= 1.5 * rhoend) {
                    rho = rhoend;
                }
                if (parmu > 0.0) {
                    denom = 0.0;
                    for(k = 1; k <= mp; ++k){
                        cmin = datmat[k][np];
                        cmax = cmin;
                        for(i = 1; i <= n; ++i){
                            cmin = Math.min(cmin, datmat[k][i]);
                            cmax = Math.max(cmax, datmat[k][i]);
                        }
                        if (k <= m && cmin < 0.5 * cmax) {
                            temp = Math.max(cmax, 0.0) - cmin;
                            denom = denom <= 0.0 ? temp : Math.min(denom, temp);
                        }
                    }
                    if (denom === 0.0) {
                        parmu = 0.0;
                    } else if (cmax - cmin < parmu * denom) {
                        parmu = (cmax - cmin) / denom;
                    }
                }
                if (iprint >= 2) {
                    console.log("Reduction in RHO to " + rho + "  and PARMU = " + parmu);
                }
                if (iprint === 2) {
                    this.PrintIterationResult(nfvals, datmat[mp][np], datmat[mpp][np], this.COL(sim, np), n, iprint);
                }
            }while (endless)
        }while (endless)
        switch(status){
            case this.Normal:
                if (iprint >= 1) {
                    console.log("%nNormal return from subroutine COBYLA%n");
                }
                if (ifull) {
                    if (iprint >= 1) {
                        this.PrintIterationResult(nfvals, f, resmax, x, n, iprint);
                    }
                    return status;
                }
                break;
            case this.MaxIterationsReached:
                if (iprint >= 1) {
                    console.log("%nReturn from subroutine COBYLA because the MAXFUN limit has been reached.%n");
                }
                break;
            case this.DivergingRoundingErrors:
                if (iprint >= 1) {
                    console.log("%nReturn from subroutine COBYLA because rounding errors are becoming damaging.%n");
                }
                break;
        }
        for(k = 1; k <= n; ++k){
            x[k] = sim[k][np];
        }
        f = datmat[mp][np];
        resmax = datmat[mpp][np];
        if (iprint >= 1) {
            this.PrintIterationResult(nfvals, f, resmax, x, n, iprint);
        }
        return status;
    },
    trstlp: function(n, m, a, b, rho, dx) {
        //(int n, int m, double[][] a, double[] b, double rho, double[] dx)
        // N.B. Arguments Z, ZDOTA, VMULTC, SDIRN, DXNEW, VMULTD & IACT have been removed.
        //     This subroutine calculates an N-component vector DX by applying the
        //     following two stages. In the first stage, DX is set to the shortest
        //     vector that minimizes the greatest violation of the constraints
        //       A(1,K)*DX(1)+A(2,K)*DX(2)+...+A(N,K)*DX(N) .GE. B(K), K = 2,3,...,M,
        //     subject to the Euclidean length of DX being at most RHO. If its length is
        //     strictly less than RHO, then we use the resultant freedom in DX to
        //     minimize the objective function
        //              -A(1,M+1)*DX(1) - A(2,M+1)*DX(2) - ... - A(N,M+1)*DX(N)
        //     subject to no increase in any greatest constraint violation. This
        //     notation allows the gradient of the objective function to be regarded as
        //     the gradient of a constraint. Therefore the two stages are distinguished
        //     by MCON .EQ. M and MCON .GT. M respectively. It is possible that a
        //     degeneracy may prevent DX from attaining the target length RHO. Then the
        //     value IFULL = 0 would be set, but usually IFULL = 1 on return.
        //
        //     In general NACT is the number of constraints in the active set and
        //     IACT(1),...,IACT(NACT) are their indices, while the remainder of IACT
        //     contains a permutation of the remaining constraint indices.  Further, Z
        //     is an orthogonal matrix whose first NACT columns can be regarded as the
        //     result of Gram-Schmidt applied to the active constraint gradients.  For
        //     J = 1,2,...,NACT, the number ZDOTA(J) is the scalar product of the J-th
        //     column of Z with the gradient of the J-th active constraint.  DX is the
        //     current vector of variables and here the residuals of the active
        //     constraints should be zero. Further, the active constraints have
        //     nonnegative Lagrange multipliers that are held at the beginning of
        //     VMULTC. The remainder of this vector holds the residuals of the inactive
        //     constraints at DX, the ordering of the components of VMULTC being in
        //     agreement with the permutation of the indices of the constraints that is
        //     in IACT. All these residuals are nonnegative, which is achieved by the
        //     shift RESMAX that makes the least residual zero.
        //     Initialize Z and some other variables. The value of RESMAX will be
        //     appropriate to DX = 0, while ICON will be the index of a most violated
        //     constraint if RESMAX is positive. Usually during the first stage the
        //     vector SDIRN gives a search direction that reduces all the active
        //     constraint violations by one simultaneously.
        // Local variables
        var temp = 0, nactx = 0, resold = 0.0, z = this.arr2(1 + n, 1 + n), zdota = this.arr(2 + m), vmultc = this.arr(2 + m), sdirn = this.arr(1 + n), dxnew = this.arr(1 + n), vmultd = this.arr(2 + m), iact = this.arr(2 + m), mcon = m, nact = 0, icon, resmax, i, k, first, optold, icount, step, stpful, optnew, ratio, isave, vsave, total, kp, kk, sp, alpha, beta, tot, spabs, acca, accb, zdotv, zdvabs, kw, dd, ss, sd, zdotw, zdwabs, kl, sumabs, tempa, endless = true;
        for(i = 1; i <= n; ++i){
            z[i][i] = 1.0;
            dx[i] = 0.0;
        }
        icon = 0;
        resmax = 0.0;
        if (m >= 1) {
            for(k = 1; k <= m; ++k){
                if (b[k] > resmax) {
                    resmax = b[k];
                    icon = k;
                }
            }
            for(k = 1; k <= m; ++k){
                iact[k] = k;
                vmultc[k] = resmax - b[k];
            }
        }
        //     End the current stage of the calculation if 3 consecutive iterations
        //     have either failed to reduce the best calculated value of the objective
        //     function or to increase the number of active constraints since the best
        //     value was calculated. This strategy prevents cycling, but there is a
        //     remote possibility that it will cause premature termination.
        first = true;
        do {
            L_60: do {
                if (!first || first && resmax === 0.0) {
                    mcon = m + 1;
                    icon = mcon;
                    iact[mcon] = mcon;
                    vmultc[mcon] = 0.0;
                }
                first = false;
                optold = 0.0;
                icount = 0;
                step = 0;
                stpful = 0;
                L_70: do {
                    // optnew = (mcon === m) ? resmax : -this.DOT_PRODUCT(this.PART(dx, 1, n), this.PART(this.COL(a, mcon), 1, n));
                    optnew = mcon === m ? resmax : -this.DOT_PRODUCT_ROW_COL(dx, -1, a, mcon, 1, n);
                    if (icount === 0 || optnew < optold) {
                        optold = optnew;
                        nactx = nact;
                        icount = 3;
                    } else if (nact > nactx) {
                        nactx = nact;
                        icount = 3;
                    } else {
                        --icount;
                    }
                    if (icount === 0) {
                        break L_60;
                    }
                    //     If ICON exceeds NACT, then we add the constraint with index IACT(ICON) to
                    //     the active set. Apply Givens rotations so that the last N-NACT-1 columns
                    //     of Z are orthogonal to the gradient of the new constraint, a scalar
                    //     product being set to zero if its nonzero value could be due to computer
                    //     rounding errors. The array DXNEW is used for working space.
                    ratio = 0;
                    if (icon <= nact) {
                        if (icon < nact) {
                            //     Delete the constraint that has the index IACT(ICON) from the active set.
                            isave = iact[icon];
                            vsave = vmultc[icon];
                            k = icon;
                            do {
                                kp = k + 1;
                                kk = iact[kp];
                                sp = this.DOT_PRODUCT(this.PART(this.COL(z, k), 1, n), this.PART(this.COL(a, kk), 1, n));
                                temp = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].hypot(sp, zdota[kp]);
                                alpha = zdota[kp] / temp;
                                beta = sp / temp;
                                zdota[kp] = alpha * zdota[k];
                                zdota[k] = temp;
                                for(i = 1; i <= n; ++i){
                                    temp = alpha * z[i][kp] + beta * z[i][k];
                                    z[i][kp] = alpha * z[i][k] - beta * z[i][kp];
                                    z[i][k] = temp;
                                }
                                iact[k] = kk;
                                vmultc[k] = vmultc[kp];
                                k = kp;
                            }while (k < nact)
                            iact[k] = isave;
                            vmultc[k] = vsave;
                        }
                        --nact;
                        //     If stage one is in progress, then set SDIRN to the direction of the next
                        //     change to the current vector of variables.
                        if (mcon > m) {
                            //     Pick the next search direction of stage two.
                            temp = 1.0 / zdota[nact];
                            for(k = 1; k <= n; ++k){
                                sdirn[k] = temp * z[k][nact];
                            }
                        } else {
                            // temp = this.DOT_PRODUCT(this.PART(sdirn, 1, n), this.PART(this.COL(z, nact + 1), 1, n));
                            temp = this.DOT_PRODUCT_ROW_COL(sdirn, -1, z, nact + 1, 1, n);
                            for(k = 1; k <= n; ++k){
                                sdirn[k] -= temp * z[k][nact + 1];
                            }
                        }
                    } else {
                        kk = iact[icon];
                        for(k = 1; k <= n; ++k){
                            dxnew[k] = a[k][kk];
                        }
                        tot = 0.0;
                        // {
                        k = n;
                        while(k > nact){
                            sp = 0.0;
                            spabs = 0.0;
                            for(i = 1; i <= n; ++i){
                                temp = z[i][k] * dxnew[i];
                                sp += temp;
                                spabs += Math.abs(temp);
                            }
                            acca = spabs + 0.1 * Math.abs(sp);
                            accb = spabs + 0.2 * Math.abs(sp);
                            if (spabs >= acca || acca >= accb) {
                                sp = 0.0;
                            }
                            if (tot === 0.0) {
                                tot = sp;
                            } else {
                                kp = k + 1;
                                temp = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].hypot(sp, tot);
                                alpha = sp / temp;
                                beta = tot / temp;
                                tot = temp;
                                for(i = 1; i <= n; ++i){
                                    temp = alpha * z[i][k] + beta * z[i][kp];
                                    z[i][kp] = alpha * z[i][kp] - beta * z[i][k];
                                    z[i][k] = temp;
                                }
                            }
                            --k;
                        }
                        // }
                        if (tot === 0.0) {
                            //     The next instruction is reached if a deletion has to be made from the
                            //     active set in order to make room for the new active constraint, because
                            //     the new constraint gradient is a linear combination of the gradients of
                            //     the old active constraints.  Set the elements of VMULTD to the multipliers
                            //     of the linear combination.  Further, set IOUT to the index of the
                            //     constraint to be deleted, but branch if no suitable index can be found.
                            ratio = -1.0;
                            //{
                            k = nact;
                            do {
                                zdotv = 0.0;
                                zdvabs = 0.0;
                                for(i = 1; i <= n; ++i){
                                    temp = z[i][k] * dxnew[i];
                                    zdotv += temp;
                                    zdvabs += Math.abs(temp);
                                }
                                acca = zdvabs + 0.1 * Math.abs(zdotv);
                                accb = zdvabs + 0.2 * Math.abs(zdotv);
                                if (zdvabs < acca && acca < accb) {
                                    temp = zdotv / zdota[k];
                                    if (temp > 0.0 && iact[k] <= m) {
                                        tempa = vmultc[k] / temp;
                                        if (ratio < 0.0 || tempa < ratio) {
                                            ratio = tempa;
                                        }
                                    }
                                    if (k >= 2) {
                                        kw = iact[k];
                                        for(i = 1; i <= n; ++i){
                                            dxnew[i] -= temp * a[i][kw];
                                        }
                                    }
                                    vmultd[k] = temp;
                                } else {
                                    vmultd[k] = 0.0;
                                }
                            }while (--k > 0)
                            //}
                            if (ratio < 0.0) {
                                break L_60;
                            }
                            //     Revise the Lagrange multipliers and reorder the active constraints so
                            //     that the one to be replaced is at the end of the list. Also calculate the
                            //     new value of ZDOTA(NACT) and branch if it is not acceptable.
                            for(k = 1; k <= nact; ++k){
                                vmultc[k] = Math.max(0.0, vmultc[k] - ratio * vmultd[k]);
                            }
                            if (icon < nact) {
                                isave = iact[icon];
                                vsave = vmultc[icon];
                                k = icon;
                                do {
                                    kp = k + 1;
                                    kw = iact[kp];
                                    sp = this.DOT_PRODUCT(this.PART(this.COL(z, k), 1, n), this.PART(this.COL(a, kw), 1, n));
                                    temp = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].hypot(sp, zdota[kp]);
                                    alpha = zdota[kp] / temp;
                                    beta = sp / temp;
                                    zdota[kp] = alpha * zdota[k];
                                    zdota[k] = temp;
                                    for(i = 1; i <= n; ++i){
                                        temp = alpha * z[i][kp] + beta * z[i][k];
                                        z[i][kp] = alpha * z[i][k] - beta * z[i][kp];
                                        z[i][k] = temp;
                                    }
                                    iact[k] = kw;
                                    vmultc[k] = vmultc[kp];
                                    k = kp;
                                }while (k < nact)
                                iact[k] = isave;
                                vmultc[k] = vsave;
                            }
                            temp = this.DOT_PRODUCT(this.PART(this.COL(z, nact), 1, n), this.PART(this.COL(a, kk), 1, n));
                            if (temp === 0.0) {
                                break L_60;
                            }
                            zdota[nact] = temp;
                            vmultc[icon] = 0.0;
                            vmultc[nact] = ratio;
                        } else {
                            //     Add the new constraint if this can be done without a deletion from the
                            //     active set.
                            ++nact;
                            zdota[nact] = tot;
                            vmultc[icon] = vmultc[nact];
                            vmultc[nact] = 0.0;
                        }
                        //     Update IACT and ensure that the objective function continues to be
                        //     treated as the last active constraint when MCON>M.
                        iact[icon] = iact[nact];
                        iact[nact] = kk;
                        if (mcon > m && kk !== mcon) {
                            k = nact - 1;
                            sp = this.DOT_PRODUCT(this.PART(this.COL(z, k), 1, n), this.PART(this.COL(a, kk), 1, n));
                            temp = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].hypot(sp, zdota[nact]);
                            alpha = zdota[nact] / temp;
                            beta = sp / temp;
                            zdota[nact] = alpha * zdota[k];
                            zdota[k] = temp;
                            for(i = 1; i <= n; ++i){
                                temp = alpha * z[i][nact] + beta * z[i][k];
                                z[i][nact] = alpha * z[i][k] - beta * z[i][nact];
                                z[i][k] = temp;
                            }
                            iact[nact] = iact[k];
                            iact[k] = kk;
                            temp = vmultc[k];
                            vmultc[k] = vmultc[nact];
                            vmultc[nact] = temp;
                        }
                        //     If stage one is in progress, then set SDIRN to the direction of the next
                        //     change to the current vector of variables.
                        if (mcon > m) {
                            //     Pick the next search direction of stage two.
                            temp = 1.0 / zdota[nact];
                            for(k = 1; k <= n; ++k){
                                sdirn[k] = temp * z[k][nact];
                            }
                        } else {
                            kk = iact[nact];
                            // temp = (this.DOT_PRODUCT(this.PART(sdirn, 1, n),this.PART(this.COL(a, kk), 1, n)) - 1.0) / zdota[nact];
                            temp = (this.DOT_PRODUCT_ROW_COL(sdirn, -1, a, kk, 1, n) - 1.0) / zdota[nact];
                            for(k = 1; k <= n; ++k){
                                sdirn[k] -= temp * z[k][nact];
                            }
                        }
                    }
                    //     Calculate the step to the boundary of the trust region or take the step
                    //     that reduces RESMAX to zero. The two statements below that include the
                    //     factor 1.0E-6 prevent some harmless underflows that occurred in a test
                    //     calculation. Further, we skip the step if it could be zero within a
                    //     reasonable tolerance for computer rounding errors.
                    dd = rho * rho;
                    sd = 0.0;
                    ss = 0.0;
                    for(i = 1; i <= n; ++i){
                        if (Math.abs(dx[i]) >= 1.0e-6 * rho) {
                            dd -= dx[i] * dx[i];
                        }
                        sd += dx[i] * sdirn[i];
                        ss += sdirn[i] * sdirn[i];
                    }
                    if (dd <= 0.0) {
                        break L_60;
                    }
                    temp = Math.sqrt(ss * dd);
                    if (Math.abs(sd) >= 1.0e-6 * temp) {
                        temp = Math.sqrt(ss * dd + sd * sd);
                    }
                    stpful = dd / (temp + sd);
                    step = stpful;
                    if (mcon === m) {
                        acca = step + 0.1 * resmax;
                        accb = step + 0.2 * resmax;
                        if (step >= acca || acca >= accb) {
                            break L_70;
                        }
                        step = Math.min(step, resmax);
                    }
                    //     Set DXNEW to the new variables if STEP is the steplength, and reduce
                    //     RESMAX to the corresponding maximum residual if stage one is being done.
                    //     Because DXNEW will be changed during the calculation of some Lagrange
                    //     multipliers, it will be restored to the following value later.
                    for(k = 1; k <= n; ++k){
                        dxnew[k] = dx[k] + step * sdirn[k];
                    }
                    if (mcon === m) {
                        resold = resmax;
                        resmax = 0.0;
                        for(k = 1; k <= nact; ++k){
                            kk = iact[k];
                            // temp = b[kk] - this.DOT_PRODUCT(this.PART(this.COL(a, kk), 1, n), this.PART(dxnew, 1, n));
                            temp = b[kk] - this.DOT_PRODUCT_ROW_COL(dxnew, -1, a, kk, 1, n);
                            resmax = Math.max(resmax, temp);
                        }
                    }
                    //     Set VMULTD to the VMULTC vector that would occur if DX became DXNEW. A
                    //     device is included to force VMULTD(K) = 0.0 if deviations from this value
                    //     can be attributed to computer rounding errors. First calculate the new
                    //     Lagrange multipliers.
                    //{
                    k = nact;
                    do {
                        zdotw = 0.0;
                        zdwabs = 0.0;
                        for(i = 1; i <= n; ++i){
                            temp = z[i][k] * dxnew[i];
                            zdotw += temp;
                            zdwabs += Math.abs(temp);
                        }
                        acca = zdwabs + 0.1 * Math.abs(zdotw);
                        accb = zdwabs + 0.2 * Math.abs(zdotw);
                        if (zdwabs >= acca || acca >= accb) {
                            zdotw = 0.0;
                        }
                        vmultd[k] = zdotw / zdota[k];
                        if (k >= 2) {
                            kk = iact[k];
                            for(i = 1; i <= n; ++i){
                                dxnew[i] -= vmultd[k] * a[i][kk];
                            }
                        }
                    }while (k-- >= 2)
                    if (mcon > m) {
                        vmultd[nact] = Math.max(0.0, vmultd[nact]);
                    }
                    //}
                    //     Complete VMULTC by finding the new constraint residuals.
                    for(k = 1; k <= n; ++k){
                        dxnew[k] = dx[k] + step * sdirn[k];
                    }
                    if (mcon > nact) {
                        kl = nact + 1;
                        for(k = kl; k <= mcon; ++k){
                            kk = iact[k];
                            total = resmax - b[kk];
                            sumabs = resmax + Math.abs(b[kk]);
                            for(i = 1; i <= n; ++i){
                                temp = a[i][kk] * dxnew[i];
                                total += temp;
                                sumabs += Math.abs(temp);
                            }
                            acca = sumabs + 0.1 * Math.abs(total);
                            accb = sumabs + 0.2 * Math.abs(total);
                            if (sumabs >= acca || acca >= accb) {
                                total = 0.0;
                            }
                            vmultd[k] = total;
                        }
                    }
                    //     Calculate the fraction of the step from DX to DXNEW that will be taken.
                    ratio = 1.0;
                    icon = 0;
                    for(k = 1; k <= mcon; ++k){
                        if (vmultd[k] < 0.0) {
                            temp = vmultc[k] / (vmultc[k] - vmultd[k]);
                            if (temp < ratio) {
                                ratio = temp;
                                icon = k;
                            }
                        }
                    }
                    //     Update DX, VMULTC and RESMAX.
                    temp = 1.0 - ratio;
                    for(k = 1; k <= n; ++k){
                        dx[k] = temp * dx[k] + ratio * dxnew[k];
                    }
                    for(k = 1; k <= mcon; ++k){
                        vmultc[k] = Math.max(0.0, temp * vmultc[k] + ratio * vmultd[k]);
                    }
                    if (mcon === m) {
                        resmax = resold + ratio * (resmax - resold);
                    }
                //     If the full step is not acceptable then begin another iteration.
                //     Otherwise switch to stage two or end the calculation.
                }while (icon > 0)
                if (step === stpful) {
                    return true;
                }
            }while (endless)
        //     We employ any freedom that may be available to reduce the objective
        //     function before returning a DX whose length is less than RHO.
        }while (mcon === m)
        return false;
    },
    PrintIterationResult: function(nfvals, f, resmax, x, n, iprint) {
        if (iprint > 1) {
            console.log("NFVALS = " + nfvals + "  F = " + f + "  MAXCV = " + resmax);
        }
        if (iprint > 1) {
            console.log("X = " + this.PART(x, 1, n));
        }
    },
    ROW: function(src, rowidx) {
        return src[rowidx].slice();
    // var col,
    //     cols = src[0].length,
    //     dest = this.arr(cols);
    // for (col = 0; col < cols; ++col) {
    //     dest[col] = src[rowidx][col];
    // }
    // return dest;
    },
    COL: function(src, colidx) {
        var row, rows = src.length, dest = []; // this.arr(rows);
        for(row = 0; row < rows; ++row){
            dest[row] = src[row][colidx];
        }
        return dest;
    },
    PART: function(src, from, to) {
        return src.slice(from, to + 1);
    // var srcidx,
    //     dest = this.arr(to - from + 1),
    //     destidx = 0;
    // for (srcidx = from; srcidx <= to; ++srcidx, ++destidx) {
    //     dest[destidx] = src[srcidx];
    // }
    // return dest;
    },
    FORMAT: function(x) {
        return x.join(",");
    // var i, fmt = "";
    // for (i = 0; i < x.length; ++i) {
    //     fmt += ", " + x[i];
    // }
    // return fmt;
    },
    DOT_PRODUCT: function(lhs, rhs) {
        var i, sum = 0.0, len = lhs.length;
        for(i = 0; i < len; ++i){
            sum += lhs[i] * rhs[i];
        }
        return sum;
    },
    DOT_PRODUCT_ROW_COL: function(lhs, row, rhs, col, start, end) {
        var i, sum = 0.0;
        if (row === -1) {
            // lhs is vector
            for(i = start; i <= end; ++i){
                sum += lhs[i] * rhs[i][col];
            }
        } else {
            // lhs is row of matrix
            if (col === -1) {
                // rhs is vector
                for(i = start; i <= end; ++i){
                    sum += lhs[row][i] * rhs[i];
                }
            } else {
                // rhs is column of matrix
                for(i = start; i <= end; ++i){
                    sum += lhs[row][i] * rhs[i][col];
                }
            }
        }
        return sum;
    }
};
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Math.Nlp;
}),
"[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/plot.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Alfred Wassermann

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */ /*global JXG: true, define: true*/ /*jslint nomen: true, plusplus: true*/ __turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/jxg.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/base/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/base/coords.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/math.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$extrapolate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/extrapolate.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$numerics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/numerics.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$statistics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/statistics.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/geometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$ia$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/ia.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/utils/type.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
/**
 * Functions for plotting of curves.
 * @name JXG.Math.Plot
 * @exports Mat.Plot as JXG.Math.Plot
 * @namespace
 */ __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Plot = {
    /**
     * Check if at least one point on the curve is finite and real.
     **/ checkReal: function(points) {
        var b = false, i, p, len = points.length;
        for(i = 0; i < len; i++){
            p = points[i].usrCoords;
            if (!isNaN(p[1]) && !isNaN(p[2]) && Math.abs(p[0]) > __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
                b = true;
                break;
            }
        }
        return b;
    },
    //----------------------------------------------------------------------
    // Plot algorithm v0
    //----------------------------------------------------------------------
    /**
     * Updates the data points of a parametric curve. This version is used if {@link JXG.Curve#doadvancedplot} is <tt>false</tt>.
     * @param {JXG.Curve} curve JSXGraph curve element
     * @param {Number} mi Left bound of curve
     * @param {Number} ma Right bound of curve
     * @param {Number} len Number of data points
     * @returns {JXG.Curve} Reference to the curve object.
     */ updateParametricCurveNaive: function(curve, mi, ma, len) {
        var i, t, suspendUpdate = false, stepSize = (ma - mi) / len;
        for(i = 0; i < len; i++){
            t = mi + i * stepSize;
            // The last parameter prevents rounding in usr2screen().
            curve.points[i].setCoordinates(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
                curve.X(t, suspendUpdate),
                curve.Y(t, suspendUpdate)
            ], false);
            curve.points[i]._t = t;
            suspendUpdate = true;
        }
        return curve;
    },
    //----------------------------------------------------------------------
    // Plot algorithm v1
    //----------------------------------------------------------------------
    /**
     * Crude and cheap test if the segment defined by the two points <tt>(x0, y0)</tt> and <tt>(x1, y1)</tt> is
     * outside the viewport of the board. All parameters have to be given in screen coordinates.
     *
     * @private
     * @deprecated
     * @param {Number} x0
     * @param {Number} y0
     * @param {Number} x1
     * @param {Number} y1
     * @param {JXG.Board} board
     * @returns {Boolean} <tt>true</tt> if the given segment is outside the visible area.
     */ isSegmentOutside: function(x0, y0, x1, y1, board) {
        return y0 < 0 && y1 < 0 || y0 > board.canvasHeight && y1 > board.canvasHeight || x0 < 0 && x1 < 0 || x0 > board.canvasWidth && x1 > board.canvasWidth;
    },
    /**
     * Compares the absolute value of <tt>dx</tt> with <tt>MAXX</tt> and the absolute value of <tt>dy</tt>
     * with <tt>MAXY</tt>.
     *
     * @private
     * @deprecated
     * @param {Number} dx
     * @param {Number} dy
     * @param {Number} MAXX
     * @param {Number} MAXY
     * @returns {Boolean} <tt>true</tt>, if <tt>|dx| &lt; MAXX</tt> and <tt>|dy| &lt; MAXY</tt>.
     */ isDistOK: function(dx, dy, MAXX, MAXY) {
        return Math.abs(dx) < MAXX && Math.abs(dy) < MAXY && !isNaN(dx + dy);
    },
    /**
     * @private
     * @deprecated
     */ isSegmentDefined: function(x0, y0, x1, y1) {
        return !(isNaN(x0 + y0) && isNaN(x1 + y1));
    },
    /**
     * Updates the data points of a parametric curve. This version is used if {@link JXG.Curve#doadvancedplot} is <tt>true</tt>.
     * Since 0.99 this algorithm is deprecated. It still can be used if {@link JXG.Curve#doadvancedplotold} is <tt>true</tt>.
     *
     * @deprecated
     * @param {JXG.Curve} curve JSXGraph curve element
     * @param {Number} mi Left bound of curve
     * @param {Number} ma Right bound of curve
     * @returns {JXG.Curve} Reference to the curve object.
     */ updateParametricCurveOld: function(curve, mi, ma) {
        var i, t, d, x, y, x0, y0, top, depth, MAX_DEPTH, MAX_XDIST, MAX_YDIST, suspendUpdate = false, po = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
            0,
            0
        ], curve.board, false), dyadicStack = [], depthStack = [], pointStack = [], divisors = [], distOK = false, j = 0, distFromLine = function(p1, p2, p0) {
            var lbda, x0 = p0[1] - p1[1], y0 = p0[2] - p1[2], x1 = p2[0] - p1[1], y1 = p2[1] - p1[2], den = x1 * x1 + y1 * y1;
            if (den >= __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
                lbda = (x0 * x1 + y0 * y1) / den;
                if (lbda > 0) {
                    if (lbda <= 1) {
                        x0 -= lbda * x1;
                        y0 -= lbda * y1;
                    // lbda = 1.0;
                    } else {
                        x0 -= x1;
                        y0 -= y1;
                    }
                }
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].hypot(x0, y0);
        };
        __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].deprecated("Curve.updateParametricCurveOld()");
        if (curve.board.updateQuality === curve.board.BOARD_QUALITY_LOW) {
            MAX_DEPTH = 15;
            MAX_XDIST = 10; // 10
            MAX_YDIST = 10; // 10
        } else {
            MAX_DEPTH = 21;
            MAX_XDIST = 0.7; // 0.7
            MAX_YDIST = 0.7; // 0.7
        }
        divisors[0] = ma - mi;
        for(i = 1; i < MAX_DEPTH; i++){
            divisors[i] = divisors[i - 1] * 0.5;
        }
        i = 1;
        dyadicStack[0] = 1;
        depthStack[0] = 0;
        t = mi;
        po.setCoordinates(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
            curve.X(t, suspendUpdate),
            curve.Y(t, suspendUpdate)
        ], false);
        // Now, there was a first call to the functions defining the curve.
        // Defining elements like sliders have been evaluated.
        // Therefore, we can set suspendUpdate to false, so that these defining elements
        // need not be evaluated anymore for the rest of the plotting.
        suspendUpdate = true;
        x0 = po.scrCoords[1];
        y0 = po.scrCoords[2];
        // t0 = t;
        t = ma;
        po.setCoordinates(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
            curve.X(t, suspendUpdate),
            curve.Y(t, suspendUpdate)
        ], false);
        x = po.scrCoords[1];
        y = po.scrCoords[2];
        pointStack[0] = [
            x,
            y
        ];
        top = 1;
        depth = 0;
        curve.points = [];
        curve.points[j++] = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_SCREEN, [
            x0,
            y0
        ], curve.board, false);
        do {
            distOK = this.isDistOK(x - x0, y - y0, MAX_XDIST, MAX_YDIST) || this.isSegmentOutside(x0, y0, x, y, curve.board);
            while(depth < MAX_DEPTH && (!distOK || depth < 6) && (depth <= 7 || this.isSegmentDefined(x0, y0, x, y))){
                // We jump out of the loop if
                // * depth>=MAX_DEPTH or
                // * (depth>=6 and distOK) or
                // * (depth>7 and segment is not defined)
                dyadicStack[top] = i;
                depthStack[top] = depth;
                pointStack[top] = [
                    x,
                    y
                ];
                top += 1;
                i = 2 * i - 1;
                // Here, depth is increased and may reach MAX_DEPTH
                depth++;
                // In that case, t is undefined and we will see a jump in the curve.
                t = mi + i * divisors[depth];
                po.setCoordinates(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
                    curve.X(t, suspendUpdate),
                    curve.Y(t, suspendUpdate)
                ], false, true);
                x = po.scrCoords[1];
                y = po.scrCoords[2];
                distOK = this.isDistOK(x - x0, y - y0, MAX_XDIST, MAX_YDIST) || this.isSegmentOutside(x0, y0, x, y, curve.board);
            }
            if (j > 1) {
                d = distFromLine(curve.points[j - 2].scrCoords, [
                    x,
                    y
                ], curve.points[j - 1].scrCoords);
                if (d < 0.015) {
                    j -= 1;
                }
            }
            curve.points[j] = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_SCREEN, [
                x,
                y
            ], curve.board, false);
            curve.points[j]._t = t;
            j += 1;
            x0 = x;
            y0 = y;
            // t0 = t;
            top -= 1;
            x = pointStack[top][0];
            y = pointStack[top][1];
            depth = depthStack[top] + 1;
            i = dyadicStack[top] * 2;
        }while (top > 0 && j < 500000)
        curve.numberPoints = curve.points.length;
        return curve;
    },
    //----------------------------------------------------------------------
    // Plot algorithm v2
    //----------------------------------------------------------------------
    /**
     * Add a point to the curve plot. If the new point is too close to the previously inserted point,
     * it is skipped.
     * Used in {@link JXG.Curve._plotRecursive}.
     *
     * @private
     * @param {JXG.Coords} pnt Coords to add to the list of points
     */ _insertPoint_v2: function(curve, pnt, t) {
        var lastReal = !isNaN(this._lastCrds[1] + this._lastCrds[2]), newReal = !isNaN(pnt.scrCoords[1] + pnt.scrCoords[2]), cw = curve.board.canvasWidth, ch = curve.board.canvasHeight, off = 500;
        newReal = newReal && pnt.scrCoords[1] > -off && pnt.scrCoords[2] > -off && pnt.scrCoords[1] < cw + off && pnt.scrCoords[2] < ch + off;
        /*
         * Prevents two consecutive NaNs or points wich are too close
         */ if (!newReal && lastReal || newReal && (!lastReal || Math.abs(pnt.scrCoords[1] - this._lastCrds[1]) > 0.7 || Math.abs(pnt.scrCoords[2] - this._lastCrds[2]) > 0.7)) {
            pnt._t = t;
            curve.points.push(pnt);
            this._lastCrds = pnt.copy("scrCoords");
        }
    },
    /**
     * Check if there is a single NaN function value at t0.
     * @param {*} curve
     * @param {*} t0
     * @returns {Boolean} true if there is a second NaN point close by, false otherwise
     */ neighborhood_isNaN_v2: function(curve, t0) {
        var is_undef, pnt = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
            0,
            0
        ], curve.board, false), t, p;
        t = t0 + __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps;
        pnt.setCoordinates(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
            curve.X(t, true),
            curve.Y(t, true)
        ], false);
        p = pnt.usrCoords;
        is_undef = isNaN(p[1] + p[2]);
        if (!is_undef) {
            t = t0 - __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps;
            pnt.setCoordinates(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
                curve.X(t, true),
                curve.Y(t, true)
            ], false);
            p = pnt.usrCoords;
            is_undef = isNaN(p[1] + p[2]);
            if (!is_undef) {
                return false;
            }
        }
        return true;
    },
    /**
     * Investigate a function term at the bounds of intervals where
     * the function is not defined, e.g. log(x) at x = 0.
     *
     * c is between a and b
     * @private
     * @param {JXG.Curve} curve JSXGraph curve element
     * @param {Array} a Screen coordinates of the left interval bound
     * @param {Array} b Screen coordinates of the right interval bound
     * @param {Array} c Screen coordinates of the bisection point at (ta + tb) / 2
     * @param {Number} ta Parameter which evaluates to a, i.e. [1, X(ta), Y(ta)] = a in screen coordinates
     * @param {Number} tb Parameter which evaluates to b, i.e. [1, X(tb), Y(tb)] = b in screen coordinates
     * @param {Number} tc (ta + tb) / 2 = tc. Parameter which evaluates to b, i.e. [1, X(tc), Y(tc)] = c in screen coordinates
     * @param {Number} depth Actual recursion depth. The recursion stops if depth is equal to 0.
     * @returns {JXG.Boolean} true if the point is inserted and the recursion should stop, false otherwise.
     */ _borderCase: function(curve, a, b, c, ta, tb, tc, depth) {
        var t, pnt, p, p_good = null, j, max_it = 30, is_undef = false, t_nan, t_real; // t_real2;
        // dx, dy,
        // vx, vy, vx2, vy2;
        // asymptote;
        if (depth <= 1) {
            pnt = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
                0,
                0
            ], curve.board, false);
            // Test if there is a single undefined point.
            // If yes, we ignore it.
            if (isNaN(a[1] + a[2]) && !isNaN(c[1] + c[2]) && !this.neighborhood_isNaN_v2(curve, ta)) {
                return false;
            }
            if (isNaN(b[1] + b[2]) && !isNaN(c[1] + c[2]) && !this.neighborhood_isNaN_v2(curve, tb)) {
                return false;
            }
            if (isNaN(c[1] + c[2]) && (!isNaN(a[1] + a[2]) || !isNaN(b[1] + b[2])) && !this.neighborhood_isNaN_v2(curve, tc)) {
                return false;
            }
            j = 0;
            // Bisect a, b and c until the point t_real is inside of the definition interval
            // and as close as possible at the boundary.
            // t_real2 is the second closest point.
            do {
                // There are four cases:
                //  a  |  c  |  b
                // ---------------
                // inf | R   | R
                // R   | R   | inf
                // inf | inf | R
                // R   | inf | inf
                //
                if (isNaN(a[1] + a[2]) && !isNaN(c[1] + c[2])) {
                    t_nan = ta;
                    t_real = tc;
                // t_real2 = tb;
                } else if (isNaN(b[1] + b[2]) && !isNaN(c[1] + c[2])) {
                    t_nan = tb;
                    t_real = tc;
                // t_real2 = ta;
                } else if (isNaN(c[1] + c[2]) && !isNaN(b[1] + b[2])) {
                    t_nan = tc;
                    t_real = tb;
                // t_real2 = tb + (tb - tc);
                } else if (isNaN(c[1] + c[2]) && !isNaN(a[1] + a[2])) {
                    t_nan = tc;
                    t_real = ta;
                // t_real2 = ta - (tc - ta);
                } else {
                    return false;
                }
                t = 0.5 * (t_nan + t_real);
                pnt.setCoordinates(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
                    curve.X(t, true),
                    curve.Y(t, true)
                ], false);
                p = pnt.usrCoords;
                is_undef = isNaN(p[1] + p[2]);
                if (is_undef) {
                    t_nan = t;
                } else {
                    // t_real2 = t_real;
                    t_real = t;
                }
                ++j;
            }while (is_undef && j < max_it)
            // If bisection was successful, take this point.
            // Useful only for general curves, for function graph
            // the code below overwrite p_good from here.
            if (j < max_it) {
                p_good = p.slice();
                c = p.slice();
                t_real = t;
            }
            // OK, bisection has been done now.
            // t_real contains the closest inner point to the border of the interval we could find.
            // t_real2 is the second nearest point to this boundary.
            // Now we approximate the derivative by computing the slope of the line through these two points
            // and test if it is "infinite", i.e larger than 400 in absolute values.
            //
            // vx = curve.X(t_real, true);
            // vx2 = curve.X(t_real2, true);
            // vy = curve.Y(t_real, true);
            // vy2 = curve.Y(t_real2, true);
            // dx = (vx - vx2) / (t_real - t_real2);
            // dy = (vy - vy2) / (t_real - t_real2);
            if (p_good !== null) {
                this._insertPoint_v2(curve, new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, p_good, curve.board, false));
                return true;
            }
        }
        return false;
    },
    /**
     * Recursive interval bisection algorithm for curve plotting.
     * Used in {@link JXG.Curve.updateParametricCurve}.
     * @private
     * @deprecated
     * @param {JXG.Curve} curve JSXGraph curve element
     * @param {Array} a Screen coordinates of the left interval bound
     * @param {Number} ta Parameter which evaluates to a, i.e. [1, X(ta), Y(ta)] = a in screen coordinates
     * @param {Array} b Screen coordinates of the right interval bound
     * @param {Number} tb Parameter which evaluates to b, i.e. [1, X(tb), Y(tb)] = b in screen coordinates
     * @param {Number} depth Actual recursion depth. The recursion stops if depth is equal to 0.
     * @param {Number} delta If the distance of the bisection point at (ta + tb) / 2 from the point (a + b) / 2 is less then delta,
     *                 the segment [a,b] is regarded as straight line.
     * @returns {JXG.Curve} Reference to the curve object.
     */ _plotRecursive_v2: function(curve, a, ta, b, tb, depth, delta) {
        var tc, c, ds, mindepth = 0, isSmooth, isJump, isCusp, cusp_threshold = 0.5, jump_threshold = 0.99, pnt = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
            0,
            0
        ], curve.board, false);
        if (curve.numberPoints > 65536) {
            return;
        }
        // Test if the function is undefined in an interval
        if (depth < this.nanLevel && this._isUndefined(curve, a, ta, b, tb)) {
            return this;
        }
        if (depth < this.nanLevel && this._isOutside(a, ta, b, tb, curve.board)) {
            return this;
        }
        tc = (ta + tb) * 0.5;
        pnt.setCoordinates(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
            curve.X(tc, true),
            curve.Y(tc, true)
        ], false);
        c = pnt.scrCoords;
        if (this._borderCase(curve, a, b, c, ta, tb, tc, depth)) {
            return this;
        }
        ds = this._triangleDists(a, b, c); // returns [d_ab, d_ac, d_cb, d_cd]
        isSmooth = depth < this.smoothLevel && ds[3] < delta;
        isJump = depth <= this.jumpLevel && (isNaN(ds[0]) || isNaN(ds[1]) || isNaN(ds[2])) || depth < this.jumpLevel && (ds[2] > jump_threshold * ds[0] || ds[1] > jump_threshold * ds[0] || ds[0] === Infinity || ds[1] === Infinity || ds[2] === Infinity);
        isCusp = depth < this.smoothLevel + 2 && ds[0] < cusp_threshold * (ds[1] + ds[2]);
        if (isCusp) {
            mindepth = 0;
            isSmooth = false;
        }
        --depth;
        if (isJump) {
            this._insertPoint_v2(curve, new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_SCREEN, [
                NaN,
                NaN
            ], curve.board, false), tc);
        } else if (depth <= mindepth || isSmooth) {
            this._insertPoint_v2(curve, pnt, tc);
        //if (this._borderCase(a, b, c, ta, tb, tc, depth)) {}
        } else {
            this._plotRecursive_v2(curve, a, ta, c, tc, depth, delta);
            if (!isNaN(pnt.scrCoords[1] + pnt.scrCoords[2])) {
                this._insertPoint_v2(curve, pnt, tc);
            }
            this._plotRecursive_v2(curve, c, tc, b, tb, depth, delta);
        }
        return this;
    },
    /**
     * Updates the data points of a parametric curve. This version is used if {@link JXG.Curve#plotVersion} is <tt>3</tt>.
     *
     * @param {JXG.Curve} curve JSXGraph curve element
     * @param {Number} mi Left bound of curve
     * @param {Number} ma Right bound of curve
     * @returns {JXG.Curve} Reference to the curve object.
     */ updateParametricCurve_v2: function(curve, mi, ma) {
        var ta, tb, a, b, suspendUpdate = false, pa = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
            0,
            0
        ], curve.board, false), pb = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
            0,
            0
        ], curve.board, false), depth, delta, w2, // h2,
        bbox, ret_arr;
        //console.time("plot");
        if (curve.board.updateQuality === curve.board.BOARD_QUALITY_LOW) {
            depth = curve.evalVisProp('recursiondepthlow') || 13;
            delta = 2;
            // this.smoothLevel = 5; //depth - 7;
            this.smoothLevel = depth - 6;
            this.jumpLevel = 3;
        } else {
            depth = curve.evalVisProp('recursiondepthhigh') || 17;
            delta = 2;
            // smoothLevel has to be small for graphs in a huge interval.
            // this.smoothLevel = 3; //depth - 7; // 9
            this.smoothLevel = depth - 9; // 9
            this.jumpLevel = 2;
        }
        this.nanLevel = depth - 4;
        curve.points = [];
        if (this.xterm === "x") {
            // For function graphs we can restrict the plot interval
            // to the visible area + plus margin
            bbox = curve.board.getBoundingBox();
            w2 = (bbox[2] - bbox[0]) * 0.3;
            // h2 = (bbox[1] - bbox[3]) * 0.3;
            ta = Math.max(mi, bbox[0] - w2);
            tb = Math.min(ma, bbox[2] + w2);
        } else {
            ta = mi;
            tb = ma;
        }
        pa.setCoordinates(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
            curve.X(ta, suspendUpdate),
            curve.Y(ta, suspendUpdate)
        ], false);
        // The first function calls of X() and Y() are done. We can now
        // switch `suspendUpdate` on. If supported by the functions, this
        // avoids for the rest of the plotting algorithm, evaluation of any
        // parent elements.
        suspendUpdate = true;
        pb.setCoordinates(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
            curve.X(tb, suspendUpdate),
            curve.Y(tb, suspendUpdate)
        ], false);
        // Find start and end points of the visible area (plus a certain margin)
        ret_arr = this._findStartPoint(curve, pa.scrCoords, ta, pb.scrCoords, tb);
        pa.setCoordinates(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_SCREEN, ret_arr[0], false);
        ta = ret_arr[1];
        ret_arr = this._findStartPoint(curve, pb.scrCoords, tb, pa.scrCoords, ta);
        pb.setCoordinates(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_SCREEN, ret_arr[0], false);
        tb = ret_arr[1];
        // Save the visible area.
        // This can be used in Curve.hasPoint().
        this._visibleArea = [
            ta,
            tb
        ];
        // Start recursive plotting algorithm
        a = pa.copy("scrCoords");
        b = pb.copy("scrCoords");
        pa._t = ta;
        curve.points.push(pa);
        this._lastCrds = pa.copy("scrCoords"); // Used in _insertPoint
        this._plotRecursive_v2(curve, a, ta, b, tb, depth, delta);
        pb._t = tb;
        curve.points.push(pb);
        curve.numberPoints = curve.points.length;
        //console.timeEnd("plot");
        return curve;
    },
    //----------------------------------------------------------------------
    // Plot algorithm v3
    //----------------------------------------------------------------------
    /**
     *
     * @param {JXG.Curve} curve JSXGraph curve element
     * @param {*} pnt
     * @param {*} t
     * @param {*} depth
     * @param {*} limes
     * @private
     */ _insertLimesPoint: function(curve, pnt, t, depth, limes) {
        var p0, p1, p2;
        // Ignore jump point if it follows limes
        if (Math.abs(this._lastUsrCrds[1]) === Infinity && Math.abs(limes.left_x) === Infinity || Math.abs(this._lastUsrCrds[2]) === Infinity && Math.abs(limes.left_y) === Infinity) {
            // console.log("SKIP:", pnt.usrCoords, this._lastUsrCrds, limes);
            return;
        }
        // // Ignore jump left from limes
        // if (Math.abs(limes.left_x) > 100 * Math.abs(this._lastUsrCrds[1])) {
        //     x = Math.sign(limes.left_x) * Infinity;
        // } else {
        //     x = limes.left_x;
        // }
        // if (Math.abs(limes.left_y) > 100 * Math.abs(this._lastUsrCrds[2])) {
        //     y = Math.sign(limes.left_y) * Infinity;
        // } else {
        //     y = limes.left_y;
        // }
        // //pnt.setCoordinates(Const.COORDS_BY_USER, [x, y], false);
        // Add points at a jump. pnt contains [NaN, NaN]
        //console.log("Add", t, pnt.usrCoords, limes, depth)
        p0 = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
            limes.left_x,
            limes.left_y
        ], curve.board);
        p0._t = t;
        curve.points.push(p0);
        if (!isNaN(limes.left_x) && !isNaN(limes.left_y) && !isNaN(limes.right_x) && !isNaN(limes.right_y) && (Math.abs(limes.left_x - limes.right_x) > __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps || Math.abs(limes.left_y - limes.right_y) > __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps)) {
            p1 = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_SCREEN, pnt, curve.board);
            p1._t = t;
            curve.points.push(p1);
        }
        p2 = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
            limes.right_x,
            limes.right_y
        ], curve.board);
        p2._t = t;
        curve.points.push(p2);
        this._lastScrCrds = p2.copy("scrCoords");
        this._lastUsrCrds = p2.copy("usrCoords");
    },
    /**
     * Add a point to the curve plot. If the new point is too close to the previously inserted point,
     * it is skipped.
     * Used in {@link JXG.Curve._plotRecursive}.
     *
     * @private
     * @param {JXG.Curve} curve JSXGraph curve element
     * @param {JXG.Coords} pnt Coords to add to the list of points
     */ _insertPoint: function(curve, pnt, t, depth, limes) {
        var last_is_real = !isNaN(this._lastScrCrds[1] + this._lastScrCrds[2]), point_is_real = !isNaN(pnt[1] + pnt[2]), cw = curve.board.canvasWidth, ch = curve.board.canvasHeight, p, near = 0.8, off = 500;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(limes)) {
            this._insertLimesPoint(curve, pnt, t, depth, limes);
            return;
        }
        // Check if point has real coordinates and
        // coordinates are not too far away from canvas.
        point_is_real = point_is_real && pnt[1] > -off && pnt[2] > -off && pnt[1] < cw + off && pnt[2] < ch + off;
        // Prevent two consecutive NaNs
        if (!last_is_real && !point_is_real) {
            return;
        }
        // Prevent two consecutive points which are too close
        if (point_is_real && last_is_real && Math.abs(pnt[1] - this._lastScrCrds[1]) < near && Math.abs(pnt[2] - this._lastScrCrds[2]) < near) {
            return;
        }
        // Prevent two consecutive points at infinity (either direction)
        if (Math.abs(pnt[1]) === Infinity && Math.abs(this._lastUsrCrds[1]) === Infinity || Math.abs(pnt[2]) === Infinity && Math.abs(this._lastUsrCrds[2]) === Infinity) {
            return;
        }
        //console.log("add", t, pnt.usrCoords, depth)
        // Add regular point
        p = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_SCREEN, pnt, curve.board);
        p._t = t;
        curve.points.push(p);
        this._lastScrCrds = p.copy("scrCoords");
        this._lastUsrCrds = p.copy("usrCoords");
    },
    /**
     * Compute distances in screen coordinates between the points ab,
     * ac, cb, and cd, where d = (a + b)/2.
     * cd is used for the smoothness test, ab, ac, cb are used to detect jumps, cusps and poles.
     *
     * @private
     * @param {Array} a Screen coordinates of the left interval bound
     * @param {Array} b Screen coordinates of the right interval bound
     * @param {Array} c Screen coordinates of the bisection point at (ta + tb) / 2
     * @returns {Array} array of distances in screen coordinates between: ab, ac, cb, and cd.
     */ _triangleDists: function(a, b, c) {
        var d, d_ab, d_ac, d_cb, d_cd;
        d = [
            a[0] * b[0],
            (a[1] + b[1]) * 0.5,
            (a[2] + b[2]) * 0.5
        ];
        d_ab = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].distance(a, b, 3);
        d_ac = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].distance(a, c, 3);
        d_cb = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].distance(c, b, 3);
        d_cd = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].distance(c, d, 3);
        return [
            d_ab,
            d_ac,
            d_cb,
            d_cd
        ];
    },
    /**
     * Test if the function is undefined on an interval:
     * If the interval borders a and b are undefined, 20 random values
     * are tested if they are undefined, too.
     * Only if all values are undefined, we declare the function to be undefined in this interval.
     *
     * @private
     * @param {JXG.Curve} curve JSXGraph curve element
     * @param {Array} a Screen coordinates of the left interval bound
     * @param {Number} ta Parameter which evaluates to a, i.e. [1, X(ta), Y(ta)] = a in screen coordinates
     * @param {Array} b Screen coordinates of the right interval bound
     * @param {Number} tb Parameter which evaluates to b, i.e. [1, X(tb), Y(tb)] = b in screen coordinates
     */ _isUndefined: function(curve, a, ta, b, tb) {
        var t, i, pnt;
        if (!isNaN(a[1] + a[2]) || !isNaN(b[1] + b[2])) {
            return false;
        }
        pnt = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
            0,
            0
        ], curve.board, false);
        for(i = 0; i < 20; ++i){
            t = ta + Math.random() * (tb - ta);
            pnt.setCoordinates(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
                curve.X(t, true),
                curve.Y(t, true)
            ], false);
            if (!isNaN(pnt.scrCoords[0] + pnt.scrCoords[1] + pnt.scrCoords[2])) {
                return false;
            }
        }
        return true;
    },
    /**
     * Decide if a path segment is too far from the canvas that we do not need to draw it.
     * @private
     * @param  {Array}  a  Screen coordinates of the start point of the segment
     * @param  {Array}  ta Curve parameter of a  (unused).
     * @param  {Array}  b  Screen coordinates of the end point of the segment
     * @param  {Array}  tb Curve parameter of b (unused).
     * @param  {JXG.Board} board
     * @returns {Boolean}   True if the segment is too far away from the canvas, false otherwise.
     */ _isOutside: function(a, ta, b, tb, board) {
        var off = 500, cw = board.canvasWidth, ch = board.canvasHeight;
        return !!(a[1] < -off && b[1] < -off || a[2] < -off && b[2] < -off || a[1] > cw + off && b[1] > cw + off || a[2] > ch + off && b[2] > ch + off);
    },
    /**
     * Decide if a point of a curve is too far from the canvas that we do not need to draw it.
     * @private
     * @param {Array}  a  Screen coordinates of the point
     * @param {JXG.Board} board
     * @returns {Boolean}  True if the point is too far away from the canvas, false otherwise.
     */ _isOutsidePoint: function(a, board) {
        var off = 500, cw = board.canvasWidth, ch = board.canvasHeight;
        return !!(a[1] < -off || a[2] < -off || a[1] > cw + off || a[2] > ch + off);
    },
    /**
     * For a curve c(t) defined on the interval [ta, tb] find the first point
     * which is in the visible area of the board (plus some outside margin).
     * <p>
     * This method is necessary to restrict the recursive plotting algorithm
     * {@link JXG.Curve._plotRecursive} to the visible area and not waste
     * recursion to areas far outside of the visible area.
     * <p>
     * This method can also be used to find the last visible point
     * by reversing the input parameters.
     *
     * @param {JXG.Curve} curve JSXGraph curve element
     * @param  {Array}  ta Curve parameter of a.
     * @param  {Array}  b  Screen coordinates of the end point of the segment (unused)
     * @param  {Array}  tb Curve parameter of b
     * @return {Array}  Array of length two containing the screen ccordinates of
     * the starting point and the curve parameter at this point.
     * @private
     */ _findStartPoint: function(curve, a, ta, b, tb) {
        // The code below is too unstable.
        // E.g. [function(t) { return Math.pow(t, 2) * (t + 5) * Math.pow(t - 5, 2); }, -8, 8]
        // Therefore, we return here.
        return [
            a,
            ta
        ];
    // var i,
    //     delta,
    //     tc,
    //     td,
    //     z,
    //     isFound,
    //     w2,
    //     h2,
    //     pnt = new Coords(Const.COORDS_BY_USER, [0, 0], curve.board, false),
    //     steps = 40,
    //     eps = 0.01,
    //     fnX1,
    //     fnX2,
    //     fnY1,
    //     fnY2,
    //     bbox = curve.board.getBoundingBox();
    // if (true || !this._isOutsidePoint(a, curve.board)) {
    //     return [a, ta];
    // }
    // w2 = (bbox[2] - bbox[0]) * 0.3;
    // h2 = (bbox[1] - bbox[3]) * 0.3;
    // bbox[0] -= w2;
    // bbox[1] += h2;
    // bbox[2] += w2;
    // bbox[3] -= h2;
    // delta = (tb - ta) / steps;
    // tc = ta + delta;
    // isFound = false;
    // fnX1 = function (t) {
    //     return curve.X(t, true) - bbox[0];
    // };
    // fnY1 = function (t) {
    //     return curve.Y(t, true) - bbox[1];
    // };
    // fnX2 = function (t) {
    //     return curve.X(t, true) - bbox[2];
    // };
    // fnY2 = function (t) {
    //     return curve.Y(t, true) - bbox[3];
    // };
    // for (i = 0; i < steps; ++i) {
    //     // Left border
    //     z = bbox[0];
    //     td = Numerics.root(fnX1, [tc - delta, tc], curve);
    //     // td = Numerics.fzero(fnX1, [tc - delta, tc], this);
    //     // console.log("A", tc - delta, tc, td, Math.abs(this.X(td, true) - z));
    //     if (Math.abs(curve.X(td, true) - z) < eps) {
    //         //} * Math.abs(z)) {
    //         isFound = true;
    //         break;
    //     }
    //     // Top border
    //     z = bbox[1];
    //     td = Numerics.root(fnY1, [tc - delta, tc], curve);
    //     // td = Numerics.fzero(fnY1, [tc - delta, tc], this);
    //     // console.log("B", tc - delta, tc, td, Math.abs(this.Y(td, true) - z));
    //     if (Math.abs(curve.Y(td, true) - z) < eps) {
    //         // * Math.abs(z)) {
    //         isFound = true;
    //         break;
    //     }
    //     // Right border
    //     z = bbox[2];
    //     td = Numerics.root(fnX2, [tc - delta, tc], curve);
    //     // td = Numerics.fzero(fnX2, [tc - delta, tc], this);
    //     // console.log("C", tc - delta, tc, td, Math.abs(this.X(td, true) - z));
    //     if (Math.abs(curve.X(td, true) - z) < eps) {
    //         // * Math.abs(z)) {
    //         isFound = true;
    //         break;
    //     }
    //     // Bottom border
    //     z = bbox[3];
    //     td = Numerics.root(fnY2, [tc - delta, tc], curve);
    //     // td = Numerics.fzero(fnY2, [tc - delta, tc], this);
    //     // console.log("D", tc - delta, tc, td, Math.abs(this.Y(td, true) - z));
    //     if (Math.abs(curve.Y(td, true) - z) < eps) {
    //         // * Math.abs(z)) {
    //         isFound = true;
    //         break;
    //     }
    //     tc += delta;
    // }
    // if (isFound) {
    //     pnt.setCoordinates(
    //         Const.COORDS_BY_USER,
    //         [curve.X(td, true), curve.Y(td, true)],
    //         false
    //     );
    //     return [pnt.scrCoords, td];
    // }
    // console.log("TODO _findStartPoint", curve.Y.toString(), tc);
    // pnt.setCoordinates(Const.COORDS_BY_USER, [curve.X(ta, true), curve.Y(ta, true)], false);
    // return [pnt.scrCoords, ta];
    },
    /**
     * Investigate a function term at the bounds of intervals where
     * the function is not defined, e.g. log(x) at x = 0.
     *
     * c is inbetween a and b
     *
     * @param {JXG.Curve} curve JSXGraph curve element
     * @param {Array} a Screen coordinates of the left interval bound
     * @param {Array} b Screen coordinates of the right interval bound
     * @param {Array} c Screen coordinates of the bisection point at (ta + tb) / 2
     * @param {Number} ta Parameter which evaluates to a, i.e. [1, X(ta), Y(ta)] = a in screen coordinates
     * @param {Number} tb Parameter which evaluates to b, i.e. [1, X(tb), Y(tb)] = b in screen coordinates
     * @param {Number} tc (ta + tb) / 2 = tc. Parameter which evaluates to b, i.e. [1, X(tc), Y(tc)] = c in screen coordinates
     * @param {Number} depth Actual recursion depth. The recursion stops if depth is equal to 0.
     * @returns {JXG.Boolean} true if the point is inserted and the recursion should stop, false otherwise.
     *
     * @private
     */ _getBorderPos: function(curve, ta, a, tc, c, tb, b) {
        var t, pnt, p, j, max_it = 30, is_undef = false, t_good, t_bad;
        pnt = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
            0,
            0
        ], curve.board, false);
        j = 0;
        // Bisect a, b and c until the point t_real is inside of the definition interval
        // and as close as possible at the boundary.
        // (t_real2 is/was the second closest point).
        // There are four cases:
        //  a  |  c  |  b
        // ---------------
        // inf | R   | R
        // R   | R   | inf
        // inf | inf | R
        // R   | inf | inf
        //
        if (isNaN(a[1] + a[2]) && !isNaN(c[1] + c[2])) {
            t_bad = ta;
            t_good = tc;
        } else if (isNaN(b[1] + b[2]) && !isNaN(c[1] + c[2])) {
            t_bad = tb;
            t_good = tc;
        } else if (isNaN(c[1] + c[2]) && !isNaN(b[1] + b[2])) {
            t_bad = tc;
            t_good = tb;
        } else if (isNaN(c[1] + c[2]) && !isNaN(a[1] + a[2])) {
            t_bad = tc;
            t_good = ta;
        } else {
            return false;
        }
        do {
            t = 0.5 * (t_good + t_bad);
            pnt.setCoordinates(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
                curve.X(t, true),
                curve.Y(t, true)
            ], false);
            p = pnt.usrCoords;
            is_undef = isNaN(p[1] + p[2]);
            if (is_undef) {
                t_bad = t;
            } else {
                t_good = t;
            }
            ++j;
        }while (j < max_it && Math.abs(t_good - t_bad) > __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps)
        return t;
    },
    /**
     *
     * @param {JXG.Curve} curve JSXGraph curve element
     * @param {Number} ta
     * @param {Number} tb
     */ _getCuspPos: function(curve, ta, tb) {
        var a = [
            curve.X(ta, true),
            curve.Y(ta, true)
        ], b = [
            curve.X(tb, true),
            curve.Y(tb, true)
        ], max_func = function(t) {
            var c = [
                curve.X(t, true),
                curve.Y(t, true)
            ];
            return -(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].hypot(a[0] - c[0], a[1] - c[1]) + __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].hypot(b[0] - c[0], b[1] - c[1]));
        };
        return __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$numerics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fminbr(max_func, [
            ta,
            tb
        ], curve);
    },
    /**
     *
     * @param {JXG.Curve} curve JSXGraph curve element
     * @param {Number} ta
     * @param {Number} tb
     */ _getJumpPos: function(curve, ta, tb) {
        var max_func = function(t) {
            var e = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps * __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps, c1 = [
                curve.X(t, true),
                curve.Y(t, true)
            ], c2 = [
                curve.X(t + e, true),
                curve.Y(t + e, true)
            ];
            return -Math.abs((c2[1] - c1[1]) / (c2[0] - c1[0]));
        };
        return __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$numerics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fminbr(max_func, [
            ta,
            tb
        ], curve);
    },
    /**
     *
     * @param {JXG.Curve} curve JSXGraph curve element
     * @param {Number} t
     * @private
     */ _getLimits: function(curve, t) {
        var res, step = 2 / (curve.maxX() - curve.minX()), x_l, x_r, y_l, y_r;
        // From left
        res = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$extrapolate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].limit(t, -step, curve.X);
        x_l = res[0];
        if (res[1] === "infinite") {
            x_l = Math.sign(x_l) * Infinity;
        }
        res = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$extrapolate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].limit(t, -step, curve.Y);
        y_l = res[0];
        if (res[1] === "infinite") {
            y_l = Math.sign(y_l) * Infinity;
        }
        // From right
        res = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$extrapolate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].limit(t, step, curve.X);
        x_r = res[0];
        if (res[1] === "infinite") {
            x_r = Math.sign(x_r) * Infinity;
        }
        res = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$extrapolate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].limit(t, step, curve.Y);
        y_r = res[0];
        if (res[1] === "infinite") {
            y_r = Math.sign(y_r) * Infinity;
        }
        return {
            left_x: x_l,
            left_y: y_l,
            right_x: x_r,
            right_y: y_r,
            t: t
        };
    },
    /**
     *
     * @param {JXG.Curve} curve JSXGraph curve element
     * @param {Array} a
     * @param {Number} tc
     * @param {Array} c
     * @param {Number} tb
     * @param {Array} b
     * @param {String} may_be_special
     * @param {Number} depth
     * @private
     */ _getLimes: function(curve, ta, a, tc, c, tb, b, may_be_special, depth) {
        var t;
        if (may_be_special === "border") {
            t = this._getBorderPos(curve, ta, a, tc, c, tb, b);
        } else if (may_be_special === "cusp") {
            t = this._getCuspPos(curve, ta, tb);
        } else if (may_be_special === "jump") {
            t = this._getJumpPos(curve, ta, tb);
        }
        return this._getLimits(curve, t);
    },
    /**
     * Recursive interval bisection algorithm for curve plotting.
     * Used in {@link JXG.Curve.updateParametricCurve}.
     * @private
     * @param {JXG.Curve} curve JSXGraph curve element
     * @param {Array} a Screen coordinates of the left interval bound
     * @param {Number} ta Parameter which evaluates to a, i.e. [1, X(ta), Y(ta)] = a in screen coordinates
     * @param {Array} b Screen coordinates of the right interval bound
     * @param {Number} tb Parameter which evaluates to b, i.e. [1, X(tb), Y(tb)] = b in screen coordinates
     * @param {Number} depth Actual recursion depth. The recursion stops if depth is equal to 0.
     * @param {Number} delta If the distance of the bisection point at (ta + tb) / 2 from the point (a + b) / 2 is less then delta,
     *                 the segment [a,b] is regarded as straight line.
     * @returns {JXG.Curve} Reference to the curve object.
     */ _plotNonRecursive: function(curve, a, ta, b, tb, d) {
        var tc, c, ds, mindepth = 0, limes = null, a_nan, b_nan, isSmooth = false, may_be_special = "", x, y, oc, depth, ds0, stack = [], stack_length = 0, item;
        oc = curve.board.origin.scrCoords;
        stack[stack_length++] = [
            a,
            ta,
            b,
            tb,
            d,
            Infinity
        ];
        while(stack_length > 0){
            // item = stack.pop();
            item = stack[--stack_length];
            a = item[0];
            ta = item[1];
            b = item[2];
            tb = item[3];
            depth = item[4];
            ds0 = item[5];
            isSmooth = false;
            may_be_special = "";
            limes = null;
            //console.log(stack.length, item)
            if (curve.points.length > 65536) {
                return;
            }
            if (depth < this.nanLevel) {
                // Test if the function is undefined in the whole interval [ta, tb]
                if (this._isUndefined(curve, a, ta, b, tb)) {
                    continue;
                }
                // Test if the graph is far outside the visible are for the interval [ta, tb]
                if (this._isOutside(a, ta, b, tb, curve.board)) {
                    continue;
                }
            }
            tc = (ta + tb) * 0.5;
            // Screen coordinates of point at tc
            x = curve.X(tc, true);
            y = curve.Y(tc, true);
            c = [
                1,
                oc[1] + x * curve.board.unitX,
                oc[2] - y * curve.board.unitY
            ];
            ds = this._triangleDists(a, b, c); // returns [d_ab, d_ac, d_cb, d_cd]
            a_nan = isNaN(a[1] + a[2]);
            b_nan = isNaN(b[1] + b[2]);
            if (a_nan && !b_nan || !a_nan && b_nan) {
                may_be_special = "border";
            } else if (ds[0] > 0.66 * ds0 || ds[0] < this.cusp_threshold * (ds[1] + ds[2]) || ds[1] > 5 * ds[2] || ds[2] > 5 * ds[1]) {
                may_be_special = "cusp";
            } else if (ds[2] > this.jump_threshold * ds[0] || ds[1] > this.jump_threshold * ds[0] || ds[0] === Infinity || ds[1] === Infinity || ds[2] === Infinity) {
                may_be_special = "jump";
            }
            isSmooth = may_be_special === "" && depth < this.smoothLevel && ds[3] < this.smooth_threshold;
            if (depth < this.testLevel && !isSmooth) {
                if (may_be_special === "") {
                    isSmooth = true;
                } else {
                    limes = this._getLimes(curve, ta, a, tc, c, tb, b, may_be_special, depth);
                }
            }
            if (limes !== null) {
                c = [
                    1,
                    NaN,
                    NaN
                ];
                this._insertPoint(curve, c, tc, depth, limes);
            } else if (depth <= mindepth || isSmooth) {
                this._insertPoint(curve, c, tc, depth, null);
            } else {
                stack[stack_length++] = [
                    c,
                    tc,
                    b,
                    tb,
                    depth - 1,
                    ds[0]
                ];
                stack[stack_length++] = [
                    a,
                    ta,
                    c,
                    tc,
                    depth - 1,
                    ds[0]
                ];
            }
        }
        return this;
    },
    /**
     * Updates the data points of a parametric curve. This version is used if {@link JXG.Curve#plotVersion} is <tt>3</tt>.
     * This is an experimental plot version, <b>not recommended</b> to be used.
     * @param {JXG.Curve} curve JSXGraph curve element
     * @param {Number} mi Left bound of curve
     * @param {Number} ma Right bound of curve
     * @returns {JXG.Curve} Reference to the curve object.
     */ updateParametricCurve_v3: function(curve, mi, ma) {
        var ta, tb, a, b, suspendUpdate = false, pa = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
            0,
            0
        ], curve.board, false), pb = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
            0,
            0
        ], curve.board, false), depth, w2, bbox, ret_arr;
        // console.log("-----------------------------------------------------------");
        // console.time("plot");
        if (curve.board.updateQuality === curve.board.BOARD_QUALITY_LOW) {
            depth = curve.evalVisProp('recursiondepthlow') || 14;
        } else {
            depth = curve.evalVisProp('recursiondepthhigh') || 17;
        }
        // smoothLevel has to be small for graphs in a huge interval.
        this.smoothLevel = 7; //depth - 10;
        this.nanLevel = depth - 4;
        this.testLevel = 4;
        this.cusp_threshold = 0.5;
        this.jump_threshold = 0.99;
        this.smooth_threshold = 2;
        curve.points = [];
        if (curve.xterm === "x") {
            // For function graphs we can restrict the plot interval
            // to the visible area +plus margin
            bbox = curve.board.getBoundingBox();
            w2 = (bbox[2] - bbox[0]) * 0.3;
            //h2 = (bbox[1] - bbox[3]) * 0.3;
            ta = Math.max(mi, bbox[0] - w2);
            tb = Math.min(ma, bbox[2] + w2);
        } else {
            ta = mi;
            tb = ma;
        }
        pa.setCoordinates(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
            curve.X(ta, suspendUpdate),
            curve.Y(ta, suspendUpdate)
        ], false);
        // The first function calls of X() and Y() are done. We can now
        // switch `suspendUpdate` on. If supported by the functions, this
        // avoids for the rest of the plotting algorithm, evaluation of any
        // parent elements.
        suspendUpdate = true;
        pb.setCoordinates(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
            curve.X(tb, suspendUpdate),
            curve.Y(tb, suspendUpdate)
        ], false);
        // Find start and end points of the visible area (plus a certain margin)
        ret_arr = this._findStartPoint(curve, pa.scrCoords, ta, pb.scrCoords, tb);
        pa.setCoordinates(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_SCREEN, ret_arr[0], false);
        ta = ret_arr[1];
        ret_arr = this._findStartPoint(curve, pb.scrCoords, tb, pa.scrCoords, ta);
        pb.setCoordinates(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_SCREEN, ret_arr[0], false);
        tb = ret_arr[1];
        // Save the visible area.
        // This can be used in Curve.hasPoint().
        this._visibleArea = [
            ta,
            tb
        ];
        // Start recursive plotting algorithm
        a = pa.copy("scrCoords");
        b = pb.copy("scrCoords");
        pa._t = ta;
        curve.points.push(pa);
        this._lastScrCrds = pa.copy("scrCoords"); // Used in _insertPoint
        this._lastUsrCrds = pa.copy("usrCoords"); // Used in _insertPoint
        this._plotNonRecursive(curve, a, ta, b, tb, depth);
        pb._t = tb;
        curve.points.push(pb);
        curve.numberPoints = curve.points.length;
        // console.timeEnd("plot");
        // console.log("number of points:", this.numberPoints);
        return curve;
    },
    //----------------------------------------------------------------------
    // Plot algorithm v4
    //----------------------------------------------------------------------
    /**
     * TODO
     * @param {Array} vec
     * @param {Number} le
     * @param {Number} level
     * @returns Object
     * @private
     */ _criticalInterval: function(vec, le, level) {
        var i, j, le1, med, sgn, sgnChange, isGroup = false, abs_vec, last = -Infinity, very_small = false, smooth = false, group = 0, groups = [], types = [], positions = [];
        abs_vec = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$statistics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].abs(vec);
        med = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$statistics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].median(abs_vec);
        if (med < 1.0e-7) {
            med = 1.0e-7;
            very_small = true;
        } else {
            med *= this.criticalThreshold;
        }
        //console.log("Median", med);
        for(i = 0; i < le; i++){
            // Start a group if not yet done and
            // add position to group
            if (abs_vec[i] > med /*&& abs_vec[i] > 0.01*/ ) {
                positions.push({
                    i: i,
                    v: vec[i],
                    group: group
                });
                last = i;
                if (!isGroup) {
                    isGroup = true;
                }
            } else {
                if (isGroup && i > last + 4) {
                    // End the group
                    if (positions.length > 0) {
                        groups.push(positions.slice(0));
                    }
                    positions = [];
                    isGroup = false;
                    group++;
                }
            }
        }
        if (isGroup) {
            if (positions.length > 1) {
                groups.push(positions.slice(0));
            }
        }
        if (very_small && groups.length === 0) {
            smooth = true;
        }
        // Decide if there is a singular critical point
        // or if a whole interval is problematic.
        // The latter is the case if the differences have many sign changes.
        for(j = 0; j < groups.length; j++){
            types[j] = "point";
            le1 = groups[j].length;
            if (le1 < 64) {
                continue;
            }
            sgnChange = 0;
            sgn = Math.sign(groups[j][0].v);
            for(i = 1; i < le1; i++){
                if (Math.sign(groups[j][i].v) !== sgn) {
                    sgnChange++;
                    sgn = Math.sign(groups[j][i].v);
                }
            }
            if (sgnChange * 6 > le1) {
                types[j] = "interval";
            }
        }
        return {
            smooth: smooth,
            groups: groups,
            types: types
        };
    },
    Component: function() {
        this.left_isNaN = false;
        this.right_isNaN = false;
        this.left_t = null;
        this.right_t = null;
        this.t_values = [];
        this.x_values = [];
        this.y_values = [];
        this.len = 0;
    },
    findComponents: function(curve, mi, ma, steps) {
        var i, t, h, x, y, components = [], comp, comp_nr = 0, cnt = 0, cntNaNs = 0, comp_started = false, suspended = false;
        h = (ma - mi) / steps;
        components[comp_nr] = new this.Component();
        comp = components[comp_nr];
        for(i = 0, t = mi; i <= steps; i++, t += h){
            x = curve.X(t, suspended);
            y = curve.Y(t, suspended);
            if (isNaN(x) || isNaN(y)) {
                cntNaNs++;
                // Wait for - at least - two consecutive NaNs
                // This avoids starting a new component if
                // the function value has infinity as intermediate value.
                if (cntNaNs > 1 && comp_started) {
                    // Finalize a component
                    comp.right_isNaN = true;
                    comp.right_t = t - h;
                    comp.len = cnt;
                    // Prepare a new component
                    comp_started = false;
                    comp_nr++;
                    components[comp_nr] = new this.Component();
                    comp = components[comp_nr];
                    cntNaNs = 0;
                }
            } else {
                // Now there is a non-NaN entry.
                if (!comp_started) {
                    // Start the component
                    comp_started = true;
                    cnt = 0;
                    if (cntNaNs > 0) {
                        comp.left_t = t - h;
                        comp.left_isNaN = true;
                    }
                }
                cntNaNs = 0;
                // Add the value to the component
                comp.t_values[cnt] = t;
                comp.x_values[cnt] = x;
                comp.y_values[cnt] = y;
                cnt++;
            }
            if (i === 0) {
                suspended = true;
            }
        }
        if (comp_started) {
            comp.len = cnt;
        } else {
            components.pop();
        }
        return components;
    },
    getPointType: function(curve, pos, t_approx, t_values, x_table, y_table, len) {
        var x_values = x_table[0], y_values = y_table[0], full_len = t_values.length, result = {
            idx: pos,
            t: t_approx,
            x: x_values[pos],
            y: y_values[pos],
            type: "other"
        };
        if (pos < 5) {
            result.type = "borderleft";
            result.idx = 0;
            result.t = t_values[0];
            result.x = x_values[0];
            result.y = y_values[0];
            // console.log('Border left', result.t);
            return result;
        }
        if (pos > len - 6) {
            result.type = "borderright";
            result.idx = full_len - 1;
            result.t = t_values[full_len - 1];
            result.x = x_values[full_len - 1];
            result.y = y_values[full_len - 1];
            // console.log('Border right', result.t, full_len - 1);
            return result;
        }
        return result;
    },
    newtonApprox: function(idx, t, h, level, table) {
        var i, s = 0.0;
        for(i = level; i > 0; i--){
            s = (s + table[i][idx]) * (t - (i - 1) * h) / i;
        }
        return s + table[0][idx];
    },
    // Thiele's interpolation formula,
    // https://en.wikipedia.org/wiki/Thiele%27s_interpolation_formula
    // unused
    thiele: function(t, recip, t_values, idx, degree) {
        var i, v = 0.0;
        for(i = degree; i > 1; i--){
            v = (t - t_values[idx + i]) / (recip[i][idx + 1] - recip[i - 2][idx + 1] + v);
        }
        return recip[0][idx + 1] + (t - t_values[idx + 1]) / (recip[1][idx + 1] + v);
    },
    differenceMethodExperiments: function(component, curve) {
        var i, level, le, up, t_values = component.t_values, x_values = component.x_values, y_values = component.y_values, x_diffs = [], y_diffs = [], x_slopes = [], y_slopes = [], x_table = [], y_table = [], x_recip = [], y_recip = [], h, numerator, // x_med, y_med,
        foundCriticalPoint = 0, pos, ma, j, v, groups, criticalPoints = [];
        h = t_values[1] - t_values[0];
        x_table.push([]);
        y_table.push([]);
        x_recip.push([]);
        y_recip.push([]);
        le = y_values.length;
        for(i = 0; i < le; i++){
            x_table[0][i] = x_values[i];
            y_table[0][i] = y_values[i];
            x_recip[0][i] = x_values[i];
            y_recip[0][i] = y_values[i];
        }
        x_table.push([]);
        y_table.push([]);
        x_recip.push([]);
        y_recip.push([]);
        numerator = h;
        le = y_values.length - 1;
        for(i = 0; i < le; i++){
            x_diffs[i] = x_values[i + 1] - x_values[i];
            y_diffs[i] = y_values[i + 1] - y_values[i];
            x_slopes[i] = x_diffs[i];
            y_slopes[i] = y_diffs[i];
            x_table[1][i] = x_diffs[i];
            y_table[1][i] = y_diffs[i];
            x_recip[1][i] = numerator / x_diffs[i];
            y_recip[1][i] = numerator / y_diffs[i];
        }
        le--;
        up = Math.min(8, y_values.length - 1);
        for(level = 1; level < up; level++){
            x_table.push([]);
            y_table.push([]);
            x_recip.push([]);
            y_recip.push([]);
            numerator *= h;
            for(i = 0; i < le; i++){
                x_diffs[i] = x_diffs[i + 1] - x_diffs[i];
                y_diffs[i] = y_diffs[i + 1] - y_diffs[i];
                x_table[level + 1][i] = x_diffs[i];
                y_table[level + 1][i] = y_diffs[i];
                x_recip[level + 1][i] = numerator / (x_recip[level][i + 1] - x_recip[level][i]) + x_recip[level - 1][i + 1];
                y_recip[level + 1][i] = numerator / (y_recip[level][i + 1] - y_recip[level][i]) + y_recip[level - 1][i + 1];
            }
            // if (level == 1) {
            //     console.log("bends level=", level, y_diffs.toString());
            // }
            // Store point location which may be centered around
            // critical points.
            // If the level is suitable, step out of the loop.
            groups = this._criticalPoints(y_diffs, le, level);
            if (groups === false) {
                // Its seems, the degree of the polynomial is equal to level
                console.log("Polynomial of degree", level);
                groups = [];
                break;
            }
            if (groups.length > 0) {
                foundCriticalPoint++;
                if (foundCriticalPoint > 1 && level % 2 === 0) {
                    break;
                }
            }
            le--;
        }
        // console.log("Last diffs", y_diffs, "level", level);
        // Analyze the groups which have been found.
        for(i = 0; i < groups.length; i++){
            // console.log("Group", i, groups[i])
            // Identify the maximum difference, i.e. the center of the "problem"
            ma = -Infinity;
            for(j = 0; j < groups[i].length; j++){
                v = Math.abs(groups[i][j].v);
                if (v > ma) {
                    ma = v;
                    pos = j;
                }
            }
            pos = Math.floor(groups[i][pos].i + level / 2);
            // Analyze the critical point
            criticalPoints.push(this.getPointType(curve, pos, t_values, x_values, y_values, x_slopes, y_slopes, le + 1));
        }
        return [
            criticalPoints,
            x_table,
            y_table,
            x_recip,
            y_recip
        ];
    },
    getCenterOfCriticalInterval: function(group, degree, t_values) {
        var ma, j, pos, v, num = 0.0, den = 0.0, h = t_values[1] - t_values[0], pos_mean, range = [];
        // Identify the maximum difference, i.e. the center of the "problem"
        // If there are several equal maxima, store the positions
        // in the array range and determine the center of the array.
        ma = -Infinity;
        range = [];
        for(j = 0; j < group.length; j++){
            v = Math.abs(group[j].v);
            if (v > ma) {
                range = [
                    j
                ];
                ma = v;
                pos = j;
            } else if (ma === v) {
                range.push(j);
            }
        }
        if (range.length > 0) {
            pos_mean = range.reduce(function(total, val) {
                return total + val;
            }, 0) / range.length;
            pos = Math.floor(pos_mean);
            pos_mean += group[0].i;
        }
        if (ma < Infinity) {
            for(j = 0; j < group.length; j++){
                num += Math.abs(group[j].v) * group[j].i;
                den += Math.abs(group[j].v);
            }
            pos_mean = num / den;
        }
        pos_mean += degree / 2;
        return [
            group[pos].i + degree / 2,
            pos_mean,
            t_values[Math.floor(pos_mean)] + h * (pos_mean - Math.floor(pos_mean))
        ];
    },
    differenceMethod: function(component, curve) {
        var i, level, le, up, t_values = component.t_values, x_values = component.x_values, y_values = component.y_values, x_table = [], y_table = [], foundCriticalPoint = 0, degree_x = -1, degree_y = -1, pos, res, res_x, res_y, t_approx, groups = [], types, criticalPoints = [];
        le = y_values.length;
        // x_table.push([]);
        // y_table.push([]);
        // for (i = 0; i < le; i++) {
        //     x_table[0][i] = x_values[i];
        //     y_table[0][i] = y_values[i];
        // }
        x_table.push(new Float64Array(x_values));
        y_table.push(new Float64Array(y_values));
        le--;
        up = Math.min(12, le);
        for(level = 0; level < up; level++){
            // Old style method:
            // x_table.push([]);
            // y_table.push([]);
            // for (i = 0; i < le; i++) {
            //     x_table[level + 1][i] = x_table[level][i + 1] - x_table[level][i];
            //     y_table[level + 1][i] = y_table[level][i + 1] - y_table[level][i];
            // }
            // New method:
            x_table.push(new Float64Array(le));
            y_table.push(new Float64Array(le));
            x_table[level + 1] = x_table[level].map(function(v, idx, arr) {
                return arr[idx + 1] - v;
            });
            y_table[level + 1] = y_table[level].map(function(v, idx, arr) {
                return arr[idx + 1] - v;
            });
            // Store point location which may be centered around critical points.
            // If the level is suitable, step out of the loop.
            res_y = this._criticalInterval(y_table[level + 1], le, level);
            if (res_y.smooth === true) {
                // Its seems, the degree of the polynomial is equal to level
                // If the values in level + 1 are zero, it might be a polynomial of degree level.
                // Seems to work numerically stable until degree 6.
                degree_y = level;
                groups = [];
            }
            res_x = this._criticalInterval(x_table[level + 1], le, level);
            if (degree_x === -1 && res_x.smooth === true) {
                // Its seems, the degree of the polynomial is equal to level
                // If the values in level + 1 are zero, it might be a polynomial of degree level.
                // Seems to work numerically stable until degree 6.
                degree_x = level;
            }
            if (degree_y >= 0) {
                break;
            }
            if (res_y.groups.length > 0) {
                foundCriticalPoint++;
                if (foundCriticalPoint > 2 && (level + 1) % 2 === 0) {
                    groups = res_y.groups;
                    types = res_y.types;
                    break;
                }
            }
            le--;
        }
        // console.log("Last diffs", y_table[Math.min(level + 1, up)], "level", level + 1);
        // Analyze the groups which have been found.
        for(i = 0; i < groups.length; i++){
            if (types[i] === "interval") {
                continue;
            }
            // console.log("Group", i, groups[i], types[i], level + 1)
            res = this.getCenterOfCriticalInterval(groups[i], level + 1, t_values);
            pos = res_y[0];
            pos = Math.floor(res[1]);
            t_approx = res[2];
            // console.log("Critical points:", groups, res, pos)
            // Analyze the type of the critical point
            // Result is of type 'borderleft', borderright', 'other'
            criticalPoints.push(this.getPointType(curve, pos, t_approx, t_values, x_table, y_table, le + 1));
        }
        // if (level === up) {
        //     console.log("No convergence!");
        // } else {
        //     console.log("Convergence level", level);
        // }
        return [
            criticalPoints,
            x_table,
            y_table,
            degree_x,
            degree_y
        ];
    },
    _insertPoint_v4: function(curve, crds, t, doLog) {
        var p, prev = null, x, y, near = 0.8;
        if (curve.points.length > 0) {
            prev = curve.points[curve.points.length - 1].scrCoords;
        }
        // Add regular point
        p = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, crds, curve.board);
        if (prev !== null) {
            x = p.scrCoords[1] - prev[1];
            y = p.scrCoords[2] - prev[2];
            if (x * x + y * y < near * near) {
                // Math.abs(p.scrCoords[1] - prev[1]) < near &&
                // Math.abs(p.scrCoords[2] - prev[2]) < near) {
                return;
            }
        }
        p._t = t;
        curve.points.push(p);
    },
    getInterval: function(curve, ta, tb) {
        var t_int, // x_int,
        y_int;
        //console.log('critical point', ta, tb);
        __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$ia$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].disable();
        t_int = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$ia$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Interval(ta, tb);
        curve.board.mathLib = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$ia$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
        curve.board.mathLibJXG = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$ia$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
        // x_int = curve.X(t_int, true);
        y_int = curve.Y(t_int, true);
        curve.board.mathLib = Math;
        curve.board.mathLibJXG = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Math;
        //console.log(x_int, y_int);
        return y_int;
    },
    sign: function(v) {
        if (v < 0) {
            return -1;
        }
        if (v > 0) {
            return 1;
        }
        return 0;
    },
    handleBorder: function(curve, comp, group, x_table, y_table) {
        var idx = group.idx, t, t1, t2, size = 32, y_int, x, y, lo, hi, i, components2, le, h;
        // console.log("HandleBorder at t =", t_approx);
        // console.log("component:", comp)
        // console.log("Group:", group);
        h = comp.t_values[1] - comp.t_values[0];
        if (group.type === "borderleft") {
            t = comp.left_isNaN ? comp.left_t : group.t - h;
            t1 = t;
            t2 = t1 + h;
        } else if (group.type === "borderright") {
            t = comp.right_isNaN ? comp.right_t : group.t + h;
            t2 = t;
            t1 = t2 - h;
        } else {
            console.log("No bordercase!!!");
        }
        components2 = this.findComponents(curve, t1, t2, size);
        if (components2.length === 0) {
            return;
        }
        if (group.type === "borderleft") {
            t1 = components2[0].left_t;
            t2 = components2[0].t_values[0];
            h = components2[0].t_values[1] - components2[0].t_values[0];
            t1 = t1 === null ? t2 - h : t1;
            t = t1;
            y_int = this.getInterval(curve, t1, t2);
            if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isObject(y_int)) {
                lo = y_int.lo;
                hi = y_int.hi;
                x = curve.X(t, true);
                y = y_table[1][idx] < 0 ? hi : lo;
                this._insertPoint_v4(curve, [
                    1,
                    x,
                    y
                ], t);
            }
        }
        le = components2[0].t_values.length;
        for(i = 0; i < le; i++){
            t = components2[0].t_values[i];
            x = components2[0].x_values[i];
            y = components2[0].y_values[i];
            this._insertPoint_v4(curve, [
                1,
                x,
                y
            ], t);
        }
        if (group.type === "borderright") {
            t1 = components2[0].t_values[le - 1];
            t2 = components2[0].right_t;
            h = components2[0].t_values[1] - components2[0].t_values[0];
            t2 = t2 === null ? t1 + h : t2;
            t = t2;
            y_int = this.getInterval(curve, t1, t2);
            if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isObject(y_int)) {
                lo = y_int.lo;
                hi = y_int.hi;
                x = curve.X(t, true);
                y = y_table[1][idx] > 0 ? hi : lo;
                this._insertPoint_v4(curve, [
                    1,
                    x,
                    y
                ], t);
            }
        }
    },
    _seconditeration_v4: function(curve, comp, group, x_table, y_table) {
        var i, t1, t2, ret, components2, comp2, idx, groups2, g, x_table2, y_table2, start, le;
        // Look at two points, hopefully left and right from the critical point
        t1 = comp.t_values[group.idx - 2];
        t2 = comp.t_values[group.idx + 2];
        components2 = this.findComponents(curve, t1, t2, 64);
        for(idx = 0; idx < components2.length; idx++){
            comp2 = components2[idx];
            ret = this.differenceMethod(comp2, curve);
            groups2 = ret[0];
            x_table2 = ret[1];
            y_table2 = ret[2];
            start = 0;
            for(g = 0; g <= groups2.length; g++){
                if (g === groups2.length) {
                    le = comp2.len;
                } else {
                    le = groups2[g].idx;
                }
                // Insert all uncritical points until next critical point
                for(i = start; i < le; i++){
                    if (!isNaN(comp2.x_values[i]) && !isNaN(comp2.y_values[i])) {
                        this._insertPoint_v4(curve, [
                            1,
                            comp2.x_values[i],
                            comp2.y_values[i]
                        ], comp2.t_values[i]);
                    }
                }
                // Handle next critical point
                if (g < groups2.length) {
                    this.handleSingularity(curve, comp2, groups2[g], x_table2, y_table2);
                    start = groups2[g].idx + 1;
                }
            }
            le = comp2.len;
            if (idx < components2.length - 1) {
                this._insertPoint_v4(curve, [
                    1,
                    NaN,
                    NaN
                ], comp2.right_t);
            }
        }
        return this;
    },
    _recurse_v4: function(curve, t1, t2, x1, y1, x2, y2, level) {
        var tol = 2, t = (t1 + t2) * 0.5, x = curve.X(t, true), y = curve.Y(t, true), dx, dy;
        //console.log("Level", level)
        if (level === 0) {
            this._insertPoint_v4(curve, [
                1,
                NaN,
                NaN
            ], t);
            return;
        }
        // console.log("R", t1, t2)
        dx = (x - x1) * curve.board.unitX;
        dy = (y - y1) * curve.board.unitY;
        // console.log("D1", Math.sqrt(dx * dx + dy * dy))
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].hypot(dx, dy) > tol) {
            this._recurse_v4(curve, t1, t, x1, y1, x, y, level - 1);
        } else {
            this._insertPoint_v4(curve, [
                1,
                x,
                y
            ], t);
        }
        dx = (x - x2) * curve.board.unitX;
        dy = (y - y2) * curve.board.unitY;
        // console.log("D2", Math.sqrt(dx * dx + dy * dy), x-x2, y-y2)
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].hypot(dx, dy) > tol) {
            this._recurse_v4(curve, t, t2, x, y, x2, y2, level - 1);
        } else {
            this._insertPoint_v4(curve, [
                1,
                x,
                y
            ], t);
        }
    },
    handleSingularity: function(curve, comp, group, x_table, y_table) {
        var idx = group.idx, t, t1, t2, y_int, i1, i2, x, // y,
        lo, hi, d_lft, d_rgt, d_thresh = 100, // d1,
        // d2,
        di1 = 5, di2 = 3;
        t = group.t;
        console.log("HandleSingularity at t =", t);
        // console.log(comp.t_values[idx - 1], comp.y_values[idx - 1], comp.t_values[idx + 1], comp.y_values[idx + 1]);
        // console.log(group);
        // Look at two points, hopefully left and right from the critical point
        t1 = comp.t_values[idx - di1];
        t2 = comp.t_values[idx + di1];
        y_int = this.getInterval(curve, t1, t2);
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isObject(y_int)) {
            lo = y_int.lo;
            hi = y_int.hi;
        } else {
            if (y_table[0][idx - 1] < y_table[0][idx + 1]) {
                lo = y_table[0][idx - 1];
                hi = y_table[0][idx + 1];
            } else {
                lo = y_table[0][idx + 1];
                hi = y_table[0][idx - 1];
            }
        }
        x = curve.X(t, true);
        d_lft = (y_table[0][idx - di2] - y_table[0][idx - di1]) / (comp.t_values[idx - di2] - comp.t_values[idx - di1]);
        d_rgt = (y_table[0][idx + di2] - y_table[0][idx + di1]) / (comp.t_values[idx + di2] - comp.t_values[idx + di1]);
        console.log(":::", d_lft, d_rgt);
        //this._insertPoint_v4(curve, [1, NaN, NaN], 0);
        if (d_lft < -d_thresh) {
            // Left branch very steep downwards -> add the minimum
            this._insertPoint_v4(curve, [
                1,
                x,
                lo
            ], t, true);
            if (d_rgt <= d_thresh) {
                // Right branch not very steep upwards -> interrupt the curve
                // I.e. it looks like -infty / (finite or infty) and not like -infty / -infty
                this._insertPoint_v4(curve, [
                    1,
                    NaN,
                    NaN
                ], t);
            }
        } else if (d_lft > d_thresh) {
            // Left branch very steep upwards -> add the maximum
            this._insertPoint_v4(curve, [
                1,
                x,
                hi
            ], t);
            if (d_rgt >= -d_thresh) {
                // Right branch not very steep downwards -> interrupt the curve
                // I.e. it looks like infty / (finite or -infty) and not like infty / infty
                this._insertPoint_v4(curve, [
                    1,
                    NaN,
                    NaN
                ], t);
            }
        } else {
            if (lo === -Infinity) {
                this._insertPoint_v4(curve, [
                    1,
                    x,
                    lo
                ], t, true);
                this._insertPoint_v4(curve, [
                    1,
                    NaN,
                    NaN
                ], t);
            }
            if (hi === Infinity) {
                this._insertPoint_v4(curve, [
                    1,
                    NaN,
                    NaN
                ], t);
                this._insertPoint_v4(curve, [
                    1,
                    x,
                    hi
                ], t, true);
            }
            if (group.t < comp.t_values[idx]) {
                i1 = idx - 1;
                i2 = idx;
            } else {
                i1 = idx;
                i2 = idx + 1;
            }
            t1 = comp.t_values[i1];
            t2 = comp.t_values[i2];
            this._recurse_v4(curve, t1, t2, x_table[0][i1], y_table[0][i1], x_table[0][i2], y_table[0][i2], 10);
        // x = (x_table[0][idx] - x_table[0][idx - 1]) * curve.board.unitX;
        // y = (y_table[0][idx] - y_table[0][idx - 1]) * curve.board.unitY;
        // d1 = Math.sqrt(x * x + y * y);
        // x = (x_table[0][idx + 1] - x_table[0][idx]) * curve.board.unitX;
        // y = (y_table[0][idx + 1] - y_table[0][idx]) * curve.board.unitY;
        // d2 = Math.sqrt(x * x + y * y);
        // console.log("end", t1, t2, t);
        // if (true || (d1 > 2 || d2 > 2)) {
        // console.log(d1, d2, y_table[0][idx])
        //                     // Finite jump
        //                     this._insertPoint_v4(curve, [1, NaN, NaN], t);
        //                 } else {
        //                     if (lo !== -Infinity && hi !== Infinity) {
        //                         // Critical point which can be ignored
        //                         this._insertPoint_v4(curve, [1, x_table[0][idx], y_table[0][idx]], comp.t_values[idx]);
        //                     } else {
        //                         if (lo === -Infinity) {
        //                             this._insertPoint_v4(curve, [1, x, lo], t, true);
        //                             this._insertPoint_v4(curve, [1, NaN, NaN], t);
        //                         }
        //                         if (hi === Infinity) {
        //                             this._insertPoint_v4(curve, [1, NaN, NaN], t);
        //                             this._insertPoint_v4(curve, [1, x, hi], t, true);
        //                         }
        //                     }
        // }
        }
        if (d_rgt < -d_thresh) {
            // Right branch very steep downwards -> add the maximum
            this._insertPoint_v4(curve, [
                1,
                x,
                hi
            ], t);
        } else if (d_rgt > d_thresh) {
            // Right branch very steep upwards -> add the minimum
            this._insertPoint_v4(curve, [
                1,
                x,
                lo
            ], t);
        }
    },
    /**
     * Number of equidistant points where the function is evaluated
     */ steps: 1021,
    /**
     * If the absolute maximum of the set of differences is larger than
     * criticalThreshold * median of these values, it is regarded as critical point.
     * @see JXG.Math.Plot._criticalInterval
     */ criticalThreshold: 1000,
    plot_v4: function(curve, ta, tb, steps) {
        var i, // j,
        le, components, idx, comp, groups, g, start, ret, x_table, y_table, t, t1, t2, // good,
        // bad,
        // x_int,
        y_int, // degree_x,
        // degree_y,
        h = (tb - ta) / steps, Ypl = function(x) {
            return curve.Y(x, true);
        }, Ymi = function(x) {
            return -curve.Y(x, true);
        }, h2 = h * 0.5;
        components = this.findComponents(curve, ta, tb, steps);
        for(idx = 0; idx < components.length; idx++){
            comp = components[idx];
            ret = this.differenceMethod(comp, curve);
            groups = ret[0];
            x_table = ret[1];
            y_table = ret[2];
            // degree_x = ret[3];
            // degree_y = ret[4];
            // if (degree_x >= 0) {
            //     console.log("x polynomial of degree", degree_x);
            // }
            // if (degree_y >= 0) {
            //     console.log("y polynomial of degree", degree_y);
            // }
            if (groups.length === 0 || groups[0].type !== "borderleft") {
                groups.unshift({
                    idx: 0,
                    t: comp.t_values[0],
                    x: comp.x_values[0],
                    y: comp.y_values[0],
                    type: "borderleft"
                });
            }
            if (groups[groups.length - 1].type !== "borderright") {
                le = comp.t_values.length;
                groups.push({
                    idx: le - 1,
                    t: comp.t_values[le - 1],
                    x: comp.x_values[le - 1],
                    y: comp.y_values[le - 1],
                    type: "borderright"
                });
            }
            start = 0;
            for(g = 0; g <= groups.length; g++){
                if (g === groups.length) {
                    le = comp.len;
                } else {
                    le = groups[g].idx - 1;
                }
                // good = 0;
                // bad = 0;
                // Insert all uncritical points until next critical point
                for(i = start; i < le - 2; i++){
                    this._insertPoint_v4(curve, [
                        1,
                        comp.x_values[i],
                        comp.y_values[i]
                    ], comp.t_values[i]);
                    // j = Math.max(0, i - 2);
                    // Add more points in critical intervals
                    if (//degree_y === -1 && // No polynomial
                    i >= start + 3 && i < le - 3 && // Do not do this if too close to a critical point
                    y_table.length > 3 && Math.abs(y_table[2][i]) > 0.2 * Math.abs(y_table[0][i])) {
                        t = comp.t_values[i];
                        h2 = h * 0.25;
                        y_int = this.getInterval(curve, t, t + h);
                        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isObject(y_int)) {
                            if (y_table[2][i] > 0) {
                                this._insertPoint_v4(curve, [
                                    1,
                                    t + h2,
                                    y_int.lo
                                ], t + h2);
                            } else {
                                this._insertPoint_v4(curve, [
                                    1,
                                    t + h - h2,
                                    y_int.hi
                                ], t + h - h2);
                            }
                        } else {
                            t1 = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$numerics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fminbr(Ypl, [
                                t,
                                t + h
                            ]);
                            t2 = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$numerics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fminbr(Ymi, [
                                t,
                                t + h
                            ]);
                            if (t1 < t2) {
                                this._insertPoint_v4(curve, [
                                    1,
                                    curve.X(t1, true),
                                    curve.Y(t1, true)
                                ], t1);
                                this._insertPoint_v4(curve, [
                                    1,
                                    curve.X(t2, true),
                                    curve.Y(t2, true)
                                ], t2);
                            } else {
                                this._insertPoint_v4(curve, [
                                    1,
                                    curve.X(t2, true),
                                    curve.Y(t2, true)
                                ], t2);
                                this._insertPoint_v4(curve, [
                                    1,
                                    curve.X(t1, true),
                                    curve.Y(t1, true)
                                ], t1);
                            }
                        }
                    // bad++;
                    // } else {
                    // good++;
                    }
                }
                // console.log("GOOD", good, "BAD", bad);
                // Handle next critical point
                if (g < groups.length) {
                    //console.log("critical point / interval", groups[g]);
                    i = groups[g].idx;
                    if (groups[g].type === "borderleft" || groups[g].type === "borderright") {
                        this.handleBorder(curve, comp, groups[g], x_table, y_table);
                    } else {
                        this._seconditeration_v4(curve, comp, groups[g], x_table, y_table);
                    }
                    start = groups[g].idx + 1 + 1;
                }
            }
            le = comp.len;
            if (idx < components.length - 1) {
                this._insertPoint_v4(curve, [
                    1,
                    NaN,
                    NaN
                ], comp.right_t);
            }
        }
    },
    /**
     * Updates the data points of a parametric curve, plotVersion 4. This version is used if {@link JXG.Curve#plotVersion} is <tt>4</tt>.
     * @param {JXG.Curve} curve JSXGraph curve element
     * @param {Number} mi Left bound of curve
     * @param {Number} ma Right bound of curve
     * @returns {JXG.Curve} Reference to the curve object.
     */ updateParametricCurve_v4: function(curve, mi, ma) {
        var ta, tb, w2, bbox;
        if (curve.xterm === "x") {
            // For function graphs we can restrict the plot interval
            // to the visible area +plus margin
            bbox = curve.board.getBoundingBox();
            w2 = (bbox[2] - bbox[0]) * 0.3;
            // h2 = (bbox[1] - bbox[3]) * 0.3;
            ta = Math.max(mi, bbox[0] - w2);
            tb = Math.min(ma, bbox[2] + w2);
        } else {
            ta = mi;
            tb = ma;
        }
        curve.points = [];
        //console.log("--------------------");
        this.plot_v4(curve, ta, tb, this.steps);
        curve.numberPoints = curve.points.length;
    //console.log(curve.numberPoints);
    },
    //----------------------------------------------------------------------
    // Plot algorithm alias
    //----------------------------------------------------------------------
    /**
     * Updates the data points of a parametric curve, alias for {@link JXG.Curve#updateParametricCurve_v2}.
     * This is needed for backwards compatibility, if this method has been
     * used directly in an application.
     * @param {JXG.Curve} curve JSXGraph curve element
     * @param {Number} mi Left bound of curve
     * @param {Number} ma Right bound of curve
     * @returns {JXG.Curve} Reference to the curve object.
     *
     * @see JXG.Curve#updateParametricCurve_v2
     */ updateParametricCurve: function(curve, mi, ma) {
        return this.updateParametricCurve_v2(curve, mi, ma);
    }
};
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Plot;
}),
"[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/implicitplot.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Carsten Miller,
        Alfred Wassermann

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */ __turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/utils/type.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/math.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/geometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$numerics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/numerics.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$bqdt$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/bqdt.js [app-client] (ecmascript)");
"use strict";
;
;
;
;
;
/**
 * Plotting of curves which are given implicitly as the set of points solving an equation
 * <i>f(x,y) = 0</i>.
 * <p>
 * The main class initializes a new implicit plot instance.
 * <p>
 * The algorithm should be able to plot most implicit curves as long as the equations
 * are not too complex. We are aware of the paper by Oliver Labs,
 * <a href="https://link.springer.com/chapter/10.1007/978-1-4419-0999-2_6">A List of Challenges for Real Algebraic Plane Curve Visualization Software</a>
 * which contains many equations where this algorithm may fail.
 * For example,  at the time being there is no attempt to detect <i>solitary points</i>.
 * Also, it is always a trade off to find all components of the curve and
 * keep the construction responsive.
 *
 * @name JXG.Math.ImplicitPlot
 * @exports Mat.ImplicitPlot as JXG.Math.ImplicitPlot
 * @param {Array} bbox Bounding box of the area in which solutions of the equation
 * are determined.
 * @param {Object} config Configuration object. Default:
 * <pre>
 *  {
 *      resolution_out: 5,    // Horizontal resolution: distance between vertical lines to search for components
 *      resolution_in: 5,     // Vertical resolution to search for components
 *      max_steps: 1024,      // Max number of points in one call of tracing
 *      alpha_0: 0.05,        // Angle between two successive tangents: smoothness of curve
 *
 *      tol_u0: Mat.eps,      // Tolerance to find starting points for tracing.
 *      tol_newton: 1.0e-7,   // Tolerance for Newton steps.
 *      tol_cusp: 0.05,       // Tolerance for cusp / bifurcation detection
 *      tol_progress: 0.0001, // If two points are closer than this value, we bail out
 *      qdt_box: 0.2,         // half of box size to search in qdt
 *      kappa_0: 0.2,         // Inverse of planned number of Newton steps
 *      delta_0: 0.05,        // Distance of predictor point to curve
 *
 *      h_initial: 0.1,       // Initial stepwidth
 *      h_critical: 0.001,    // If h is below this threshold we bail out
 *      h_max: 1,             // Maximal value of h (user units)
 *      loop_dist: 0.09,      // Allowed distance (multiplied by actual stepwidth) to detect loop
 *      loop_dir: 0.99,       // Should be > 0.95
 *      loop_detection: true, // Use Gosper's loop detector
 *      unitX: 10,            // unitX of board
 *      unitY: 10             // unitX of board
 *   };
 * </pre>
 * @param {function} f function from <b>R</b><sup>2</sup> to <b>R</b>
 * @param {function} [dfx] Optional partial derivative of <i>f</i> with regard to <i>x</i>
 * @param {function} [dfy] Optional partial derivative of <i>f</i> with regard to <i>y</i>
 *
 * @constructor
 * @example
 *     var f = (x, y) => x**3 - 2 * x * y + y**3;
 *     var c = board.create('curve', [[], []], {
 *             strokeWidth: 3,
 *             strokeColor: JXG.palette.red
 *         });
 *
 *     c.updateDataArray = function () {
 *         var bbox = this.board.getBoundingBox(),
 *             ip, cfg,
 *             ret = [],
 *             mgn = 1;
 *
 *         bbox[0] -= mgn;
 *         bbox[1] += mgn;
 *         bbox[2] += mgn;
 *         bbox[3] -= mgn;
 *
 *         cfg = {
 *             resolution_out: 5,
 *             resolution_in: 5,
 *             unitX: this.board.unitX,
 *             unitY: this.board.unitX
 *         };
 *
 *         this.dataX = [];
 *         this.dataY = [];
 *         ip = new JXG.Math.ImplicitPlot(bbox, cfg, f, null, null);
 *         ret = ip.plot();
 *         this.dataX = ret[0];
 *         this.dataY = ret[1];
 *     };
 *     board.update();
 * </pre><div id="JXGf3e8cd82-2b67-4efb-900a-471eb92b3b96" class="jxgbox" style="width: 300px; height: 300px;"></div>
 * <script type="text/javascript">
 *     (function() {
 *         var board = JXG.JSXGraph.initBoard('JXGf3e8cd82-2b67-4efb-900a-471eb92b3b96',
 *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
 *             var f = (x, y) => x**3 - 2 * x * y + y**3;
 *             var c = board.create('curve', [[], []], {
 *                     strokeWidth: 3,
 *                     strokeColor: JXG.palette.red
 *                 });
 *
 *             c.updateDataArray = function () {
 *                 var bbox = this.board.getBoundingBox(),
 *                     ip, cfg,
 *                     ret = [],
 *                     mgn = 1;
 *
 *                 bbox[0] -= mgn;
 *                 bbox[1] += mgn;
 *                 bbox[2] += mgn;
 *                 bbox[3] -= mgn;
 *
 *                 cfg = {
 *                     resolution_out: 5,
 *                     resolution_in: 5,
 *                     unitX: this.board.unitX,
 *                     unitY: this.board.unitX
 *                 };
 *
 *                 this.dataX = [];
 *                 this.dataY = [];
 *
 *                 ip = new JXG.Math.ImplicitPlot(bbox, cfg, f, null, null);
 *                 ret = ip.plot();
 *
 *                 this.dataX = ret[0];
 *                 this.dataY = ret[1];
 *             };
 *             board.update();
 *
 *     })();
 *
 * </script><pre>
 *
 */ __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ImplicitPlot = function(bbox, config, f, dfx, dfy) {
    // Default values
    var cfg_default = {
        resolution_out: 5,
        resolution_in: 5,
        max_steps: 1024,
        alpha_0: 0.05,
        tol_u0: __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps,
        tol_newton: 1.0e-7,
        tol_cusp: 0.05,
        tol_progress: 0.0001,
        qdt_box: 0.2,
        kappa_0: 0.2,
        delta_0: 0.05,
        h_initial: 0.1,
        h_critical: 0.001,
        h_max: 1,
        loop_dist: 0.09,
        loop_dir: 0.99,
        loop_detection: true,
        unitX: 10,
        unitY: 10 // unitX of board
    };
    this.config = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].merge(cfg_default, config);
    this.f = f;
    this.dfx = null;
    this.dfy = null;
    if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isFunction(dfx)) {
        this.dfx = dfx;
    } else {
        this.dfx = function(x, y) {
            var h = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps * __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps;
            return (this.f(x + h, y) - this.f(x - h, y)) * 0.5 / h;
        };
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isFunction(dfy)) {
        this.dfy = dfy;
    } else {
        this.dfy = function(x, y) {
            var h = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps * __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps;
            return (this.f(x, y + h) - this.f(x, y - h)) * 0.5 / h;
        };
    }
    this.bbox = bbox;
    this.qdt = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$bqdt$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](20, 5, bbox);
    this.components = [];
};
__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].extend(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ImplicitPlot.prototype, /** @lends JXG.Math.ImplicitPlot.prototype */ {
    /**
         * Implicit plotting method.
         *
         * @returns {Array} consisting of [dataX, dataY, number_of_components]
         */ plot: function() {
        var doVerticalSearch = true, doHorizontalSearch = true, x, y, mi_x, ma_x, mi_y, ma_y, dataX = [], dataY = [], ret = [], num_components = 0, delta, that = this, fmi_x = function(t) {
            return that.f(x, t);
        }, fma_x = function(t) {
            return -that.f(x, t);
        }, fmi_y = function(t) {
            return that.f(t, y);
        }, fma_y = function(t) {
            return -that.f(t, y);
        };
        // Vertical lines or circular search:
        mi_x = Math.min(this.bbox[0], this.bbox[2]) - __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps;
        ma_x = Math.max(this.bbox[0], this.bbox[2]);
        mi_y = Math.min(this.bbox[1], this.bbox[3]) + __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps;
        ma_y = Math.max(this.bbox[1], this.bbox[3]);
        if ("TURBOPACK compile-time truthy", 1) {
            delta = this.config.resolution_out / this.config.unitX;
            delta *= 1 + __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps;
            // console.log("Outer delta x", delta)
            for(x = mi_x; x < ma_x; x += delta){
                ret = this.searchLine(fmi_x, fma_x, x, [
                    mi_y,
                    ma_y
                ], 'vertical', num_components, dataX, dataY, 20);
                if (ret !== false) {
                    dataX = ret[0];
                    dataY = ret[1];
                    num_components = ret[2];
                }
            }
        }
        if ("TURBOPACK compile-time truthy", 1) {
            delta = this.config.resolution_out / this.config.unitY;
            delta *= 1 + __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps;
            // console.log("Outer delta y", delta)
            for(y = mi_y; y < ma_y; y += delta){
                ret = this.searchLine(fmi_y, fma_y, y, [
                    mi_x,
                    ma_x
                ], 'horizontal', num_components, dataX, dataY, 20);
                if (ret !== false) {
                    dataX = ret[0];
                    dataY = ret[1];
                    num_components = ret[2];
                }
            }
        }
        return [
            dataX,
            dataY,
            num_components
        ];
    },
    /**
         * Recursively search a horizontal or vertical line for points on the
         * fulfilling the given equation.
         *
         * @param {Function} fmi Minimization function
         * @param {Function} fma Maximization function
         * @param {Number} fix Value of the fixed variable
         * @param {Array} interval Search interval of the free variable
         * @param {String} dir 'vertical' or 'horizontal'
         * @param {Number} num_components Number of components before search
         * @param {Array} dataX x-coordinates of points so far
         * @param {Array} dataY y-coordinates of points so far
         * @param {Number} level Recursion level
         * @returns {Array} consisting of [dataX, dataY, number_of_components]-
         * @private
         */ searchLine: function(fmi, fma, fix, interval, dir, num_components, dataX, dataY, level) {
        var t_mi, t_ma, t, ft, mi, ma, tmp, m, is_in, u0, i, le, ret, offset, delta, eps = this.config.tol_u0, DEBUG = false, b = interval[0], e = interval[1];
        t_mi = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$numerics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fminbr(fmi, [
            b,
            e
        ]);
        mi = fmi(t_mi);
        t_ma = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$numerics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fminbr(fma, [
            b,
            e
        ]);
        ma = fmi(t_ma);
        if (mi < eps && ma > -eps) {
            tmp = t_mi;
            t_mi = Math.min(tmp, t_ma);
            t_ma = Math.max(tmp, t_ma);
            t = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$numerics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fzero(fmi, [
                t_mi,
                t_ma
            ]);
            // t = Numerics.chandrupatla(fmi, [t_mi, t_ma]);
            ft = fmi(t);
            if (Math.abs(ft) > Math.max((ma - mi) * __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps, 0.001)) {
                //console.log("searchLine:",  dir, fix, t, "no root " + ft);
                return false;
            // throw new Error("searchLine: no root " + ft);
            }
            if (dir === 'vertical') {
                u0 = [
                    1,
                    fix,
                    t
                ];
                delta = this.config.resolution_in / this.config.unitY;
            // console.log("Inner delta x", delta)
            } else {
                u0 = [
                    1,
                    t,
                    fix
                ];
                delta = this.config.resolution_in / this.config.unitX;
            // console.log("Inner delta y", delta)
            }
            delta *= 1 + __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps;
            is_in = this.curveContainsPoint(u0, dataX, dataY, delta * 2, this.config.qdt_box // 0.5 of box size to search in qdt
            );
            if (is_in) {
                if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                ;
            } else {
                if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                ;
                ret = this.traceComponent(u0, 1);
                if (ret[0].length > 0) {
                    // Add jump in curve
                    if (num_components > 0) {
                        dataX.push(NaN);
                        dataY.push(NaN);
                    }
                    offset = dataX.length;
                    le = ret[0].length;
                    for(i = 1; i < le; i++){
                        this.qdt.insertItem({
                            xlb: Math.min(ret[0][i - 1], ret[0][i]),
                            xub: Math.max(ret[0][i - 1], ret[0][i]),
                            ylb: Math.min(ret[1][i - 1], ret[1][i]),
                            yub: Math.max(ret[1][i - 1], ret[1][i]),
                            idx1: offset + i - 1,
                            idx2: offset + i,
                            comp: num_components
                        });
                    }
                    num_components++;
                    __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].concat(dataX, ret[0]);
                    __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].concat(dataY, ret[1]);
                }
            }
            m = t - delta * 0.01;
            if (m - b > delta && level > 0) {
                ret = this.searchLine(fmi, fma, fix, [
                    b,
                    m
                ], dir, num_components, dataX, dataY, level - 1);
                if (ret !== false) {
                    dataX = ret[0];
                    dataY = ret[1];
                    num_components = ret[2];
                }
            }
            m = t + delta * 0.01;
            if (e - m > delta && level > 0) {
                ret = this.searchLine(fmi, fma, fix, [
                    m,
                    e
                ], dir, num_components, dataX, dataY, level - 1);
                if (ret !== false) {
                    dataX = ret[0];
                    dataY = ret[1];
                    num_components = ret[2];
                }
            }
            return [
                dataX,
                dataY,
                num_components
            ];
        }
        return false;
    },
    /**
         * Test if the data points contain a given coordinate, i.e. if the
         * given coordinate is close enough to the polygonal chain
         * through the data points.
         *
         * @param {Array} p Homogenous coordinates [1, x, y] of the coordinate point
         * @param {Array} dataX x-coordinates of points so far
         * @param {Array} dataY y-coordinates of points so far
         * @param {Number} tol Maximal distance of p from the polygonal chain through the data points
         * @param {Number} eps Helper tolerance used for the quadtree
         * @returns Boolean
         */ curveContainsPoint: function(p, dataX, dataY, tol, eps) {
        var i, le, hits, d, x = p[1], y = p[2];
        hits = this.qdt.find([
            x - eps,
            y + eps,
            x + eps,
            y - eps
        ]);
        le = hits.length;
        for(i = 0; i < le; i++){
            d = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].distPointSegment(p, [
                1,
                dataX[hits[i].idx1],
                dataY[hits[i].idx1]
            ], [
                1,
                dataX[hits[i].idx2],
                dataY[hits[i].idx2]
            ]);
            if (d < tol) {
                return true;
            }
        }
        return false;
    },
    /**
         * Starting at an initial point the curve is traced with a Euler-Newton method.
         * After tracing in one direction the algorithm stops if the component is a closed loop.
         * Otherwise, the curved is traced in the opposite direction, starting from
         * the same initial point. Finally, the two components are glued together.
         *
         * @param {Array} u0 Initial point in homogenous coordinates [1, x, y].
         * @returns Array [dataX, dataY] containing a new component.
         * @private
         */ traceComponent: function(u0) {
        var dataX = [], dataY = [], arr = [];
        // Trace in first direction
        // console.log("---- Start tracing forward ---------")
        arr = this.tracing(u0, 1);
        if (arr.length === 0) {
        // console.log("Could not start tracing due to singularity")
        } else {
            // console.log("Trace from", [arr[0][0], arr[1][0]], "to", [arr[0][arr[0].length - 1], arr[1][arr[1].length - 1]],
            //    "num points:", arr[0].length);
            dataX = arr[0];
            dataY = arr[1];
        }
        // Trace in the other direction
        if (!arr[2]) {
            // No loop in the first tracing step,
            // now explore the other direction.
            // console.log("---- Start tracing backward ---------")
            arr = this.tracing(u0, -1);
            if (arr.length === 0) {
            // console.log("Could not start backward tracing due to singularity")
            } else {
                // console.log("Trace backwards from", [arr[0][0], arr[1][0]], "to",
                //     [arr[0][arr[0].length - 1], arr[1][arr[1].length - 1]], "num points:", arr[0].length);
                dataX = arr[0].reverse().concat(dataX.slice(1));
                dataY = arr[1].reverse().concat(dataY.slice(1));
            }
        }
        if (dataX.length > 0 && dataX.length < 6) {
            // Solitary point
            dataX.push(dataX[dataX.length - 1]);
            dataY.push(dataY[dataY.length - 1]);
        }
        return [
            dataX,
            dataY
        ];
    },
    /**
         * Starting at a point <i>u0</i>, this routine traces the curve <i>f(u)=0</i> until
         * a loop is detected, a critical point is reached, the curve leaves the bounding box,
         * or the maximum number of points is reached.
         * <p>
         * The method is a predictor / corrector method consisting of Euler and Newton steps
         * together with step width adaption.
         * <p>
         * The algorithm is an adaption of the algorithm in
         * Eugene L. Allgower, Kurt Georg: <i>Introduction to Numerical Continuation methods.</i>
         *
         * @param {Array} u0 Starting point in homogenous coordinates  [1, x, y].
         * @param {Number} direction 1 or -1
         * @returns Array [pathX, pathY, loop_closed] or []
         * @private
         */ tracing: function(u0, direction) {
        var u = [], ulast = [], len, v = [], v_start = [], w = [], t_u, t_v, t_u_0, tloc, A, grad, nrm, dir, steps = 0, k = 0, loop_closed = false, k0, k1, denom, dist, progress, kappa, delta, alpha, factor, point_added = false, quasi = false, cusp_or_bifurc = false, kappa_0 = this.config.kappa_0, delta_0 = this.config.delta_0, alpha_0 = this.config.alpha_0, h = this.config.h_initial, max_steps = this.config.max_steps, omega = direction, pathX = [], pathY = [], T = [], n, m, i, e;
        u = u0.slice(1);
        pathX.push(u[0]);
        pathY.push(u[1]);
        t_u = this.tangent(u);
        if (t_u === false) {
            // We don't want to start at a singularity.
            // Get out of here and search for another starting point.
            return [];
        }
        A = [
            this.dfx(u[0], u[1]),
            this.dfy(u[0], u[1])
        ];
        do {
            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
            ;
            else {
                t_u = this.tangent(u);
            }
            if (t_u === false) {
                u = v.slice();
                pathX.push(u[0]);
                pathY.push(u[1]);
                break;
            }
            if (pathX.length === 1) {
                // Store first point
                t_u_0 = t_u.slice();
            } else if (pathX.length === 2) {
                T.push(pathX.length - 1); // Put first point into Gosper table T
            } else if (point_added && pathX.length > 2 && !cusp_or_bifurc) {
                // Detect if loop has been closed
                dist = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].distPointSegment([
                    1,
                    u[0],
                    u[1]
                ], [
                    1,
                    pathX[0],
                    pathY[0]
                ], [
                    1,
                    pathX[1],
                    pathY[1]
                ]);
                if (dist < this.config.loop_dist * h && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].innerProduct(t_u, t_u_0, 2) > this.config.loop_dir) {
                    // console.log("Loop detected after", steps, "steps");
                    // console.log("\t", "v", v, "u0:", u0)
                    // console.log("\t", "Dist(v, path0)", dist, config.loop_dist * h)
                    // console.log("\t", "t_u", t_u);
                    // console.log("\t", "inner:", Mat.innerProduct(t_u, t_u_0, 2));
                    // console.log("\t", "h", h);
                    u = u0.slice(1);
                    pathX.push(u[0]);
                    pathY.push(u[1]);
                    loop_closed = true;
                    break;
                }
                // Gosper's loop detector
                if (this.config.loop_detection) {
                    n = pathX.length - 1;
                    // console.log("Check Gosper", n);
                    m = Math.floor(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].log2(n));
                    for(i = 0; i <= m; i++){
                        dist = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].distPointSegment([
                            1,
                            u[0],
                            u[1]
                        ], [
                            1,
                            pathX[T[i] - 1],
                            pathY[T[i] - 1]
                        ], [
                            1,
                            pathX[T[i]],
                            pathY[T[i]]
                        ]);
                        if (dist < this.config.loop_dist * h) {
                            // console.log("!!!!!!!!!!!!!!! GOSPER LOOP CLOSED !!!!", i, n + 1,
                            //     this.config.loop_dist * h
                            // );
                            t_v = this.tangent([
                                pathX[T[i]],
                                pathY[T[i]]
                            ]);
                            if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].innerProduct(t_u, t_v, 2) > this.config.loop_dir) {
                                break;
                            }
                        }
                    }
                    if (i <= m) {
                        loop_closed = true;
                        break;
                    }
                    m = 1;
                    e = 0;
                    for(i = 0; i < 100; i++){
                        if ((n + 1) % m !== 0) {
                            break;
                        }
                        m *= 2;
                        e++;
                    }
                    // console.log("Add at e", e);
                    T[e] = n;
                }
            }
            // Predictor step
            // if (true /*h < 2 * this.config.h_initial*/) {
            // Euler
            // console.log("euler")
            v[0] = u[0] + h * omega * t_u[0];
            v[1] = u[1] + h * omega * t_u[1];
            // } else {
            //     // Heun
            //     // console.log("heun")
            //     v[0] = u[0] + h * omega * t_u[0];
            //     v[1] = u[1] + h * omega * t_u[1];
            //     t_v = this.tangent(v);
            //     v[0] = 0.5 * u[0] + 0.5 * (v[0] + h * omega * t_v[0]);
            //     v[1] = 0.5 * u[1] + 0.5 * (v[1] + h * omega * t_v[1]);
            // }
            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
            ;
            // Corrector step: Newton
            k = 0;
            do {
                if ("TURBOPACK compile-time falsy", 0) {
                    grad = A;
                } else {
                    grad = [
                        this.dfx(v[0], v[1]),
                        this.dfy(v[0], v[1])
                    ];
                }
                // Compute w = v - A(v) * f(v),
                // grad: row vector and A(v) is the Moore-Penrose inverse:
                // grad^T * (grad * grad^T)^(-1)
                denom = grad[0] * grad[0] + grad[1] * grad[1];
                nrm = this.f(v[0], v[1]) / denom;
                w[0] = v[0] - grad[0] * nrm;
                w[1] = v[1] - grad[1] * nrm;
                if (k === 0) {
                    k0 = Math.abs(nrm) * Math.sqrt(denom);
                } else if (k === 1) {
                    k1 = Math.abs(nrm) * Math.sqrt(denom);
                }
                v[0] = w[0];
                v[1] = w[1];
                k++;
            }while (k < 20 && Math.abs(this.f(v[0], v[1])) > this.config.tol_newton)
            delta = k0;
            if (k > 1) {
                kappa = k1 / k0;
            } else {
                kappa = 0.0;
            }
            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
            ;
            else {
                t_v = this.tangent(v);
            }
            dir = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].innerProduct(t_u, t_v, 2);
            dir = Math.max(-1, Math.min(1, dir));
            alpha = Math.acos(dir);
            // Look for simple bifurcation points and cusps
            cusp_or_bifurc = false;
            progress = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].distance(u, v, 2);
            if (progress < this.config.tol_progress) {
                u = v.slice();
                pathX.push(u[0]);
                pathY.push(u[1]);
                break;
            } else if (dir < 0.0) {
                if (h > this.config.h_critical) {
                // console.log("Critical point at [", u[0].toFixed(4), u[1].toFixed(4), "], v: [", v[0].toFixed(4), v[1].toFixed(4), "], but large  h:", h);
                } else {
                    cusp_or_bifurc = true;
                    if (this.isBifurcation(u, this.config.tol_cusp)) {
                        // console.log(steps, "bifurcation point between", u, "and", v, ":", dir, "h", h, "alpha", alpha);
                        // A = [dfx(v[0], v[1]), dfy(v[0], v[1])];
                        omega *= -1;
                        // If there is a bifurcation point, we
                        // ignore the angle alpha for subsequent step length
                        // adaption. Because then we might be able to
                        // "jump over the critical point"
                        alpha = 0;
                    } else {
                        // Cusp or something more weird
                        u = v.slice();
                        pathX.push(u[0]);
                        pathY.push(u[1]);
                        break;
                    }
                }
            }
            // Adapt stepwidth
            if (!cusp_or_bifurc) {
                factor = Math.max(Math.sqrt(kappa / kappa_0), Math.sqrt(delta / delta_0), alpha / alpha_0);
                if (isNaN(factor)) {
                    factor = 1;
                }
                factor = Math.max(Math.min(factor, 2), 0.5);
                h /= factor;
                h = Math.min(this.config.h_max, h);
                if (factor >= 2) {
                    steps++;
                    if (steps >= 3 * max_steps) {
                        break;
                    }
                    point_added = false;
                    continue;
                }
            }
            u = v.slice();
            pathX.push(u[0]);
            pathY.push(u[1]);
            point_added = true;
            steps++;
        }while (steps < max_steps && u[0] >= this.bbox[0] && u[1] <= this.bbox[1] && u[0] <= this.bbox[2] && u[1] >= this.bbox[3])
        // Clipping to bounding box, last may be outside, interpolate between second last und last point
        len = pathX.length;
        ulast = [
            pathX[len - 2],
            pathY[len - 2]
        ];
        // If u[0] is outside x-interval in bounding box, interpolate to the box.
        if (u[0] < this.bbox[0]) {
            if (u[0] !== ulast[0]) {
                tloc = (this.bbox[0] - ulast[0]) / (u[0] - ulast[0]);
                if (u[1] !== ulast[1]) {
                    u[1] = ulast[1] + tloc * (u[1] - ulast[1]);
                }
            }
            u[0] = this.bbox[0];
        }
        if (u[0] > this.bbox[2]) {
            if (u[0] !== ulast[0]) {
                tloc = (this.bbox[2] - ulast[0]) / (u[0] - ulast[0]);
                if (u[1] !== ulast[1]) {
                    u[1] = ulast[1] + tloc * (u[1] - ulast[1]);
                }
            }
            u[0] = this.bbox[2];
        }
        // If u[1] is outside y-interval in bounding box, interpolate to the box.
        if (u[1] < this.bbox[3]) {
            if (u[1] !== ulast[1]) {
                tloc = (this.bbox[3] - ulast[1]) / (u[1] - ulast[1]);
                if (u[0] !== ulast[0]) {
                    u[0] = ulast[0] + tloc * (u[0] - ulast[0]);
                }
            }
            u[1] = this.bbox[3];
        }
        if (u[1] > this.bbox[1]) {
            if (u[1] !== ulast[1]) {
                tloc = (this.bbox[1] - ulast[1]) / (u[1] - ulast[1]);
                if (u[0] !== ulast[0]) {
                    u[0] = ulast[0] + tloc * (u[0] - ulast[0]);
                }
            }
            u[1] = this.bbox[1];
        }
        // Update last point
        pathX[len - 1] = u[0];
        pathY[len - 1] = u[1];
        // if (!loop_closed) {
        //     console.log("No loop", steps);
        // } else {
        //     console.log("Loop", steps);
        // }
        return [
            pathX,
            pathY,
            loop_closed
        ];
    },
    /**
         * If both eigenvalues of the Hessian are different from zero, the critical point at u
         * is a simple bifurcation point.
         *
         * @param {Array} u Critical point [x, y]
         * @param {Number} tol Tolerance of the eigenvalues to be zero.
         * @returns Boolean True if the point is a simple bifurcation point.
         * @private
         */ isBifurcation: function(u, tol) {
        // Former experiments:
        // If the Hessian has exactly one zero eigenvalue,
        // we claim that there is a cusp.
        // Otherwise, we decide that there is a bifurcation point.
        // In the latter case, if both eigenvalues are zero
        // this is a somewhat crude decision.
        //
        var h = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps * __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps * 100, x, y, a, b, c, d, ad, lbda1, lbda2, dis;
        x = u[0];
        y = u[1];
        a = 0.5 * (this.dfx(x + h, y) - this.dfx(x - h, y)) / h;
        b = 0.5 * (this.dfx(x, y + h) - this.dfx(x, y - h)) / h;
        c = 0.5 * (this.dfy(x + h, y) - this.dfy(x - h, y)) / h;
        d = 0.5 * (this.dfy(x, y + h) - this.dfy(x, y - h)) / h;
        // c = b
        ad = a + d;
        dis = ad * ad - 4 * (a * d - b * c);
        lbda1 = 0.5 * (ad + Math.sqrt(dis));
        lbda2 = 0.5 * (ad - Math.sqrt(dis));
        // console.log(a, b, c, d)
        // console.log("Eigenvals u:", lbda1, lbda2, tol);
        if (Math.abs(lbda1) > tol && Math.abs(lbda2) > tol) {
            // if (lbda1 * lbda2 > 0) {
            //     console.log("Seems to be isolated singularity at", u);
            // }
            return true;
        }
        return false;
    },
    /**
         * Search in an arc around a critical point for a further point on the curve.
         * Unused for the moment.
         *
         * @param {Array} u Critical point [x, y]
         * @param {Array} t_u Tangent at u
         * @param {Number} r Radius
         * @param {Number} omega angle
         * @returns {Array} Coordinates [x, y] of a new point.
         * @private
         */ handleCriticalPoint: function(u, t_u, r, omega) {
        var a = Math.atan2(omega * t_u[1], omega * t_u[0]), // s = a - 0.75 * Math.PI,
        // e = a + 0.75 * Math.PI,
        f_circ = function(t) {
            var x = u[0] + r * Math.cos(t), y = u[1] + r * Math.sin(t);
            return this.f(x, y);
        }, x, y, t0;
        // t0 = Numerics.fzero(f_circ, [s, e]);
        t0 = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$numerics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].root(f_circ, a);
        x = u[0] + r * Math.cos(t0);
        y = u[1] + r * Math.sin(t0);
        // console.log("\t", "result", x, y, "f", f(x, y));
        return [
            x,
            y
        ];
    },
    /**
         * Quasi-Newton update of the Moore-Penrose inverse.
         * See (7.2.3) in Allgower, Georg.
         *
         * @param {Array} A
         * @param {Array} u0
         * @param {Array} u1
         * @returns Array
         * @private
         */ updateA: function(A, u0, u1) {
        var s = [
            u1[0] - u0[0],
            u1[1] - u0[1]
        ], y = this.f(u1[0], u1[1]) - this.f(u0[0], u0[1]), nom, denom;
        denom = s[0] * s[0] + s[1] * s[1];
        nom = y - (A[0] * s[0] + A[1] * s[1]);
        nom /= denom;
        A[0] += nom * s[0];
        A[1] += nom * s[1];
        return A;
    },
    /**
         * Approximate tangent (of norm 1) with Quasi-Newton method
         * @param {Array} A
         * @returns Array
         * @private
         */ tangent_A: function(A) {
        var t = [
            -A[1],
            A[0]
        ], nrm = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].norm(t, 2);
        if (nrm < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
        // console.log("Approx. Singularity", t, "is zero", nrm);
        }
        return [
            t[0] / nrm,
            t[1] / nrm
        ];
    },
    /**
         * Tangent of norm 1 at point u.
         * @param {Array} u Point [x, y]
         * @returns Array
         * @private
         */ tangent: function(u) {
        var t = [
            -this.dfy(u[0], u[1]),
            this.dfx(u[0], u[1])
        ], nrm = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].norm(t, 2);
        if (nrm < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps * __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
            // console.log("Singularity", t, "is zero", "at", u, ":", nrm);
            return false;
        }
        return [
            t[0] / nrm,
            t[1] / nrm
        ];
    }
});
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ImplicitPlot;
}),
"[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/metapost.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.


    Metapost/Hobby curves, see e.g. https://bosker.wordpress.com/2013/11/13/beyond-bezier-curves/

    * Ported to Python for the project PyX. Copyright (C) 2011 Michael Schindler <m-schindler@users.sourceforge.net>
    * Ported to javascript from the PyX implementation (https://pyx-project.org/) by Vlad-X.
    * Adapted to JSXGraph and some code changes by Alfred Wassermann 2020.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

    Internal functions of MetaPost
    This file re-implements some of the functionality of MetaPost
    (https://tug.org/metapost.html). MetaPost was developed by John D. Hobby and
    others. The code of Metapost is in the public domain, which we understand as
    an implicit permission to reuse the code here (see the comment at
    https://www.gnu.org/licenses/license-list.html)

    This file is based on the MetaPost version distributed by TeXLive:
    svn://tug.org/texlive/trunk/Build/source/texk/web2c/mplibdir revision 22737 #
    (2011-05-31)
*/ /*global JXG: true, define: true*/ /*jslint nomen: true, plusplus: true*/ /**
 * @fileoverview In this file the namespace Math.Metapost is defined which holds algorithms translated from Metapost
 * by D.E. Knuth and J.D. Hobby.
 */ __turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/utils/type.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/math.js [app-client] (ecmascript)");
;
;
/**
 * The JXG.Math.Metapost namespace holds algorithms translated from Metapost
 * by D.E. Knuth and J.D. Hobby.
 *
 * @name JXG.Math.Metapost
 * @exports Mat.Metapost as JXG.Math.Metapost
 * @namespace
 */ __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Metapost = {
    MP_ENDPOINT: 0,
    MP_EXPLICIT: 1,
    MP_GIVEN: 2,
    MP_CURL: 3,
    MP_OPEN: 4,
    MP_END_CYCLE: 5,
    UNITY: 1.0,
    // two: 2,
    // fraction_half: 0.5,
    FRACTION_ONE: 1.0,
    FRACTION_THREE: 3.0,
    ONE_EIGHTY_DEG: Math.PI,
    THREE_SIXTY_DEG: 2 * Math.PI,
    // EPSILON: 1e-5,
    EPS_SQ: 1e-5 * 1e-5,
    /**
     * @private
     */ make_choices: function(knots) {
        var dely, h, k, delx, n, q, p, s, cosine, t, sine, delta_x, delta_y, delta, psi, endless = true;
        p = knots[0];
        do {
            if (!p) {
                break;
            }
            q = p.next;
            // Join two identical knots by setting the control points to the same
            // coordinates.
            // MP 291
            if (p.rtype > this.MP_EXPLICIT && (p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y) < this.EPS_SQ) {
                p.rtype = this.MP_EXPLICIT;
                if (p.ltype === this.MP_OPEN) {
                    p.ltype = this.MP_CURL;
                    p.set_left_curl(this.UNITY);
                }
                q.ltype = this.MP_EXPLICIT;
                if (q.rtype === this.MP_OPEN) {
                    q.rtype = this.MP_CURL;
                    q.set_right_curl(this.UNITY);
                }
                p.rx = p.x;
                q.lx = p.x;
                p.ry = p.y;
                q.ly = p.y;
            }
            p = q;
        }while (p !== knots[0])
        // Find the first breakpoint, h, on the path
        // MP 292
        h = knots[0];
        while(endless){
            if (h.ltype !== this.MP_OPEN || h.rtype !== this.MP_OPEN) {
                break;
            }
            h = h.next;
            if (h === knots[0]) {
                h.ltype = this.MP_END_CYCLE;
                break;
            }
        }
        p = h;
        while(endless){
            if (!p) {
                break;
            }
            // Fill in the control points between p and the next breakpoint,
            // then advance p to that breakpoint
            // MP 299
            q = p.next;
            if (p.rtype >= this.MP_GIVEN) {
                while(q.ltype === this.MP_OPEN && q.rtype === this.MP_OPEN){
                    q = q.next;
                }
                // Calculate the turning angles psi_ k and the distances d_{k,k+1};
                // set n to the length of the path
                // MP 302
                k = 0;
                s = p;
                n = knots.length;
                delta_x = [];
                delta_y = [];
                delta = [];
                psi = [
                    null
                ];
                // tuple([]) = tuple([[], [], [], [null]]);
                while(endless){
                    t = s.next;
                    // None;
                    delta_x.push(t.x - s.x);
                    delta_y.push(t.y - s.y);
                    delta.push(this.mp_pyth_add(delta_x[k], delta_y[k]));
                    if (k > 0) {
                        sine = delta_y[k - 1] / delta[k - 1];
                        cosine = delta_x[k - 1] / delta[k - 1];
                        psi.push(Math.atan2(delta_y[k] * cosine - delta_x[k] * sine, delta_x[k] * cosine + delta_y[k] * sine));
                    }
                    k++;
                    s = t;
                    if (s === q) {
                        n = k;
                    }
                    if (k >= n && s.ltype !== this.MP_END_CYCLE) {
                        break;
                    }
                }
                if (k === n) {
                    psi.push(0);
                } else {
                    psi.push(psi[1]);
                }
                // Remove open types at the breakpoints
                // MP 303
                if (q.ltype === this.MP_OPEN) {
                    delx = q.rx - q.x;
                    dely = q.ry - q.y;
                    if (delx * delx + dely * dely < this.EPS_SQ) {
                        q.ltype = this.MP_CURL;
                        q.set_left_curl(this.UNITY);
                    } else {
                        q.ltype = this.MP_GIVEN;
                        q.set_left_given(Math.atan2(dely, delx));
                    }
                }
                if (p.rtype === this.MP_OPEN && p.ltype === this.MP_EXPLICIT) {
                    delx = p.x - p.lx;
                    dely = p.y - p.ly;
                    if (delx * delx + dely * dely < this.EPS_SQ) {
                        p.rtype = this.MP_CURL;
                        p.set_right_curl(this.UNITY);
                    } else {
                        p.rtype = this.MP_GIVEN;
                        p.set_right_given(Math.atan2(dely, delx));
                    }
                }
                this.mp_solve_choices(p, q, n, delta_x, delta_y, delta, psi);
            } else if (p.rtype === this.MP_ENDPOINT) {
                // MP 294
                p.rx = p.x;
                p.ry = p.y;
                q.lx = q.x;
                q.ly = q.y;
            }
            p = q;
            if (p === h) {
                break;
            }
        }
    },
    /**
     * Implements solve_choices form metapost
     * MP 305
     * @private
     */ mp_solve_choices: function(p, q, n, delta_x, delta_y, delta, psi) {
        var aa, acc, vv, bb, ldelta, ee, k, s, ww, uu, lt, r, t, ff, theta, rt, dd, cc, ct_st, ct, st, cf_sf, cf, sf, i, k_idx, endless = true;
        ldelta = delta.length + 1;
        uu = new Array(ldelta);
        ww = new Array(ldelta);
        vv = new Array(ldelta);
        theta = new Array(ldelta);
        for(i = 0; i < ldelta; i++){
            theta[i] = vv[i] = ww[i] = uu[i] = 0;
        }
        k = 0;
        s = p;
        r = 0;
        while(endless){
            t = s.next;
            if (k === 0) {
                // MP 306
                if (s.rtype === this.MP_GIVEN) {
                    // MP 314
                    if (t.ltype === this.MP_GIVEN) {
                        aa = Math.atan2(delta_y[0], delta_x[0]);
                        ct_st = this.mp_n_sin_cos(p.right_given() - aa);
                        ct = ct_st[0];
                        st = ct_st[1];
                        cf_sf = this.mp_n_sin_cos(q.left_given() - aa);
                        cf = cf_sf[0];
                        sf = cf_sf[1];
                        this.mp_set_controls(p, q, delta_x[0], delta_y[0], st, ct, -sf, cf);
                        return;
                    }
                    vv[0] = s.right_given() - Math.atan2(delta_y[0], delta_x[0]);
                    vv[0] = this.reduce_angle(vv[0]);
                    uu[0] = 0;
                    ww[0] = 0;
                } else if (s.rtype === this.MP_CURL) {
                    // MP 315
                    if (t.ltype === this.MP_CURL) {
                        p.rtype = this.MP_EXPLICIT;
                        q.ltype = this.MP_EXPLICIT;
                        lt = Math.abs(q.left_tension());
                        rt = Math.abs(p.right_tension());
                        ff = this.UNITY / (3.0 * rt);
                        p.rx = p.x + delta_x[0] * ff;
                        p.ry = p.y + delta_y[0] * ff;
                        ff = this.UNITY / (3.0 * lt);
                        q.lx = q.x - delta_x[0] * ff;
                        q.ly = q.y - delta_y[0] * ff;
                        return;
                    }
                    cc = s.right_curl();
                    lt = Math.abs(t.left_tension());
                    rt = Math.abs(s.right_tension());
                    uu[0] = this.mp_curl_ratio(cc, rt, lt);
                    vv[0] = -psi[1] * uu[0];
                    ww[0] = 0;
                } else {
                    if (s.rtype === this.MP_OPEN) {
                        uu[0] = 0;
                        vv[0] = 0;
                        ww[0] = this.FRACTION_ONE;
                    }
                }
            } else {
                if (s.ltype === this.MP_END_CYCLE || s.ltype === this.MP_OPEN) {
                    // MP 308
                    aa = this.UNITY / (3.0 * Math.abs(r.right_tension()) - this.UNITY);
                    dd = delta[k] * (this.FRACTION_THREE - this.UNITY / Math.abs(r.right_tension()));
                    bb = this.UNITY / (3 * Math.abs(t.left_tension()) - this.UNITY);
                    ee = delta[k - 1] * (this.FRACTION_THREE - this.UNITY / Math.abs(t.left_tension()));
                    cc = this.FRACTION_ONE - uu[k - 1] * aa;
                    dd = dd * cc;
                    lt = Math.abs(s.left_tension());
                    rt = Math.abs(s.right_tension());
                    if (lt < rt) {
                        dd *= Math.pow(lt / rt, 2);
                    } else {
                        if (lt > rt) {
                            ee *= Math.pow(rt / lt, 2);
                        }
                    }
                    ff = ee / (ee + dd);
                    uu[k] = ff * bb;
                    acc = -psi[k + 1] * uu[k];
                    if (r.rtype === this.MP_CURL) {
                        ww[k] = 0;
                        vv[k] = acc - psi[1] * (this.FRACTION_ONE - ff);
                    } else {
                        ff = (this.FRACTION_ONE - ff) / cc;
                        acc = acc - psi[k] * ff;
                        ff = ff * aa;
                        vv[k] = acc - vv[k - 1] * ff;
                        ww[k] = -ww[k - 1] * ff;
                    }
                    if (s.ltype === this.MP_END_CYCLE) {
                        aa = 0;
                        bb = this.FRACTION_ONE;
                        while(endless){
                            k -= 1;
                            if (k === 0) {
                                k = n;
                            }
                            aa = vv[k] - aa * uu[k];
                            bb = ww[k] - bb * uu[k];
                            if (k === n) {
                                break;
                            }
                        }
                        aa = aa / (this.FRACTION_ONE - bb);
                        theta[n] = aa;
                        vv[0] = aa;
                        // k_val = range(1, n);
                        // for (k_idx in k_val) {
                        // k = k_val[k_idx];
                        for(k_idx = 1; k_idx < n; k_idx++){
                            vv[k_idx] = vv[k_idx] + aa * ww[k_idx];
                        }
                        break;
                    }
                } else {
                    if (s.ltype === this.MP_CURL) {
                        cc = s.left_curl();
                        lt = Math.abs(s.left_tension());
                        rt = Math.abs(r.right_tension());
                        ff = this.mp_curl_ratio(cc, lt, rt);
                        theta[n] = -(vv[n - 1] * ff) / (this.FRACTION_ONE - ff * uu[n - 1]);
                        break;
                    }
                    if (s.ltype === this.MP_GIVEN) {
                        theta[n] = s.left_given() - Math.atan2(delta_y[n - 1], delta_x[n - 1]);
                        theta[n] = this.reduce_angle(theta[n]);
                        break;
                    }
                }
            }
            r = s;
            s = t;
            k += 1;
        }
        // MP 318
        for(k = n - 1; k > -1; k--){
            theta[k] = vv[k] - theta[k + 1] * uu[k];
        }
        s = p;
        k = 0;
        while(endless){
            t = s.next;
            ct_st = this.mp_n_sin_cos(theta[k]);
            ct = ct_st[0];
            st = ct_st[1];
            cf_sf = this.mp_n_sin_cos(-psi[k + 1] - theta[k + 1]);
            cf = cf_sf[0];
            sf = cf_sf[1];
            this.mp_set_controls(s, t, delta_x[k], delta_y[k], st, ct, sf, cf);
            k++;
            s = t;
            if (k === n) {
                break;
            }
        }
    },
    /**
     * @private
     */ mp_n_sin_cos: function(z) {
        return [
            Math.cos(z),
            Math.sin(z)
        ];
    },
    /**
     * @private
     */ mp_set_controls: function(p, q, delta_x, delta_y, st, ct, sf, cf) {
        var rt, ss, lt, sine, rr;
        lt = Math.abs(q.left_tension());
        rt = Math.abs(p.right_tension());
        rr = this.mp_velocity(st, ct, sf, cf, rt);
        ss = this.mp_velocity(sf, cf, st, ct, lt);
        // console.log('lt rt rr ss', lt, rt, rr, ss);
        if (p.right_tension() < 0 || q.left_tension() < 0) {
            if (st >= 0 && sf >= 0 || st <= 0 && sf <= 0) {
                sine = Math.abs(st) * cf + Math.abs(sf) * ct;
                if (sine > 0) {
                    sine *= 1.00024414062;
                    if (p.right_tension() < 0) {
                        if (this.mp_ab_vs_cd(Math.abs(sf), this.FRACTION_ONE, rr, sine) < 0) {
                            rr = Math.abs(sf) / sine;
                        }
                    }
                    if (q.left_tension() < 0) {
                        if (this.mp_ab_vs_cd(Math.abs(st), this.FRACTION_ONE, ss, sine) < 0) {
                            ss = Math.abs(st) / sine;
                        }
                    }
                }
            }
        }
        p.rx = p.x + (delta_x * ct - delta_y * st) * rr;
        p.ry = p.y + (delta_y * ct + delta_x * st) * rr;
        q.lx = q.x - (delta_x * cf + delta_y * sf) * ss;
        q.ly = q.y - (delta_y * cf - delta_x * sf) * ss;
        p.rtype = this.MP_EXPLICIT;
        q.ltype = this.MP_EXPLICIT;
    },
    /**
     * @private
     */ mp_pyth_add: function(a, b) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].hypot(a, b);
    },
    /**
     *
     * @private
     */ mp_curl_ratio: function(gamma, a_tension, b_tension) {
        var alpha = 1.0 / a_tension, beta = 1.0 / b_tension;
        return Math.min(4.0, ((3.0 - alpha) * alpha * alpha * gamma + beta * beta * beta) / (alpha * alpha * alpha * gamma + (3.0 - beta) * beta * beta));
    },
    /**
     * @private
     */ mp_ab_vs_cd: function(a, b, c, d) {
        if (a * b === c * d) {
            return 0;
        }
        if (a * b > c * d) {
            return 1;
        }
        return -1;
    },
    /**
     * @private
     */ mp_velocity: function(st, ct, sf, cf, t) {
        return Math.min(4.0, (2.0 + Math.sqrt(2) * (st - sf / 16.0) * (sf - st / 16.0) * (ct - cf)) / (1.5 * t * (2 + (Math.sqrt(5) - 1) * ct + (3 - Math.sqrt(5)) * cf)));
    },
    /**
     * @private
     * @param {Number} A
     */ reduce_angle: function(A) {
        if (Math.abs(A) > this.ONE_EIGHTY_DEG) {
            if (A > 0) {
                A -= this.THREE_SIXTY_DEG;
            } else {
                A += this.THREE_SIXTY_DEG;
            }
        }
        return A;
    },
    /**
     *
     * @private
     * @param {Array} p
     * @param {Number} tension
     * @param {Boolean} cycle
     */ makeknots: function(p, tension) {
        var i, len, knots = [];
        len = p.length;
        for(i = 0; i < len; i++){
            knots.push({
                x: p[i][0],
                y: p[i][1],
                ltype: this.MP_OPEN,
                rtype: this.MP_OPEN,
                lx: false,
                rx: false,
                ly: tension,
                ry: tension,
                left_curl: function() {
                    return this.lx || 0;
                },
                right_curl: function() {
                    return this.rx || 0;
                },
                left_tension: function() {
                    return this.ly || 1;
                },
                right_tension: function() {
                    return this.ry || 1;
                },
                set_right_curl: function(v) {
                    this.rx = v || 0;
                },
                set_left_curl: function(v) {
                    this.lx = v || 0;
                }
            });
        }
        len = knots.length;
        for(i = 0; i < len; i++){
            knots[i].next = knots[i + 1] || knots[i];
            knots[i].set_right_given = knots[i].set_right_curl;
            knots[i].set_left_given = knots[i].set_left_curl;
            knots[i].right_given = knots[i].right_curl;
            knots[i].left_given = knots[i].left_curl;
        }
        knots[len - 1].next = knots[0];
        return knots;
    },
    /**
     *
     * @param {Array} point_list
     * @param {Object} controls
     *
     * @returns {Array}
     */ curve: function(point_list, controls) {
        var knots, len, i, ii, val, obj, isClosed = false, x = [], y = [];
        controls = controls || {
            tension: 1,
            direction: {},
            curl: {},
            isClosed: false
        };
        // Change default tension
        val = 1;
        if (controls.hasOwnProperty('tension')) {
            val = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evaluate(controls.tension);
        }
        knots = this.makeknots(point_list, val);
        len = knots.length;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(controls.isClosed) && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evaluate(controls.isClosed)) {
            isClosed = true;
        }
        if (!isClosed) {
            knots[0].ltype = this.MP_ENDPOINT;
            knots[0].rtype = this.MP_CURL;
            knots[len - 1].rtype = this.MP_ENDPOINT;
            knots[len - 1].ltype = this.MP_CURL;
        }
        // for (i in controls.direction) {
        //     if (controls.direction.hasOwnProperty(i)) {
        //         val = Type.evaluate(controls.direction[i]);
        //         if (Type.isArray(val)) {
        //             if (val[0] !== false) {
        //                 knots[i].lx = (val[0] * Math.PI) / 180;
        //                 knots[i].ltype = this.MP_GIVEN;
        //             }
        //             if (val[1] !== false) {
        //                 knots[i].rx = (val[1] * Math.PI) / 180;
        //                 knots[i].rtype = this.MP_GIVEN;
        //             }
        //         } else {
        //             knots[i].lx = (val * Math.PI) / 180;
        //             knots[i].rx = (val * Math.PI) / 180;
        //             knots[i].ltype = knots[i].rtype = this.MP_GIVEN;
        //         }
        //     }
        // }
        // for (i in controls.curl) {
        //     if (controls.curl.hasOwnProperty(i)) {
        //         val = Type.evaluate(controls.curl[i]);
        //         if (parseInt(i, 10) === 0) {
        //             knots[i].rtype = this.MP_CURL;
        //             knots[i].set_right_curl(val);
        //         } else if (parseInt(i, 10) === len - 1) {
        //             knots[i].ltype = this.MP_CURL;
        //             knots[i].set_left_curl(val);
        //         }
        //     }
        // }
        // Set individual point control values
        for(ii in controls){
            if (controls.hasOwnProperty(ii)) {
                i = parseInt(ii, 10);
                if (isNaN(i) || i < 0 || i >= len) {
                    continue;
                }
                // Handle individual curl
                obj = controls[i];
                if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(obj.type)) {
                    switch(obj.type){
                        case 'curl':
                            val = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evaluate(obj.curl);
                            if (i === 0) {
                                knots[i].rtype = this.MP_CURL;
                                knots[i].set_right_curl(val);
                            } else if (i === len - 1) {
                                knots[i].ltype = this.MP_CURL;
                                knots[i].set_left_curl(val);
                            } else {
                                knots[i].ltype = this.MP_CURL;
                                knots[i].rtype = this.MP_CURL;
                                knots[i].lx = val;
                                knots[i].rx = val;
                            }
                            break;
                    }
                }
                // Handle individual directions
                if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(obj.direction)) {
                    val = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evaluate(obj.direction);
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(val)) {
                        if (val[0] !== false) {
                            knots[i].lx = val[0] * Math.PI / 180;
                            knots[i].ltype = this.MP_GIVEN;
                        }
                        if (val[1] !== false) {
                            knots[i].rx = val[1] * Math.PI / 180;
                            knots[i].rtype = this.MP_GIVEN;
                        }
                    } else {
                        knots[i].lx = val * Math.PI / 180;
                        knots[i].rx = val * Math.PI / 180;
                        knots[i].ltype = knots[i].rtype = this.MP_GIVEN;
                    }
                }
                // Handle individual tension
                if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(obj.tension)) {
                    val = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evaluate(obj.tension);
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(val)) {
                        if (val[0] !== false) {
                            knots[i].ly = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evaluate(val[0]);
                        }
                        if (val[1] !== false) {
                            knots[i].ry = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].evaluate(val[1]);
                        }
                    } else {
                        knots[i].ly = val;
                        knots[i].ry = val;
                    }
                }
            }
        }
        // Generate ths Bezier curve
        this.make_choices(knots);
        // Return the coordinates
        for(i = 0; i < len - 1; i++){
            x.push(knots[i].x);
            x.push(knots[i].rx);
            x.push(knots[i + 1].lx);
            y.push(knots[i].y);
            y.push(knots[i].ry);
            y.push(knots[i + 1].ly);
        }
        x.push(knots[len - 1].x);
        y.push(knots[len - 1].y);
        if (isClosed) {
            x.push(knots[len - 1].rx);
            y.push(knots[len - 1].ry);
            x.push(knots[0].lx);
            y.push(knots[0].ly);
            x.push(knots[0].x);
            y.push(knots[0].y);
        }
        return [
            x,
            y
        ];
    }
};
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Metapost;
}),
"[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/clip.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Alfred Wassermann

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */ /*global JXG: true, define: true*/ /*jslint nomen: true, plusplus: true*/ /**
 * @fileoverview This file contains the Math.Clip namespace for clipping and computing boolean operations
 * on polygons and curves
 *
 * // TODO:
 * * Check if input polygons are closed. If not, handle this case.
 */ // import JXG from "../jxg.js";
__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/base/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/base/coords.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/math.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/geometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/utils/type.js [app-client] (ecmascript)");
;
;
;
;
;
/**
 * Math.Clip namespace definition. This namespace contains algorithms for Boolean operations on paths, i.e.
 * intersection, union and difference of paths. Base is the Greiner-Hormann algorithm.
 * @name JXG.Math.Clip
 * @exports Mat.Clip as JXG.Math.Clip
 * @namespace
 */ __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Clip = {
    _isSeparator: function(node) {
        return isNaN(node.coords.usrCoords[1]) && isNaN(node.coords.usrCoords[2]);
    },
    /**
     * Add pointers to an array S such that it is a circular doubly-linked list.
     *
     * @private
     * @param  {Array} S Array
     * @return {Array} return containing the starter indices of each component.
     */ makeDoublyLinkedList: function(S) {
        var i, first = null, components = [], le = S.length;
        if (le > 0) {
            for(i = 0; i < le; i++){
                // S[i]._next = S[(i + 1) % le];
                // S[i]._prev = S[(le + i - 1) % le];
                // If S[i] is component separator we proceed with the next node.
                if (this._isSeparator(S[i])) {
                    S[i]._next = S[(i + 1) % le];
                    S[i]._prev = S[(le + i - 1) % le];
                    continue;
                }
                // Now we know that S[i] is a path component
                if (first === null) {
                    // Start the component if it is not yet started.
                    first = i;
                    components.push(first);
                }
                if (this._isSeparator(S[(i + 1) % le]) || i === le - 1) {
                    // If the next node is a component separator or if the node is the last node,
                    // then we close the loop
                    S[i]._next = S[first];
                    S[first]._prev = S[i];
                    S[i]._end = true;
                    first = null;
                } else {
                    // Here, we are not at the end of component
                    S[i]._next = S[(i + 1) % le];
                    S[first]._prev = S[i];
                }
                if (!this._isSeparator(S[(le + i - 1) % le])) {
                    S[i]._prev = S[(le + i - 1) % le];
                }
            }
        }
        return components;
    },
    /**
     * JavaScript object containing the intersection of two paths. Every intersection point is on one path, but
     * comes with a neighbour point having the same coordinates and being on the other path.
     *
     * The intersection point is inserted into the doubly linked list of the path.
     *
     * @private
     * @param  {JXG.Coords} coords JSXGraph Coords object containing the coordinates of the intersection
     * @param  {Number} i        Number of the segment of the subject path (first path) containing the intersection.
     * @param  {Number} alpha    The intersection is a p_1 + alpha*(p_2 - p_1), where p_1 and p_2 are the end points
     *      of the i-th segment.
     * @param  {Array} path      Pointer to the path containing the intersection point
     * @param  {String} pathname Name of the path: 'S' or 'C'.
     */ Vertex: function(coords, i, alpha, path, pathname, type) {
        this.pos = i;
        this.intersection = true;
        this.coords = coords;
        this.elementClass = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_CLASS_POINT;
        this.data = {
            alpha: alpha,
            path: path,
            pathname: pathname,
            done: false,
            type: type,
            idx: 0
        };
        // Set after initialisation
        this.neighbour = null;
        this.entry_exit = false;
    },
    _addToList: function(list, coords, pos) {
        var len = list.length, eps = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps * __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps;
        if (len > 0 && Math.abs(list[len - 1].coords.usrCoords[0] - coords.usrCoords[0]) < eps && Math.abs(list[len - 1].coords.usrCoords[1] - coords.usrCoords[1]) < eps && Math.abs(list[len - 1].coords.usrCoords[2] - coords.usrCoords[2]) < eps) {
            // Skip point
            return;
        }
        list.push({
            pos: pos,
            intersection: false,
            coords: coords,
            elementClass: __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_CLASS_POINT
        });
    },
    /**
     * Sort the intersection points into their path.
     * @private
     * @param  {Array} P_crossings Array of arrays. Each array contains the intersections of the path
     *      with one segment of the other path.
     * @return {Array}  Array of intersection points ordered by first occurrence in the path.
     */ sortIntersections: function(P_crossings) {
        var i, j, P, Q, last, next_node, P_intersect = [], P_le = P_crossings.length;
        for(i = 0; i < P_le; i++){
            P_crossings[i].sort(function(a, b) {
                return a.data.alpha > b.data.alpha ? 1 : -1;
            });
            if (P_crossings[i].length > 0) {
                // console.log("Crossings", P_crossings[i])
                last = P_crossings[i].length - 1;
                P = P_crossings[i][0];
                //console.log("SORT", P.coords.usrCoords)
                Q = P.data.path[P.pos];
                next_node = Q._next; // Store the next "normal" node
                if (i === P_le - 1) {
                    Q._end = false;
                }
                if (P.data.alpha === 0.0 && P.data.type === "T") {
                    // console.log("SKIP", P.coords.usrCoords, P.data.type, P.neighbour.data.type);
                    Q.intersection = true;
                    Q.data = P.data;
                    Q.neighbour = P.neighbour;
                    Q.neighbour.neighbour = Q;
                    Q.entry_exit = false;
                    P_crossings[i][0] = Q;
                } else {
                    // Insert the first intersection point
                    P._prev = Q;
                    P._prev._next = P;
                }
                // Insert the other intersection points, but the last
                for(j = 1; j <= last; j++){
                    P = P_crossings[i][j];
                    P._prev = P_crossings[i][j - 1];
                    P._prev._next = P;
                }
                // Link last intersection point to the next node
                P = P_crossings[i][last];
                P._next = next_node;
                P._next._prev = P;
                if (i === P_le - 1) {
                    P._end = true;
                //console.log("END", P._end, P.coords.usrCoords, P._prev.coords.usrCoords, P._next.coords.usrCoords);
                }
                P_intersect = P_intersect.concat(P_crossings[i]);
            }
        }
        return P_intersect;
    },
    _inbetween: function(q, p1, p2) {
        var alpha, eps = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps * __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps, px = p2[1] - p1[1], py = p2[2] - p1[2], qx = q[1] - p1[1], qy = q[2] - p1[2];
        if (px === 0 && py === 0 && qx === 0 && qy === 0) {
            // All three points are equal
            return true;
        }
        if (Math.abs(qx) < eps && Math.abs(px) < eps) {
            alpha = qy / py;
        } else {
            alpha = qx / px;
        }
        if (Math.abs(alpha) < eps) {
            alpha = 0.0;
        }
        return alpha;
    },
    _print_array: function(arr) {
        var i, end;
        for(i = 0; i < arr.length; i++){
            //console.log(i, arr[i].coords.usrCoords,  arr[i].data.type);
            try {
                end = "";
                if (arr[i]._end) {
                    end = " end";
                }
                console.log(i, arr[i].coords.usrCoords, arr[i].data.type, "\t", "prev", arr[i]._prev.coords.usrCoords, "next", arr[i]._next.coords.usrCoords + end);
            } catch (e) {
                console.log(i, arr[i].coords.usrCoords);
            }
        }
    },
    _print_list: function(P) {
        var cnt = 0, alpha;
        while(cnt < 100){
            if (P.data) {
                alpha = P.data.alpha;
            } else {
                alpha = "-";
            }
            console.log("\t", P.coords.usrCoords, "\n\t\tis:", P.intersection, "end:", P._end, alpha, "\n\t\t-:", P._prev.coords.usrCoords, "\n\t\t+:", P._next.coords.usrCoords, "\n\t\tn:", P.intersection ? P.neighbour.coords.usrCoords : "-");
            if (P._end) {
                break;
            }
            P = P._next;
            cnt++;
        }
    },
    _noOverlap: function(p1, p2, q1, q2) {
        var k, eps = Math.sqrt(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps), minp, maxp, minq, maxq, no_overlap = false;
        for(k = 0; k < 3; k++){
            minp = Math.min(p1[k], p2[k]);
            maxp = Math.max(p1[k], p2[k]);
            minq = Math.min(q1[k], q2[k]);
            maxq = Math.max(q1[k], q2[k]);
            if (maxp < minq - eps || minp > maxq + eps) {
                no_overlap = true;
                break;
            }
        }
        return no_overlap;
    },
    /**
     * Find all intersections between two paths.
     * @private
     * @param  {Array} S     Subject path
     * @param  {Array} C     Clip path
     * @param  {JXG.Board} board JSXGraph board object. It is needed to convert between
     * user coordinates and screen coordinates.
     * @return {Array}  Array containing two arrays. The first array contains the intersection vertices
     * of the subject path and the second array contains the intersection vertices of the clip path.
     * @see JXG.Math.Clip.Vertex
     */ findIntersections: function(S, C, board) {
        var res = [], eps = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps * 100, i, j, crds, S_le = S.length, C_le = C.length, Si, Si1, Cj, Cj1, d1, d2, alpha, type, IS, IC, S_intersect = [], C_intersect = [], S_crossings = [], C_crossings = [], hasMultCompsS = false, hasMultCompsC = false, DEBUG = false;
        for(j = 0; j < C_le; j++){
            C_crossings.push([]);
        }
        // Run through the subject path.
        for(i = 0; i < S_le; i++){
            S_crossings.push([]);
            // Test if S[i] or its successor is a path separator.
            // If yes, we know that the path consists of multiple components.
            // We immediately jump to the next segment.
            if (this._isSeparator(S[i]) || this._isSeparator(S[(i + 1) % S_le])) {
                hasMultCompsS = true;
                continue;
            }
            // If the path consists of multiple components then there is
            // no path-closing segment between the last node and the first
            // node. In this case we can leave the loop now.
            if (hasMultCompsS && i === S_le - 1) {
                break;
            }
            Si = S[i].coords.usrCoords;
            Si1 = S[(i + 1) % S_le].coords.usrCoords;
            // Run through the clip path.
            for(j = 0; j < C_le; j++){
                // Test if C[j] or its successor is a path separator.
                // If yes, we know that the path consists of multiple components.
                // We immediately jump to the next segment.
                if (this._isSeparator(C[j]) || this._isSeparator(C[(j + 1) % C_le])) {
                    hasMultCompsC = true;
                    continue;
                }
                // If the path consists of multiple components then there is
                // no path-closing segment between the last node and the first
                // node. In this case we can leave the loop now.
                if (hasMultCompsC && j === C_le - 1) {
                    break;
                }
                // Test if bounding boxes of the two curve segments overlap
                // If not, the expensive intersection test can be skipped.
                Cj = C[j].coords.usrCoords;
                Cj1 = C[(j + 1) % C_le].coords.usrCoords;
                if (this._noOverlap(Si, Si1, Cj, Cj1)) {
                    continue;
                }
                // Intersection test
                res = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].meetSegmentSegment(Si, Si1, Cj, Cj1);
                d1 = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].distance(Si, Si1, 3);
                d2 = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].distance(Cj, Cj1, 3);
                // Found an intersection point
                if (// "Regular" intersection
                res[1] * d1 > -eps && res[1] < 1 - eps / d1 && res[2] * d2 > -eps && res[2] < 1 - eps / d2 || res[1] === Infinity && res[2] === Infinity && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].norm(res[0], 3) < eps) {
                    crds = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, res[0], board);
                    type = "X";
                    // Handle degenerated cases
                    if (Math.abs(res[1]) * d1 < eps || Math.abs(res[2]) * d2 < eps) {
                        // Crossing / bouncing at vertex or
                        // end of delayed crossing / bouncing
                        type = "T";
                        if (Math.abs(res[1]) * d1 < eps) {
                            res[1] = 0;
                        }
                        if (Math.abs(res[2]) * d2 < eps) {
                            res[2] = 0;
                        }
                        if (res[1] === 0) {
                            crds = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, Si, board);
                        } else {
                            crds = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, Cj, board);
                        }
                        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                        ;
                    } else if (res[1] === Infinity && res[2] === Infinity && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].norm(res[0], 3) < eps) {
                        // console.log(C_intersect);
                        // Collinear segments
                        // Here, there might be two intersection points to be added
                        alpha = this._inbetween(Si, Cj, Cj1);
                        if (DEBUG) {
                        // console.log("alpha Si", alpha, Si);
                        // console.log(j, Cj)
                        // console.log((j + 1) % C_le, Cj1)
                        }
                        if (alpha >= 0 && alpha < 1) {
                            type = "T";
                            crds = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, Si, board);
                            res[1] = 0;
                            res[2] = alpha;
                            IS = new this.Vertex(crds, i, res[1], S, "S", type);
                            IC = new this.Vertex(crds, j, res[2], C, "C", type);
                            IS.neighbour = IC;
                            IC.neighbour = IS;
                            S_crossings[i].push(IS);
                            C_crossings[j].push(IC);
                            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                            ;
                        }
                        alpha = this._inbetween(Cj, Si, Si1);
                        if (DEBUG) {
                        // console.log("alpha Cj", alpha, Si, Geometry.distance(Si, Cj, 3));
                        }
                        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].distance(Si, Cj, 3) > eps && alpha >= 0 && alpha < 1) {
                            type = "T";
                            crds = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, Cj, board);
                            res[1] = alpha;
                            res[2] = 0;
                            IS = new this.Vertex(crds, i, res[1], S, "S", type);
                            IC = new this.Vertex(crds, j, res[2], C, "C", type);
                            IS.neighbour = IC;
                            IC.neighbour = IS;
                            S_crossings[i].push(IS);
                            C_crossings[j].push(IC);
                            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                            ;
                        }
                        continue;
                    }
                    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                    ;
                    IS = new this.Vertex(crds, i, res[1], S, "S", type);
                    IC = new this.Vertex(crds, j, res[2], C, "C", type);
                    IS.neighbour = IC;
                    IC.neighbour = IS;
                    S_crossings[i].push(IS);
                    C_crossings[j].push(IC);
                }
            }
        }
        // For both paths, sort their intersection points
        S_intersect = this.sortIntersections(S_crossings);
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        for(i = 0; i < S_intersect.length; i++){
            S_intersect[i].data.idx = i;
            S_intersect[i].neighbour.data.idx = i;
        }
        C_intersect = this.sortIntersections(C_crossings);
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        return [
            S_intersect,
            C_intersect
        ];
    },
    /**
     * It is testedd if the point q lies to the left or right
     * of the poylgonal chain [p1, p2, p3].
     * @param {Array} q User coords array
     * @param {Array} p1 User coords array
     * @param {Array} p2 User coords array
     * @param {Array} p3 User coords array
     * @returns string 'left' or 'right'
     * @private
     */ _getPosition: function(q, p1, p2, p3) {
        var s1 = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].det3p(q, p1, p2), s2 = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].det3p(q, p2, p3), s3 = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].det3p(p1, p2, p3);
        // Left turn
        if (s3 >= 0) {
            if (s1 >= 0 && s2 >= 0) {
                return "left";
            }
            return "right";
        }
        // Right turn
        if (s1 >= 0 || s2 >= 0) {
            return "left";
        }
        return "right";
    },
    /**
     * Determine the delayed status of degenerated intersection points.
     * It is of the form
     *   ['on|left|right', 'on|left|right']
     * <p>
     * If all four determinants are zero, we add random noise to the point.
     *
     * @param {JXG.Math.Clip.Vertex} P Start of path
     * @private
     * @see JXG.Math.Clip.markEntryExit
     * @see JXG.Math.Clip._handleIntersectionChains
     */ _classifyDegenerateIntersections: function(P) {
        var Pp, Pm, Qp, Qm, Q, side, cnt, tmp, det, oppositeDir, s1, s2, s3, s4, endless = true, DEBUG = false;
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        det = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].det3p;
        cnt = 0;
        P._tours = 0;
        while(endless){
            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
            ;
            if (P.intersection && P.data.type === "T") {
                // Handle the degenerate cases
                // Decide if they are (delayed) bouncing or crossing intersections
                Pp = P._next.coords.usrCoords; // P+
                Pm = P._prev.coords.usrCoords; // P-
                // If the intersection point is degenerated and
                // equal to the start and end of one component,
                // then there will be two adjacent points with
                // the same coordinate.
                // In that case, we proceed to the next node.
                if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].distance(P.coords.usrCoords, Pp, 3) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
                    Pp = P._next._next.coords.usrCoords;
                }
                if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].distance(P.coords.usrCoords, Pm, 3) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
                    Pm = P._prev._prev.coords.usrCoords;
                }
                Q = P.neighbour;
                Qm = Q._prev.coords.usrCoords; // Q-
                Qp = Q._next.coords.usrCoords; // Q+
                if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].distance(Q.coords.usrCoords, Qp, 3) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
                    Qp = Q._next._next.coords.usrCoords;
                }
                if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].distance(Q.coords.usrCoords, Qm, 3) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
                    Qm = Q._prev._prev.coords.usrCoords;
                }
                if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                ;
                s1 = det(P.coords.usrCoords, Pm, Qm);
                s2 = det(P.coords.usrCoords, Pp, Qp);
                s3 = det(P.coords.usrCoords, Pm, Qp);
                s4 = det(P.coords.usrCoords, Pp, Qm);
                if (s1 === 0 && s2 === 0 && s3 === 0 && s4 === 0) {
                    P.coords.usrCoords[1] *= 1 + Math.random() * __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps;
                    P.coords.usrCoords[2] *= 1 + Math.random() * __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps;
                    Q.coords.usrCoords[1] = P.coords.usrCoords[1];
                    Q.coords.usrCoords[2] = P.coords.usrCoords[2];
                    s1 = det(P.coords.usrCoords, Pm, Qm);
                    s2 = det(P.coords.usrCoords, Pp, Qp);
                    s3 = det(P.coords.usrCoords, Pm, Qp);
                    s4 = det(P.coords.usrCoords, Pp, Qm);
                    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                    ;
                }
                oppositeDir = false;
                if (s1 === 0) {
                    // Q-, Q=P, P- on straight line
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].affineRatio(P.coords.usrCoords, Pm, Qm) < 0) {
                        oppositeDir = true;
                    }
                } else if (s2 === 0) {
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].affineRatio(P.coords.usrCoords, Pp, Qp) < 0) {
                        oppositeDir = true;
                    }
                } else if (s3 === 0) {
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].affineRatio(P.coords.usrCoords, Pm, Qp) > 0) {
                        oppositeDir = true;
                    }
                } else if (s4 === 0) {
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].affineRatio(P.coords.usrCoords, Pp, Qm) > 0) {
                        oppositeDir = true;
                    }
                }
                if (oppositeDir) {
                    // Swap Qm and Qp
                    // Then Qm Q Qp has the same direction as Pm P Pp
                    tmp = Qm;
                    Qm = Qp;
                    Qp = tmp;
                    tmp = s1;
                    s1 = s3;
                    s3 = tmp;
                    tmp = s2;
                    s2 = s4;
                    s4 = tmp;
                }
                if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                ;
                if (!__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(P.delayedStatus)) {
                    P.delayedStatus = [];
                }
                if (s1 === 0 && s2 === 0) {
                    // Line [P-,P] equals [Q-,Q] and line [P,P+] equals [Q,Q+]
                    // Interior of delayed crossing / bouncing
                    P.delayedStatus = [
                        "on",
                        "on"
                    ];
                } else if (s1 === 0) {
                    // P- on line [Q-,Q], P+ not on line [Q,Q+]
                    // Begin / end of delayed crossing / bouncing
                    side = this._getPosition(Pp, Qm, Q.coords.usrCoords, Qp);
                    P.delayedStatus = [
                        "on",
                        side
                    ];
                } else if (s2 === 0) {
                    // P+ on line [Q,Q+], P- not on line [Q-,Q]
                    // Begin / end of delayed crossing / bouncing
                    side = this._getPosition(Pm, Qm, Q.coords.usrCoords, Qp);
                    P.delayedStatus = [
                        side,
                        "on"
                    ];
                } else {
                    // Neither P+ on line [Q,Q+], nor P- on line [Q-,Q]
                    // No delayed crossing / bouncing
                    if (P.delayedStatus.length === 0) {
                        if (this._getPosition(Pm, Qm, Q.coords.usrCoords, Qp) !== this._getPosition(Pp, Qm, Q.coords.usrCoords, Qp)) {
                            P.data.type = "X";
                        } else {
                            P.data.type = "B";
                        }
                    }
                }
                if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                ;
            }
            if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(P._tours)) {
                P._tours++;
            }
            if (P._tours > 3 || P._end || cnt > 1000) {
                // Jump out if either
                // - we reached the end
                // - there are more than 1000 intersection points
                // - P._tours > 3: We went already 4 times through this path.
                if (cnt > 1000) {
                    console.log("Clipping: _classifyDegenerateIntersections exit");
                }
                if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(P._tours)) {
                    delete P._tours;
                }
                break;
            }
            if (P.intersection) {
                cnt++;
            }
            P = P._next;
        }
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
    },
    /**
     * At this point the degenerated intersections have been classified.
     * Now we decide if the intersection chains of the given path
     * ultimatively cross the other path or bounce.
     *
     * @param {JXG.Math.Clip.Vertex} P Start of path
     *
     * @see JXG.Math.Clip.markEntryExit
     * @see JXG.Math.Clip._classifyDegenerateIntersections
     * @private
     */ _handleIntersectionChains: function(P) {
        var cnt = 0, start_status = "Null", P_start, endless = true, intersection_chain = false, wait_for_exit = false, DEBUG = false;
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        while(endless){
            if (P.intersection === true) {
                if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                ;
                if (P.data.type === "T") {
                    if (P.delayedStatus[0] !== "on" && P.delayedStatus[1] === "on") {
                        // First point of intersection chain
                        intersection_chain = true;
                        P_start = P;
                        start_status = P.delayedStatus[0];
                    } else if (intersection_chain && P.delayedStatus[0] === "on" && P.delayedStatus[1] === "on") {
                        // Interior of intersection chain
                        P.data.type = "B";
                        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                        ;
                    } else if (intersection_chain && P.delayedStatus[0] === "on" && P.delayedStatus[1] !== "on") {
                        // Last point of intersection chain
                        intersection_chain = false;
                        if (start_status === P.delayedStatus[1]) {
                            // Intersection chain is delayed bouncing
                            P_start.data.type = "DB";
                            P.data.type = "DB";
                            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                            ;
                        } else {
                            // Intersection chain is delayed crossing
                            P_start.data.type = "DX";
                            P.data.type = "DX";
                            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                            ;
                        }
                    }
                }
                cnt++;
            }
            if (P._end) {
                wait_for_exit = true;
            }
            if (wait_for_exit && !intersection_chain) {
                break;
            }
            if (cnt > 1000) {
                console.log("Warning: _handleIntersectionChains: intersection chain reached maximum numbers of iterations");
                break;
            }
            P = P._next;
        }
    },
    /**
     * Handle the case that all vertices of one path are contained
     * in the other path. In this case we search for a midpoint of an edge
     * which is not contained in the other path and add it to the path.
     * It will be used as starting point for the entry/exit algorithm.
     *
     * @private
     * @param {Array} S Subject path
     * @param {Array} C Clip path
     * @param {JXG.board} board JSXGraph board object. It is needed to convert between
     * user coordinates and screen coordinates.
     */ _handleFullyDegenerateCase: function(S, C, board) {
        var P, Q, l, M, crds, q1, q2, node, i, j, leP, leQ, is_on_Q, tmp, is_fully_degenerated, arr = [
            S,
            C
        ];
        for(l = 0; l < 2; l++){
            P = arr[l];
            leP = P.length;
            for(i = 0, is_fully_degenerated = true; i < leP; i++){
                if (!P[i].intersection) {
                    is_fully_degenerated = false;
                    break;
                }
            }
            if (is_fully_degenerated) {
                // All nodes of P are also on the other path.
                Q = arr[(l + 1) % 2];
                leQ = Q.length;
                // We search for a midpoint of one edge of P which is not the other path and
                // we add that midpoint to P.
                for(i = 0; i < leP; i++){
                    q1 = P[i].coords.usrCoords;
                    q2 = P[i]._next.coords.usrCoords;
                    // M is the midpoint
                    M = [
                        (q1[0] + q2[0]) * 0.5,
                        (q1[1] + q2[1]) * 0.5,
                        (q1[2] + q2[2]) * 0.5
                    ];
                    // Test if M is on path Q. If this is not the case,
                    // we take M as additional point of P.
                    for(j = 0, is_on_Q = false; j < leQ; j++){
                        if (Math.abs(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].det3p(Q[j].coords.usrCoords, Q[(j + 1) % leQ].coords.usrCoords, M)) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
                            is_on_Q = true;
                            break;
                        }
                    }
                    if (!is_on_Q) {
                        // The midpoint is added to the doubly-linked list.
                        crds = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, M, board);
                        node = {
                            pos: i,
                            intersection: false,
                            coords: crds,
                            elementClass: __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_CLASS_POINT
                        };
                        tmp = P[i]._next;
                        P[i]._next = node;
                        node._prev = P[i];
                        node._next = tmp;
                        tmp._prev = node;
                        if (P[i]._end) {
                            P[i]._end = false;
                            node._end = true;
                        }
                        break;
                    }
                }
            }
        }
    },
    _getStatus: function(P, path) {
        var status;
        while(P.intersection){
            if (P._end) {
                break;
            }
            P = P._next;
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].windingNumber(P.coords.usrCoords, path) === 0) {
            // Outside
            status = "entry";
        // console.log(P.coords.usrCoords, ' is outside')
        } else {
            // Inside
            status = "exit";
        // console.log(P.coords.usrCoords, ' is inside')
        }
        return [
            P,
            status
        ];
    },
    /**
     * Mark the intersection vertices of path1 as entry points or as exit points
     * in respect to path2.
     * <p>
     * This is the simple algorithm as in
     * Greiner, Gnther; Kai Hormann (1998). "Efficient clipping of arbitrary polygons".
     * ACM Transactions on Graphics. 17 (2): 7183
     * <p>
     * The algorithm handles also "delayed crossings" from
     * Erich, L. Foster, and Kai Hormann, Kai, and Romeo Traaian Popa (2019),
     * "Clipping simple polygons with degenerate intersections", Computers & Graphics:X, 2.
     * and - as an additional improvement -
     * handles self intersections of delayed crossings (A.W. 2021).
     *
     * @private
     * @param  {Array} path1 First path
     * @param  {Array} path2 Second path
     */ markEntryExit: function(path1, path2, starters) {
        var status, P, cnt, res, i, len, start, endless = true, chain_start = null, intersection_chain = 0, DEBUG = false;
        len = starters.length;
        for(i = 0; i < len; i++){
            start = starters[i];
            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
            ;
            this._classifyDegenerateIntersections(path1[start]);
            this._handleIntersectionChains(path1[start]);
            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
            ;
            // Decide if the first point of the component is inside or outside
            // of the other path.
            res = this._getStatus(path1[start], path2);
            P = res[0];
            status = res[1];
            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
            ;
            P._starter = true;
            // Greiner-Hormann entry/exit algorithm
            // with additional handling of delayed crossing / bouncing
            cnt = 0;
            chain_start = null;
            intersection_chain = 0;
            while(endless){
                if (P.intersection === true) {
                    if (P.data.type === "X" && intersection_chain === 1) {
                        // While we are in an intersection chain, i.e. a delayed crossing,
                        // we stumble on a crossing intersection.
                        // Probably, the other path is self intersecting.
                        // We end the intersection chain here and
                        // mark this event by setting intersection_chain = 2.
                        chain_start.entry_exit = status;
                        if (status === "exit") {
                            chain_start.data.type = "X";
                        }
                        intersection_chain = 2;
                    }
                    if (P.data.type === "X" || P.data.type === "DB") {
                        P.entry_exit = status;
                        status = status === "entry" ? "exit" : "entry";
                        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                        ;
                    }
                    if (P.data.type === "DX") {
                        if (intersection_chain === 0) {
                            // Start of intersection chain.
                            // No active intersection chain yet,
                            // i.e. we did not pass a the first node of a delayed crossing.
                            chain_start = P;
                            intersection_chain = 1;
                            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                            ;
                        } else if (intersection_chain === 1) {
                            // Active intersection chain (intersection_chain===1)!
                            // End of delayed crossing chain reached
                            P.entry_exit = status;
                            chain_start.entry_exit = status;
                            if (status === "exit") {
                                chain_start.data.type = "X";
                            } else {
                                P.data.type = "X";
                            }
                            status = status === "entry" ? "exit" : "entry";
                            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                            ;
                            chain_start = null;
                            intersection_chain = 0;
                        } else if (intersection_chain === 2) {
                            // The delayed crossing had been interrupted by a crossing intersection.
                            // Now we treat the end of the delayed crossing as regular crossing.
                            P.entry_exit = status;
                            P.data.type = "X";
                            status = status === "entry" ? "exit" : "entry";
                            chain_start = null;
                            intersection_chain = 0;
                        }
                    }
                }
                P = P._next;
                if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(P._starter) || cnt > 10000) {
                    break;
                }
                cnt++;
            }
        }
    },
    /**
     *
     * @private
     * @param {Array} P
     * @param {Boolean} isBackward
     * @returns {Boolean} True, if the node is an intersection and is of type 'X'
     */ _stayOnPath: function(P, status) {
        var stay = true;
        if (P.intersection && P.data.type !== "B") {
            stay = status === P.entry_exit;
        }
        return stay;
    },
    /**
     * Add a point to the clipping path and returns if the algorithms
     * arrived at an intersection point which has already been visited.
     * In this case, true is returned.
     *
     * @param {Array} path Resulting path
     * @param {JXG.Math.Clip.Vertex} vertex Point to be added
     * @param {Boolean} DEBUG debug output to console.log
     * @returns {Boolean} true: point has been visited before, false otherwise
     * @private
     */ _addVertex: function(path, vertex, DEBUG) {
        if (!isNaN(vertex.coords.usrCoords[1]) && !isNaN(vertex.coords.usrCoords[2])) {
            path.push(vertex);
        }
        if (vertex.intersection && vertex.data.done) {
            if (DEBUG) {
                console.log("Add last intersection point", vertex.coords.usrCoords, "on", vertex.data.pathname, vertex.entry_exit, vertex.data.type);
            }
            return true;
        }
        if (vertex.intersection) {
            vertex.data.done = true;
            if (DEBUG) {
                console.log("Add intersection point", vertex.coords.usrCoords, "on", vertex.data.pathname, vertex.entry_exit, vertex.data.type);
            }
        }
        return false;
    },
    /**
     * Tracing phase of the Greiner-Hormann algorithm, see
     * Greiner, Gnther; Kai Hormann (1998).
     * "Efficient clipping of arbitrary polygons". ACM Transactions on Graphics. 17 (2): 7183
     *
     * Boolean operations on polygons are distinguished: 'intersection', 'union', 'difference'.
     *
     * @private
     * @param  {Array} S           Subject path
     * @param  {Array} S_intersect Array containing the intersection vertices of the subject path
     * @param  {String} clip_type  contains the Boolean operation: 'intersection', 'union', or 'difference'
     * @return {Array}             Array consisting of two arrays containing the x-coordinates and the y-coordintaes of
     *      the resulting path.
     */ tracing: function(S, S_intersect, clip_type) {
        var P, status, current, start, cnt = 0, maxCnt = 10000, S_idx = 0, path = [], done = false, DEBUG = false;
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        // reverse = (clip_type === 'difference' || clip_type === 'union') ? true : false;
        while(S_idx < S_intersect.length && cnt < maxCnt){
            // Take the first intersection node of the subject path
            // which is not yet included as start point.
            current = S_intersect[S_idx];
            if (current.data.done || current.data.type !== "X" /*|| !this._isCrossing(current, reverse)*/ ) {
                S_idx++;
                continue;
            }
            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
            ;
            if (path.length > 0) {
                // Add a new path
                path.push([
                    NaN,
                    NaN
                ]);
            }
            // Start now the tracing with that node of the subject path
            start = current.data.idx;
            P = S;
            done = this._addVertex(path, current, DEBUG);
            status = current.entry_exit;
            do {
                if (done) {
                    break;
                }
                //
                // Decide if we follow the current path forward or backward.
                // for example, in case the clipping is of type "intersection"
                // and the current intersection node is of type entry, we go forward.
                //
                if (clip_type === "intersection" && current.entry_exit === "entry" || clip_type === "union" && current.entry_exit === "exit" || clip_type === "difference" && P === S === (current.entry_exit === "exit")) {
                    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                    ;
                    //
                    // Take the next nodes and add them to the path
                    // as long as they are not intersection nodes of type 'X'.
                    //
                    do {
                        current = current._next;
                        done = this._addVertex(path, current, DEBUG);
                        if (done) {
                            break;
                        }
                    }while (this._stayOnPath(current, status))
                    cnt++;
                } else {
                    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                    ;
                    //
                    // Here, we go backward:
                    // Take the previous nodes and add them to the path
                    // as long as they are not intersection nodes of type 'X'.
                    //
                    do {
                        current = current._prev;
                        done = this._addVertex(path, current, DEBUG);
                        if (done) {
                            break;
                        }
                    }while (this._stayOnPath(current, status))
                    cnt++;
                }
                if (done) {
                    break;
                }
                if (!current.neighbour) {
                    console.log("Tracing: emergency break - no neighbour!!!!!!!!!!!!!!!!!", cnt);
                    return [
                        [
                            0
                        ],
                        [
                            0
                        ]
                    ];
                }
                //
                // We stopped the forward or backward loop, because we've
                // arrived at a crossing intersection node, i.e. we have to
                // switch to the other path now.
                if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                ;
                current = current.neighbour;
                if (current.data.done) {
                    break;
                }
                current.data.done = true;
                status = current.entry_exit;
                // if (current.data.done) {
                //     // We arrived at an intersection node which is already
                //     // added to the clipping path.
                //     // We add it again to close the clipping path and jump out of the
                //     // loop.
                //     path.push(current);
                //     if (DEBUG) {
                //         console.log("Push last", current.coords.usrCoords);
                //     }
                //     break;
                // }
                P = current.data.path;
            // Polygon closed:
            // if (DEBUG) {
            //     console.log("End of loop:", "start=", start, "idx=", current.data.idx);
            // }
            // } while (!(current.data.pathname === 'S' && current.data.idx === start) && cnt < maxCnt);
            }while (current.data.idx !== start && cnt < maxCnt)
            if (cnt >= maxCnt) {
                console.log("Tracing: stopping an infinite loop!", cnt);
            }
            S_idx++;
        }
        return this._getCoordsArrays(path, false);
    },
    /**
     * Handle path clipping if one of the two paths is empty.
     * @private
     * @param  {Array} S        First path, array of JXG.Coords
     * @param  {Array} C        Second path, array of JXG.Coords
     * @param  {String} clip_type Type of Boolean operation: 'intersection', 'union', 'differrence'.
     * @return {Boolean}        true, if one of the input paths is empty, false otherwise.
     */ isEmptyCase: function(S, C, clip_type) {
        if (clip_type === "intersection" && (S.length === 0 || C.length === 0)) {
            return true;
        }
        if (clip_type === "union" && S.length === 0 && C.length === 0) {
            return true;
        }
        if (clip_type === "difference" && S.length === 0) {
            return true;
        }
        return false;
    },
    _getCoordsArrays: function(path, doClose) {
        var pathX = [], pathY = [], i, le = path.length;
        for(i = 0; i < le; i++){
            if (path[i].coords) {
                pathX.push(path[i].coords.usrCoords[1]);
                pathY.push(path[i].coords.usrCoords[2]);
            } else {
                pathX.push(path[i][0]);
                pathY.push(path[i][1]);
            }
        }
        if (doClose && le > 0) {
            if (path[0].coords) {
                pathX.push(path[0].coords.usrCoords[1]);
                pathY.push(path[0].coords.usrCoords[2]);
            } else {
                pathX.push(path[0][0]);
                pathY.push(path[0][1]);
            }
        }
        return [
            pathX,
            pathY
        ];
    },
    /**
     * Handle cases when there are no intersection points of the two paths. This is the case if the
     * paths are disjoint or one is contained in the other.
     * @private
     * @param  {Array} S        First path, array of JXG.Coords
     * @param  {Array} C        Second path, array of JXG.Coords
     * @param  {String} clip_type Type of Boolean operation: 'intersection', 'union', 'differrence'.
     * @return {Array}          Array consisting of two arrays containing the x-coordinates and the y-coordinates of
     *      the resulting path.
     */ handleEmptyIntersection: function(S, C, clip_type) {
        var P, Q, doClose = false, path = [];
        // Handle trivial cases
        if (S.length === 0) {
            if (clip_type === "union") {
                // S cup C = C
                path = C;
            } else {
                // S cap C = S \ C = {}
                path = [];
            }
            return this._getCoordsArrays(path, true);
        }
        if (C.length === 0) {
            if (clip_type === "intersection") {
                // S cap C = {}
                path = [];
            } else {
                // S cup C = S \ C = S
                path = S;
            }
            return this._getCoordsArrays(path, true);
        }
        // From now on, both paths have non-zero length.
        // The two paths have no crossing intersections,
        // but there might be bouncing intersections.
        // First, we find -- if possible -- on each path a point which is not an intersection point.
        if (S.length > 0) {
            P = S[0];
            while(P.intersection){
                P = P._next;
                if (P._end) {
                    break;
                }
            }
        }
        if (C.length > 0) {
            Q = C[0];
            while(Q.intersection){
                Q = Q._next;
                if (Q._end) {
                    break;
                }
            }
        }
        // Test if one curve is contained by the other
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].windingNumber(P.coords.usrCoords, C) === 0) {
            // P is outside of C:
            // Either S is disjoint from C or C is inside of S
            if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].windingNumber(Q.coords.usrCoords, S) !== 0) {
                // C is inside of S, i.e. C subset of S
                if (clip_type === "union") {
                    __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].concat(path, S);
                    path.push(S[0]);
                } else if (clip_type === "difference") {
                    __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].concat(path, S);
                    path.push(S[0]);
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].signedPolygon(S) * __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].signedPolygon(C) > 0) {
                        // Pathes have same orientation, we have to revert one.
                        path.reverse();
                    }
                    path.push([
                        NaN,
                        NaN
                    ]);
                }
                if (clip_type === "difference" || clip_type === "intersection") {
                    __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].concat(path, C);
                    path.push(C[0]);
                    doClose = false;
                }
            } else {
                // The curves are disjoint
                if (clip_type === "difference") {
                    __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].concat(path, S);
                    doClose = true;
                } else if (clip_type === "union") {
                    __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].concat(path, S);
                    path.push(S[0]);
                    path.push([
                        NaN,
                        NaN
                    ]);
                    __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].concat(path, C);
                    path.push(C[0]);
                }
            }
        } else {
            // S inside of C, i.e. S subset of C
            if (clip_type === "intersection") {
                __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].concat(path, S);
                doClose = true;
            } else if (clip_type === "union") {
                __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].concat(path, C);
                path.push(C[0]);
            }
        // 'difference': path is empty
        }
        return this._getCoordsArrays(path, doClose);
    },
    /**
     * Count intersection points of type 'X'.
     * @param {JXG.Mat.Clip.Vertex} intersections
     * @returns Number
     * @private
     */ _countCrossingIntersections: function(intersections) {
        var i, le = intersections.length, sum = 0;
        for(i = 0; i < le; i++){
            if (intersections[i].data.type === "X") {
                sum++;
            }
        }
        return sum;
    },
    /**
     * Create path from all sorts of input elements and convert it
     * to a suitable input path for greinerHormann().
     *
     * @private
     * @param {Object} obj Maybe curve, arc, sector, circle, polygon, array of points, array of JXG.Coords,
     * array of coordinate pairs.
     * @param  {JXG.Board} board   JSXGraph board object. It is needed to convert between
     * user coordinates and screen coordinates.
     * @returns {Array} Array of JXG.Coords elements containing a path.
     * @see JXG.Math.Clip.greinerHormann
     */ _getPath: function(obj, board) {
        var i, len, r, rad, angle, alpha, steps, S = [];
        // Collect all points into path array S
        if (obj.elementClass === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_CLASS_CURVE && (obj.type === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_TYPE_ARC || obj.type === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_TYPE_SECTOR)) {
            angle = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].rad(obj.radiuspoint, obj.center, obj.anglepoint);
            steps = Math.floor(angle * 180 / Math.PI);
            r = obj.Radius();
            rad = angle / steps;
            alpha = Math.atan2(obj.radiuspoint.coords.usrCoords[2] - obj.center.coords.usrCoords[2], obj.radiuspoint.coords.usrCoords[1] - obj.center.coords.usrCoords[1]);
            if (obj.type === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_TYPE_SECTOR) {
                this._addToList(S, obj.center.coords, 0);
            }
            for(i = 0; i <= steps; i++){
                this._addToList(S, new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
                    obj.center.coords.usrCoords[0],
                    obj.center.coords.usrCoords[1] + Math.cos(i * rad + alpha) * r,
                    obj.center.coords.usrCoords[2] + Math.sin(i * rad + alpha) * r
                ], board), i + 1);
            }
            if (obj.type === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_TYPE_SECTOR) {
                this._addToList(S, obj.center.coords, steps + 2);
            }
        } else if (obj.elementClass === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_CLASS_CURVE && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(obj.points)) {
            len = obj.numberPoints;
            for(i = 0; i < len; i++){
                this._addToList(S, obj.points[i], i);
            }
        } else if (obj.type === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_TYPE_POLYGON) {
            for(i = 0; i < obj.vertices.length; i++){
                this._addToList(S, obj.vertices[i].coords, i);
            }
        } else if (obj.elementClass === __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OBJECT_CLASS_CIRCLE) {
            steps = 359;
            r = obj.Radius();
            rad = 2 * Math.PI / steps;
            for(i = 0; i <= steps; i++){
                this._addToList(S, new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, [
                    obj.center.coords.usrCoords[0],
                    obj.center.coords.usrCoords[1] + Math.cos(i * rad) * r,
                    obj.center.coords.usrCoords[2] + Math.sin(i * rad) * r
                ], board), i);
            }
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(obj)) {
            len = obj.length;
            for(i = 0; i < len; i++){
                if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(obj[i].coords)) {
                    // Point type
                    this._addToList(S, obj[i].coords, i);
                } else if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(obj[i])) {
                    // Coordinate pair
                    this._addToList(S, new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$coords$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$base$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COORDS_BY_USER, obj[i], board), i);
                } else if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(obj[i].usrCoords)) {
                    // JXG.Coordinates
                    this._addToList(S, obj[i], i);
                }
            }
        }
        return S;
    },
    /**
     * Determine the intersection, union or difference of two closed paths.
     * <p>
     * This is an implementation of the Greiner-Hormann algorithm, see
     * Gnther Greiner and Kai Hormann (1998).
     * "Efficient clipping of arbitrary polygons". ACM Transactions on Graphics. 17 (2): 7183.
     * and
     * Erich, L. Foster, and Kai Hormann, Kai, and Romeo Traaian Popa (2019),
     * "Clipping simple polygons with degenerate intersections", Computers & Graphics:X, 2.
     * <p>
     * It is assumed that the pathes are closed, whereby it does not matter if the last point indeed
     * equals the first point. In contrast to the original Greiner-Hormann algorithm,
     * this algorithm can cope with many degenerate cases. A degenerate case is a vertext of one path
     * which is contained in the other path.
     * <p>
     *
     * <p>Problematic are:
     * <ul>
     *   <li>degenerate cases where one path additionally has self-intersections
     *   <li>differences with one path having self-intersections.
     * </ul>
     *
     * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} subject   First closed path, usually called 'subject'.
     * Maybe curve, arc, sector, circle, polygon, array of points, array of JXG.Coords,
     * array of coordinate pairs.
     * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} clip      Second closed path, usually called 'clip'.
     * Maybe curve, arc, sector, circle, polygon, array of points, array of JXG.Coords,
     * array of coordinate pairs.
     * @param  {String} clip_type Determines the type of boolean operation on the two paths.
     *  Possible values are 'intersection', 'union', or 'difference'.
     * @param  {JXG.Board} board   JSXGraph board object. It is needed to convert between
     * user coordinates and screen coordinates.
     * @return {Array}          Array consisting of two arrays containing the x-coordinates and the y-coordinates of
     *      the resulting path.
     *
     * @see JXG.Math.Clip.intersection
     * @see JXG.Math.Clip.union
     * @see JXG.Math.Clip.difference
     *
     * @example
     *     var curve1 = board.create('curve', [
     *             [-3, 3, 0, -3],
     *             [3, 3, 0, 3]
     *         ],
     *         {strokeColor: 'black'});
     *
     *     var curve2 = board.create('curve', [
     *             [-4, 4, 0, -4],
     *             [2, 2, 4, 2]
     *         ],
     *         {strokeColor: 'blue'});
     *
     *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});
     *     clip_path.updateDataArray = function() {
     *         var a = JXG.Math.Clip.greinerHormann(curve2, curve1, 'intersection', this.board);
     *
     *         this.dataX = a[0];
     *         this.dataY = a[1];
     *     };
     *
     *     board.update();
     *
     * </pre><div id="JXG9d2a6acf-a43b-4035-8f8a-9b1bee580210" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG9d2a6acf-a43b-4035-8f8a-9b1bee580210',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *
     *         var curve1 = board.create('curve', [
     *                 [-3, 3, 0, -3],
     *                 [3, 3, 0, 3]
     *             ],
     *             {strokeColor: 'black'});
     *
     *         var curve2 = board.create('curve', [
     *                 [-4, 4, 0, -4],
     *                 [2, 2, 4, 2]
     *             ],
     *             {strokeColor: 'blue'});
     *
     *         var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});
     *         clip_path.updateDataArray = function() {
     *             var a = JXG.Math.Clip.greinerHormann(curve2, curve1, 'intersection', this.board);
     *
     *             this.dataX = a[0];
     *             this.dataY = a[1];
     *         };
     *
     *         board.update();
     *
     *     })();
     *
     * </script><pre>
     *
     * @example
     *     var curve1 = board.create('curve', [
     *             [-3, 3, 0, -3],
     *             [3, 3, 0, 3]
     *         ],
     *         {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});
     *
     *     var curve2 = board.create('polygon', [[3, 4], [-4, 0], [-4, 4]],
     *             {strokeColor: 'blue', fillColor: 'none'});
     *
     *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});
     *     clip_path.updateDataArray = function() {
     *         var a = JXG.Math.Clip.greinerHormann(curve1, curve2, 'union', this.board);
     *         this.dataX = a[0];
     *         this.dataY = a[1];
     *     };
     *
     *     board.update();
     *
     * </pre><div id="JXG6075c918-4d57-4b72-b600-6597a6a4f44e" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG6075c918-4d57-4b72-b600-6597a6a4f44e',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *         var curve1 = board.create('curve', [
     *                 [-3, 3, 0, -3],
     *                 [3, 3, 0, 3]
     *             ],
     *             {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});
     *
     *         var curve2 = board.create('polygon', [[3, 4], [-4, 0], [-4, 4]],
     *                 {strokeColor: 'blue', fillColor: 'none'});
     *
     *
     *         var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});
     *         clip_path.updateDataArray = function() {
     *             var a = JXG.Math.Clip.greinerHormann(curve1, curve2, 'union', this.board);
     *             this.dataX = a[0];
     *             this.dataY = a[1];
     *         };
     *
     *         board.update();
     *
     *     })();
     *
     * </script><pre>
     *
     * @example
     *     var curve1 = board.create('curve', [
     *             [-4, 4, 0, -4],
     *             [4, 4, -2, 4]
     *         ],
     *         {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});
     *
     *     var curve2 = board.create('circle', [[0, 0], [0, -2]],
     *             {strokeColor: 'blue', strokeWidth: 1, fillColor: 'red', fixed: true, fillOpacity: 0.3,
     *             center: {visible: true, size: 5}, point2: {size: 5}});
     *
     *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});
     *     clip_path.updateDataArray = function() {
     *         var a = JXG.Math.Clip.greinerHormann(curve1, curve2, 'difference', this.board);
     *
     *         this.dataX = a[0];
     *         this.dataY = a[1];
     *     };
     *
     *     board.update();
     *
     * </pre><div id="JXG46b3316b-5ab9-4928-9473-ccb476ca4185" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG46b3316b-5ab9-4928-9473-ccb476ca4185',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *         var curve1 = board.create('curve', [
     *                 [-4, 4, 0, -4],
     *                 [4, 4, -2, 4]
     *             ],
     *             {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});
     *
     *         var curve2 = board.create('circle', [[0, 0], [0, -2]],
     *                 {strokeColor: 'blue', strokeWidth: 1, fillColor: 'red', fixed: true, fillOpacity: 0.3,
     *                 center: {visible: true, size: 5}, point2: {size: 5}});
     *
     *
     *         var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});
     *         clip_path.updateDataArray = function() {
     *             var a = JXG.Math.Clip.greinerHormann(curve1, curve2, 'difference', this.board);
     *
     *             this.dataX = a[0];
     *             this.dataY = a[1];
     *         };
     *
     *         board.update();
     *
     *     })();
     *
     * </script><pre>
     *
     * @example
     * var clip_path = board.create('curve', [[], []], {strokeWidth: 1, fillColor: 'yellow', fillOpacity: 0.6});
     * clip_path.updateDataArray = function() {
     *     var bbox = this.board.getBoundingBox(),
     *         canvas, triangle;
     *
     *     canvas = [[bbox[0], bbox[1]], // ul
     *          [bbox[0], bbox[3]], // ll
     *          [bbox[2], bbox[3]], // lr
     *          [bbox[2], bbox[1]], // ur
     *          [bbox[0], bbox[1]]] // ul
     *     triangle = [[-1,1], [1,1], [0,-1], [-1,1]];
     *
     *     var a = JXG.Math.Clip.greinerHormann(canvas, triangle, 'difference', this.board);
     *     this.dataX = a[0];
     *     this.dataY = a[1];
     * };
     *
     * </pre><div id="JXGe94da07a-2a01-4498-ad62-f71a327f8e25" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXGe94da07a-2a01-4498-ad62-f71a327f8e25',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     var clip_path = board.create('curve', [[], []], {strokeWidth: 1, fillColor: 'yellow', fillOpacity: 0.6});
     *     clip_path.updateDataArray = function() {
     *         var bbox = this.board.getBoundingBox(),
     *             canvas, triangle;
     *
     *         canvas = [[bbox[0], bbox[1]], // ul
     *              [bbox[0], bbox[3]], // ll
     *              [bbox[2], bbox[3]], // lr
     *              [bbox[2], bbox[1]], // ur
     *              [bbox[0], bbox[1]]] // ul
     *         triangle = [[-1,1], [1,1], [0,-1], [-1,1]];
     *
     *         var a = JXG.Math.Clip.greinerHormann(canvas, triangle, 'difference', this.board);
     *         this.dataX = a[0];
     *         this.dataY = a[1];
     *     };
     *
     *     })();
     *
     * </script><pre>
     *
     */ greinerHormann: function(subject, clip, clip_type, board) {
        //},
        // subject_first_point_type, clip_first_point_type) {
        var len, S = [], C = [], S_intersect = [], // C_intersect = [],
        S_starters, C_starters, res = [], DEBUG = false;
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        // Collect all subject points into subject array S
        S = this._getPath(subject, board);
        len = S.length;
        if (len > 0 && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].distance(S[0].coords.usrCoords, S[len - 1].coords.usrCoords, 3) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
            S.pop();
        }
        // Collect all points into clip array C
        C = this._getPath(clip, board);
        len = C.length;
        if (len > 0 && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].distance(C[0].coords.usrCoords, C[len - 1].coords.usrCoords, 3) < __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps * __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eps) {
            C.pop();
        }
        // Handle cases where at least one of the paths is empty
        if (this.isEmptyCase(S, C, clip_type)) {
            return [
                [],
                []
            ];
        }
        // Add pointers for doubly linked lists
        S_starters = this.makeDoublyLinkedList(S);
        C_starters = this.makeDoublyLinkedList(C);
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        res = this.findIntersections(S, C, board);
        S_intersect = res[0];
        this._handleFullyDegenerateCase(S, C, board);
        // Phase 2: mark intersection points as entry or exit points
        this.markEntryExit(S, C, S_starters);
        // if (S[0].coords.distance(Const.COORDS_BY_USER, C[0].coords) === 0) {
        //     // Randomly disturb the first point of the second path
        //     // if both paths start at the same point.
        //     C[0].usrCoords[1] *= 1 + Math.random() * 0.0001 - 0.00005;
        //     C[0].usrCoords[2] *= 1 + Math.random() * 0.0001 - 0.00005;
        // }
        this.markEntryExit(C, S, C_starters);
        // Handle cases without intersections
        if (this._countCrossingIntersections(S_intersect) === 0) {
            return this.handleEmptyIntersection(S, C, clip_type);
        }
        // Phase 3: tracing
        return this.tracing(S, S_intersect, clip_type);
    },
    /**
     * Union of two closed paths. The paths could be JSXGraph elements circle, curve, or polygon.
     * Computed by the Greiner-Hormann algorithm.
     *
     * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} subject   First closed path.
     * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} clip      Second closed path.
     * @param  {JXG.Board} board   JSXGraph board object. It is needed to convert between
     * user coordinates and screen coordinates.
     * @return {Array}          Array consisting of two arrays containing the x-coordinates and the y-coordinates of
     *      the resulting path.
     *
     * @see JXG.Math.Clip.greinerHormann
     * @see JXG.Math.Clip.intersection
     * @see JXG.Math.Clip.difference
     *
     * @example
     *     var curve1 = board.create('curve', [
     *             [-3, 3, 0, -3],
     *             [3, 3, 0, 3]
     *         ],
     *         {strokeColor: 'black'});
     *
     *     var curve2 = board.create('polygon', [[3, 4], [-4, 0], [-4, 4]],
     *             {strokeColor: 'blue', fillColor: 'none'});
     *
     *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});
     *     clip_path.updateDataArray = function() {
     *         var a = JXG.Math.Clip.union(curve1, curve2, this.board);
     *         this.dataX = a[0];
     *         this.dataY = a[1];
     *     };
     *
     *     board.update();
     *
     * </pre><div id="JXG7c5204aa-3824-4464-819c-80df7bf1d917" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG7c5204aa-3824-4464-819c-80df7bf1d917',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *         var curve1 = board.create('curve', [
     *                 [-3, 3, 0, -3],
     *                 [3, 3, 0, 3]
     *             ],
     *             {strokeColor: 'black'});
     *
     *         var curve2 = board.create('polygon', [[3, 4], [-4, 0], [-4, 4]],
     *                 {strokeColor: 'blue', fillColor: 'none'});
     *
     *
     *         var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});
     *         clip_path.updateDataArray = function() {
     *             var a = JXG.Math.Clip.union(curve1, curve2, this.board);
     *             this.dataX = a[0];
     *             this.dataY = a[1];
     *         };
     *
     *         board.update();
     *
     *     })();
     *
     * </script><pre>
     *
     */ union: function(path1, path2, board) {
        return this.greinerHormann(path1, path2, "union", board);
    },
    /**
     * Intersection of two closed paths. The paths could be JSXGraph elements circle, curve, or polygon.
     * Computed by the Greiner-Hormann algorithm.
     *
     * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} subject   First closed path.
     * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} clip      Second closed path.
     * @param  {JXG.Board} board   JSXGraph board object. It is needed to convert between
     * user coordinates and screen coordinates.
     * @return {Array}          Array consisting of two arrays containing the x-coordinates and the y-coordinates of
     *      the resulting path.
     *
     * @see JXG.Math.Clip.greinerHormann
     * @see JXG.Math.Clip.union
     * @see JXG.Math.Clip.difference
     *
     * @example
     * var p = [];
     * p.push(board.create('point', [0, -5]));
     * p.push(board.create('point', [-5, 0]));
     * p.push(board.create('point', [-3, 3]));
     *
     * var curve1 = board.create('ellipse', p,
     *                 {strokeColor: 'black'});
     *
     * var curve2 = board.create('curve', [function(phi){return 4 * Math.cos(2*phi); },
     *                                     [0, 0],
     *                                     0, 2 * Math.PI],
     *                       {curveType:'polar', strokeColor: 'blue', strokewidth:1});
     *
     * var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});
     * clip_path.updateDataArray = function() {
     *     var a = JXG.Math.Clip.intersection(curve2, curve1, this.board);
     *
     *     this.dataX = a[0];
     *     this.dataY = a[1];
     * };
     *
     * board.update();
     *
     * </pre><div id="JXG7ad547eb-7b6c-4a1a-a4d4-4ed298fc7998" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG7ad547eb-7b6c-4a1a-a4d4-4ed298fc7998',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     var p = [];
     *     p.push(board.create('point', [0, -5]));
     *     p.push(board.create('point', [-5, 0]));
     *     p.push(board.create('point', [-3, 3]));
     *
     *     var curve1 = board.create('ellipse', p,
     *                     {strokeColor: 'black'});
     *
     *     var curve2 = board.create('curve', [function(phi){return 4 * Math.cos(2*phi); },
     *                                         [0, 0],
     *                                         0, 2 * Math.PI],
     *                           {curveType:'polar', strokeColor: 'blue', strokewidth:1});
     *
     *
     *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});
     *     clip_path.updateDataArray = function() {
     *         var a = JXG.Math.Clip.intersection(curve2, curve1, this.board);
     *
     *         this.dataX = a[0];
     *         this.dataY = a[1];
     *     };
     *
     *     board.update();
     *
     *     })();
     *
     * </script><pre>
     *
     *
     */ intersection: function(path1, path2, board) {
        return this.greinerHormann(path1, path2, "intersection", board);
    },
    /**
     * Difference of two closed paths, i.e. path1 minus path2.
     * The paths could be JSXGraph elements circle, curve, or polygon.
     * Computed by the Greiner-Hormann algorithm.
     *
     * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} subject   First closed path.
     * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} clip      Second closed path.
     * @param  {JXG.Board} board   JSXGraph board object. It is needed to convert between
     * user coordinates and screen coordinates.
     * @return {Array}          Array consisting of two arrays containing the x-coordinates and the y-coordinates of
     *      the resulting path.
     *
     * @see JXG.Math.Clip.greinerHormann
     * @see JXG.Math.Clip.intersection
     * @see JXG.Math.Clip.union
     *
     * @example
     *     var curve1 = board.create('polygon', [[-4, 4], [4, 4], [0, -1]],
     *             {strokeColor: 'blue', fillColor: 'none'});
     *
     *     var curve2 = board.create('curve', [
     *             [-1, 1, 0, -1],
     *             [1, 1, 3, 1]
     *         ],
     *         {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});
     *
     *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});
     *     clip_path.updateDataArray = function() {
     *         var a = JXG.Math.Clip.difference(curve1, curve2, this.board);
     *         this.dataX = a[0];
     *         this.dataY = a[1];
     *     };
     *
     *     board.update();
     *
     * </pre><div id="JXGc5ce6bb3-146c-457f-a48b-6b9081fb68a3" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXGc5ce6bb3-146c-457f-a48b-6b9081fb68a3',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *         var curve1 = board.create('polygon', [[-4, 4], [4, 4], [0, -1]],
     *                 {strokeColor: 'blue', fillColor: 'none'});
     *
     *         var curve2 = board.create('curve', [
     *                 [-1, 1, 0, -1],
     *                 [1, 1, 3, 1]
     *             ],
     *             {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});
     *
     *
     *         var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});
     *         clip_path.updateDataArray = function() {
     *             var a = JXG.Math.Clip.difference(curve1, curve2, this.board);
     *             this.dataX = a[0];
     *             this.dataY = a[1];
     *         };
     *
     *         board.update();
     *
     *     })();
     *
     * </script><pre>
     *
     */ difference: function(path1, path2, board) {
        return this.greinerHormann(path1, path2, "difference", board);
    }
};
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Clip;
}),
"[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/poly.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */ /*global JXG: true, define: true*/ /*jslint nomen: true, plusplus: true*/ /**
 * @fileoverview In this file the namespace Math.Poly is defined, which holds algorithms to create and
 * manipulate polynomials.
 */ __turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/jxg.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/math.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/utils/type.js [app-client] (ecmascript)");
;
;
;
/**
 * The JXG.Math.Poly namespace holds algorithms to create and manipulate polynomials.
 * @name JXG.Math.Poly
 * @exports Mat.Poly as JXG.Math.Poly
 * @namespace
 */ __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Poly = {};
/**
 * Define a polynomial ring over R.
 * @class
 * @name JXG.Math.Poly.Ring
 * @param {Array} variables List of indeterminates.
 */ __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Poly.Ring = function(variables) {
    /**
     * A list of variables in this polynomial ring.
     * @type Array
     */ this.vars = variables;
};
__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].extend(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Poly.Ring.prototype, /** @lends JXG.Math.Poly.Ring.prototype */ {
});
/**
 * Define a monomial over the polynomial ring <tt>ring</tt>.
 * @class
 * @name JXG.Math.Poly.Monomial
 * @param {JXG.Math.Poly.Ring} ring
 * @param {Number} coefficient
 * @param {Array} exponents An array of exponents, corresponding to ring
 */ __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Poly.Monomial = function(ring, coefficient, exponents) {
    var i;
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(ring)) {
        throw new Error("JSXGraph error: In JXG.Math.Poly.monomial missing parameter 'ring'.");
    }
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(exponents)) {
        exponents = [];
    }
    exponents = exponents.slice(0, ring.vars.length);
    for(i = exponents.length; i < ring.vars.length; i++){
        exponents.push(0);
    }
    /**
     * A polynomial ring.
     * @type JXG.Math.Poly.Ring
     */ this.ring = ring;
    /**
     * The monomial's coefficient
     * @type Number
     */ this.coefficient = coefficient || 0;
    /**
     * Exponent vector, the order depends on the order of the variables
     * in the ring definition.
     * @type Array
     */ this.exponents = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].deepCopy(exponents);
};
__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].extend(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Poly.Monomial.prototype, /** @lends JXG.Math.Poly.Monomial.prototype */ {
    /**
         * Creates a deep copy of the monomial.
         *
         * @returns {JXG.Math.Poly.Monomial}
         *
         * @memberof JXG.Math.Poly.Monomial
         */ copy: function() {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Poly.Monomial(this.ring, this.coefficient, this.exponents);
    },
    /**
         * Print the monomial.
         * @returns {String} String representation of the monomial

         * @memberof JXG.Math.Poly.Monomial
         */ print: function() {
        var s = [], i;
        for(i = 0; i < this.ring.vars.length; i++){
            s.push(this.ring.vars[i] + "^" + this.exponents[i]);
        }
        return this.coefficient + "*" + s.join("*");
    }
});
/**
 * A polynomial is a sum of monomials.
 * @class
 * @name JXG.Math.Poly.Polynomial
 * @param {JXG.Math.Poly.Ring} ring A polynomial ring.
 * @param {String} str TODO String representation of the polynomial, will be parsed.
 */ __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Poly.Polynomial = function(ring, str) {
    var parse = function() {}, mons;
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(ring)) {
        throw new Error("JSXGraph error: In JXG.Math.Poly.polynomial missing parameter 'ring'.");
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(str) && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isString(str)) {
        mons = parse(str);
    } else {
        mons = [];
    }
    /**
     * A polynomial ring.
     * @type JXG.Math.Poly.Ring
     */ this.ring = ring;
    /**
     * List of monomials.
     * @type Array
     */ this.monomials = mons;
};
__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].extend(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Poly.Polynomial.prototype, /** @lends JXG.Math.Poly.Polynomial.prototype */ {
    /**
         * Find a monomial with the given signature, i.e. exponent vector.
         * @param {Array} sig An array of numbers
         * @returns {Number} The index of the first monomial with the given signature, or -1
         * if no monomial could be found.
         * @memberof JXG.Math.Poly.Polynomial
         */ findSignature: function(sig) {
        var i;
        for(i = 0; i < this.monomials.length; i++){
            if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cmpArrays(this.monomials[i].exponents, sig)) {
                return i;
            }
        }
        return -1;
    },
    /**
         * Adds a monomial to the polynomial. Checks the existing monomials for the added
         * monomial's signature and just adds the coefficient if one is found.
         * @param {JXG.Math.Poly.Monomial} m
         * @param {Number} factor Either <tt>1</tt> or <tt>-1</tt>.
         * @memberof JXG.Math.Poly.Polynomial
         */ addSubMonomial: function(m, factor) {
        var i;
        i = this.findSignature(m.exponents);
        if (i > -1) {
            this.monomials[i].coefficient += factor * m.coefficient;
        } else {
            m.coefficient *= factor;
            this.monomials.push(m);
        }
    },
    /**
         * Adds another polynomial or monomial to this one and merges them by checking for the
         * signature of each new monomial in the existing monomials.
         * @param {JXG.Math.Poly.Polynomial|JXG.Math.Poly.Monomial} mp
         * @memberof JXG.Math.Poly.Polynomial
         */ add: function(mp) {
        var i;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(mp) && mp.ring === this.ring) {
            if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(mp.exponents)) {
                // mp is a monomial
                this.addSubMonomial(mp, 1);
            } else {
                // mp is a polynomial
                for(i = 0; i < mp.monomials.length; i++){
                    this.addSubMonomial(mp.monomials[i], 1);
                }
            }
        } else {
            throw new Error("JSXGraph error: In JXG.Math.Poly.polynomial.add either summand is undefined or rings don't match.");
        }
    },
    /**
         * Subtracts another polynomial or monomial from this one and merges them by checking for the
         * signature of each new monomial in the existing monomials.
         * @param {JXG.Math.Poly.Polynomial|JXG.Math.Poly.Monomial} mp
         * @memberof JXG.Math.Poly.Polynomial
         */ sub: function(mp) {
        var i;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].exists(mp) && mp.ring === this.ring) {
            if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(mp.exponents)) {
                // mp is a monomial
                this.addSubMonomial(mp, -1);
            } else {
                // mp is a polynomial
                for(i = 0; i < mp.monomials.length; i++){
                    this.addSubMonomial(mp.monomials[i], -1);
                }
            }
        } else {
            throw new Error("JSXGraph error: In JXG.Math.Poly.polynomial.sub either summand is undefined or rings don't match.");
        }
    },
    /**
         * Creates a deep copy of the polynomial.
         * @returns {JXG.Math.Poly.Polynomial}
         * @memberof JXG.Math.Poly.Polynomial
         */ copy: function() {
        var i, p;
        p = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Poly.Polynomial(this.ring);
        for(i = 0; i < this.monomials.length; i++){
            p.monomials.push(this.monomials[i].copy());
        }
        return p;
    },
    /**
         * Prints the polynomial.
         * @returns {String} A string representation of the polynomial.
         * @memberof JXG.Math.Poly.Polynomial
         */ print: function() {
        var s = [], i;
        for(i = 0; i < this.monomials.length; i++){
            s.push("(" + this.monomials[i].print() + ")");
        }
        return s.join("+");
    }
});
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Poly;
}),
"[project]/Documents/geometry_review/node_modules/jsxgraph/src/math/complex.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */ /*global JXG: true, define: true*/ /*jslint nomen: true, plusplus: true*/ /**
 * @fileoverview A class for complex arithmetics JXG.Complex is defined in this
 * file. Also a namespace JXG.C is included to provide instance-independent
 * arithmetic functions.
 */ __turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/jxg.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Documents/geometry_review/node_modules/jsxgraph/src/utils/type.js [app-client] (ecmascript)");
;
;
/**
 * Creates a new complex number. See also {@link JXG.C}.
 * @class This class is for calculating with complex numbers, see also {@link JXG.C} for more methods.
 * @constructor
 * @param {Number} [x=0] Real part.
 * @param {Number} [y=0] Imaginary part.
 * @see JXG.C
 */ __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Complex = function(x, y) {
    /**
     * This property is only to signalize that this object is of type JXG.Complex. Only
     * used internally to distinguish between normal JavaScript numbers and JXG.Complex numbers.
     * @type Boolean
     * @default true
     * @private
     */ this.isComplex = true;
    /* is the first argument a complex number? if it is,
     * extract real and imaginary part. */ if (x && x.isComplex) {
        y = x.imaginary;
        x = x.real;
    }
    /**
     * Real part of the complex number.
     * @type Number
     * @default 0
     */ this.real = x || 0;
    /**
     * Imaginary part of the complex number.
     * @type Number
     * @default 0
     */ this.imaginary = y || 0;
// /**
//  * Absolute value in the polar form of the complex number. Currently unused.
//  * @type Number
//  */
// this.absval = 0;
// /**
//  * Angle value in the polar form of the complex number. Currently unused.
//  * @type Number
//  */
// this.angle = 0;
};
__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].extend(__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Complex.prototype, /** @lends JXG.Complex.prototype */ {
    /**
         * Converts a complex number into a string.
         * @returns {String} Formatted string containing the complex number in human readable form (algebraic form).
         */ toString: function() {
        return this.real + " + " + this.imaginary + "i";
    },
    /**
         * Add another complex number to this complex number.
         * @param {JXG.Complex|Number} c A JavaScript number or a JXG.Complex object to be added to the current object.
         * @returns {JXG.Complex} Reference to this complex number
         */ add: function(c) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(c)) {
            this.real += c;
        } else {
            this.real += c.real;
            this.imaginary += c.imaginary;
        }
        return this;
    },
    /**
         * Subtract another complex number from this complex number.
         * @param {JXG.Complex|Number} c A JavaScript number or a JXG.Complex object to subtract from the current object.
         * @returns {JXG.Complex} Reference to this complex number
         */ sub: function(c) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(c)) {
            this.real -= c;
        } else {
            this.real -= c.real;
            this.imaginary -= c.imaginary;
        }
        return this;
    },
    /**
         * Multiply another complex number to this complex number.
         * @param {JXG.Complex|Number} c A JavaScript number or a JXG.Complex object to
         * multiply with the current object.
         * @returns {JXG.Complex} Reference to this complex number
         */ mult: function(c) {
        var re, im;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(c)) {
            this.real *= c;
            this.imaginary *= c;
        } else {
            re = this.real;
            im = this.imaginary;
            //  (a+ib)(x+iy) = ax-by + i(xb+ay)
            this.real = re * c.real - im * c.imaginary;
            this.imaginary = re * c.imaginary + im * c.real;
        }
        return this;
    },
    /**
         * Divide this complex number by the given complex number.
         * @param {JXG.Complex|Number} c A JavaScript number or a JXG.Complex object to
         * divide the current object by.
         * @returns {JXG.Complex} Reference to this complex number
         */ div: function(c) {
        var denom, im, re;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$utils$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(c)) {
            if (Math.abs(c) < Math.eps) {
                this.real = Infinity;
                this.imaginary = Infinity;
                return this;
            }
            this.real /= c;
            this.imaginary /= c;
        } else {
            //  (a+ib)(x+iy) = ax-by + i(xb+ay)
            if (Math.abs(c.real) < Math.eps && Math.abs(c.imaginary) < Math.eps) {
                this.real = Infinity;
                this.imaginary = Infinity;
                return this;
            }
            denom = c.real * c.real + c.imaginary * c.imaginary;
            re = this.real;
            im = this.imaginary;
            this.real = (re * c.real + im * c.imaginary) / denom;
            this.imaginary = (im * c.real - re * c.imaginary) / denom;
        }
        return this;
    },
    /**
         * Conjugate a complex number in place.
         * @returns {JXG.Complex} Reference to this complex number
         */ conj: function() {
        this.imaginary *= -1;
        return this;
    },
    /**
         * Absolute value in the polar form, i.e. |z| of the complex number z.
         * @returns Number
         */ abs: function() {
        var x = this.real, y = this.imaginary;
        return Math.sqrt(x * x + y * y);
    },
    /**
         * Angle value in the polar form of the complex number (in radians).
         * @returns Number
         */ angle: function() {
        return Math.atan2(this.imaginary, this.real);
    }
});
/**
 * @namespace Namespace for the complex number arithmetic functions, see also {@link JXG.Complex}.
 * @description
 * JXG.C is the complex number (name)space. It provides functions to calculate with
 * complex numbers (defined in {@link JXG.Complex}). With this namespace you don't have to modify
 * your existing complex numbers, e.g. to add two complex numbers:
 * <pre class="code">   var z1 = new JXG.Complex(1, 0);
 *    var z2 = new JXG.Complex(0, 1);
 *    z = JXG.C.add(z1, z1);</pre>
 * z1 and z2 here remain unmodified. With the object oriented approach above this
 * section the code would look like:
 * <pre class="code">
 *    var z1 = new JXG.Complex(1, 0);
 *    var z2 = new JXG.Complex(0, 1);
 *    var z = new JXG.Complex(z1);
 *    z.add(z2);</pre>
 * @see JXG.Complex
 */ __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].C = {};
/**
 * Add two (complex) numbers z1 and z2 and return the result as a (complex) number.
 * @param {JXG.Complex|Number} z1 Summand
 * @param {JXG.Complex|Number} z2 Summand
 * @returns {JXG.Complex} A complex number equal to the sum of the given parameters.
 */ __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].C.add = function(z1, z2) {
    var z = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Complex(z1);
    z.add(z2);
    return z;
};
/**
 * Subtract two (complex) numbers z1 and z2 and return the result as a (complex) number.
 * @param {JXG.Complex|Number} z1 Minuend
 * @param {JXG.Complex|Number} z2 Subtrahend
 * @returns {JXG.Complex} A complex number equal to the difference of the given parameters.
 */ __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].C.sub = function(z1, z2) {
    var z = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Complex(z1);
    z.sub(z2);
    return z;
};
/**
 * Multiply two (complex) numbers z1 and z2 and return the result as a (complex) number.
 * @param {JXG.Complex|Number} z1 Factor
 * @param {JXG.Complex|Number} z2 Factor
 * @returns {JXG.Complex} A complex number equal to the product of the given parameters.
 */ __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].C.mult = function(z1, z2) {
    var z = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Complex(z1);
    z.mult(z2);
    return z;
};
/**
 * Divide two (complex) numbers z1 and z2 and return the result as a (complex) number.
 * @param {JXG.Complex|Number} z1 Dividend
 * @param {JXG.Complex|Number} z2 Divisor
 * @returns {JXG.Complex} A complex number equal to the quotient of the given parameters.
 */ __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].C.div = function(z1, z2) {
    var z = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Complex(z1);
    z.div(z2);
    return z;
};
/**
 * Conjugate a complex number and return the result.
 * @param {JXG.Complex|Number} z1 Complex number
 * @returns {JXG.Complex} A complex number equal to the conjugate of the given parameter.
 */ __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].C.conj = function(z1) {
    var z = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Complex(z1);
    z.conj();
    return z;
};
/**
 * Absolute value of a complex number.
 * @param {JXG.Complex|Number} z1 Complex number
 * @returns {Number} real number equal to the absolute value of the given parameter.
 */ __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].C.abs = function(z1) {
    var z = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Complex(z1);
    // z.conj();
    // z.mult(z1);
    // return Math.sqrt(z.real);
    return z.abs();
};
/**
 * Angle of a complex number (in radians).
 * @param {JXG.Complex|Number} z1 Complex number
 * @returns {Number} real number equal to the angle value of the given parameter.
 */ __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].C.angle = function(z1) {
    var z = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Complex(z1);
    return z.angle();
};
/**
 * Create copy of complex number.
 *
 * @param {JXG.Complex|Number} z
 * @returns {JXG.Complex}
 */ __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].C.copy = function(z) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Complex(z);
};
__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Complex.C = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].C;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$geometry_review$2f$node_modules$2f$jsxgraph$2f$src$2f$jxg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Complex;
}),
]);

//# sourceMappingURL=c0305_jsxgraph_src_math_a10cfb61._.js.map